---
phase: 02-intent-agent
type: execute
domain: python-agent-sdk
---

<objective>
Create the follow-up question skill and complete the Intent Agent conversation flow.

Purpose: Enable natural conversation flow with intelligent follow-up questions to gather complete intent information.
Output: suggest_follow_up_questions tool and complete conversation management.
</objective>


<context>
@BRIEF.md
@ROADMAP.md
@plans/02-intent-agent/02-01-SUMMARY.md
@plans/02-intent-agent/02-02-SUMMARY.md
@plans/02-intent-agent/02-03-SUMMARY.md
</context>

<reasoning_guidance>
Thoroughly analyze conversation design patterns before implementing.
Consider the user experience of the intent gathering flow:
- How many questions feel natural vs interrogative?
- When is "good enough" for generating a story plan?
- How to gracefully handle vague or incomplete responses?

Deeply consider state machine design for conversation flow:
- What triggers transitions between states?
- How to recover from misunderstandings?
- When to summarize vs when to ask more?

Explore multiple approaches for follow-up question generation:
- Rule-based (explicit missing fields)
- Context-aware (based on last response)
- Adaptive (based on user engagement signals)
</reasoning_guidance>

<tasks>

<task type="auto">
  <n>Task 1: Implement suggest_follow_up_questions skill</n>
  <files>src/codestory/skills/intent.py</files>
  <action>
    Add follow-up question generation to IntentSkills:
    
    ```python
    # Add to IntentSkills class in src/codestory/skills/intent.py
    
    @skill(
        description="Generate contextual follow-up questions based on conversation progress"
    )
    @handle_skill_errors
    async def suggest_follow_up_questions(
        self,
        has_stated_goal: bool,
        has_background: bool,
        has_focus_areas: bool,
        has_time_preference: bool,
        conversation_turn: int,
        last_response_topic: str = "",
    ) -> dict:
        """Generate appropriate follow-up questions based on what's missing.
        
        Args:
            has_stated_goal: Whether user has stated their learning goal
            has_background: Whether user has shared technical background
            has_focus_areas: Whether user has identified specific interests
            has_time_preference: Whether user has indicated time preference
            conversation_turn: Current turn number in conversation
            last_response_topic: Topic of user's last response
        
        Returns:
            Suggested questions and conversation guidance
        """
        questions = []
        priority = "high"
        ready_to_generate = False
        
        # Early conversation - need basics
        if conversation_turn <= 2:
            if not has_stated_goal:
                questions.append({
                    "question": "What would you like to learn about this codebase?",
                    "purpose": "Understand primary learning goal",
                    "alternatives": [
                        "Are you trying to understand the overall architecture, or dive into a specific feature?",
                        "What brings you to explore this repository?",
                    ]
                })
                priority = "high"
            elif not has_background:
                questions.append({
                    "question": "How familiar are you with this type of project or technology?",
                    "purpose": "Gauge expertise level for appropriate depth",
                    "alternatives": [
                        "What's your experience with projects like this?",
                        "Are you new to this technology stack, or do you have prior experience?",
                    ]
                })
                priority = "high"
        
        # Mid conversation - gather specifics
        elif conversation_turn <= 4:
            if not has_focus_areas and has_stated_goal:
                questions.append({
                    "question": "Are there specific parts of the codebase you're most interested in?",
                    "purpose": "Identify focus areas for deeper coverage",
                    "alternatives": [
                        "Which components or features would you like me to emphasize?",
                        "Is there anything you've already looked at that you want to understand better?",
                    ]
                })
                priority = "medium"
            
            if not has_time_preference:
                questions.append({
                    "question": "How much time do you have? Would you prefer a quick overview or a comprehensive deep-dive?",
                    "purpose": "Calibrate story length and depth",
                    "alternatives": [
                        "Are you looking for a 5-minute summary or a 20-minute detailed exploration?",
                    ]
                })
                priority = "low"
        
        # Late conversation - ready to proceed
        else:
            if has_stated_goal and has_background:
                ready_to_generate = True
                questions.append({
                    "question": "I think I have a good understanding of what you need. Should I create your story plan now?",
                    "purpose": "Confirm readiness to generate plan",
                    "alternatives": [
                        "Is there anything else you'd like to add before I create your personalized story?",
                    ]
                })
                priority = "confirmation"
        
        # Determine conversation state
        info_gathered = sum([has_stated_goal, has_background, has_focus_areas, has_time_preference])
        completeness = info_gathered / 4.0
        
        return {
            "suggested_questions": questions,
            "priority": priority,
            "ready_to_generate_plan": ready_to_generate,
            "completeness": completeness,
            "missing_info": {
                "goal": not has_stated_goal,
                "background": not has_background,
                "focus_areas": not has_focus_areas,
                "time_preference": not has_time_preference,
            },
            "recommendation": self._get_conversation_recommendation(
                completeness, conversation_turn, ready_to_generate
            ),
        }
    
    def _get_conversation_recommendation(
        self,
        completeness: float,
        turn: int,
        ready: bool,
    ) -> str:
        """Get recommendation for conversation flow."""
        if ready:
            return "Ready to generate story plan. Confirm with user and use generate_story_plan."
        elif completeness >= 0.75:
            return "Nearly complete. Ask one final clarifying question or proceed to plan generation."
        elif completeness >= 0.5:
            return "Good progress. Focus on gathering specific interests or preferences."
        elif turn >= 3:
            return "Consider summarizing what you know and asking what's most important to the user."
        else:
            return "Continue natural conversation to understand user's needs."
    
    @skill(
        description="Summarize the conversation and confirm understanding with user"
    )
    @handle_skill_errors
    async def summarize_intent(
        self,
        stated_goal: str,
        expertise_level: str,
        focus_areas: list[str],
        preferred_style: str,
        time_preference: int,
    ) -> dict:
        """Create a summary of understood intent for user confirmation.
        
        Args:
            stated_goal: User's learning objective
            expertise_level: Assessed expertise level
            focus_areas: Identified areas of interest
            preferred_style: Selected narrative style
            time_preference: Preferred duration in minutes
        
        Returns:
            Formatted summary for user confirmation
        """
        # Format focus areas
        focus_str = ", ".join(focus_areas) if focus_areas else "the overall codebase"
        
        # Style descriptions
        style_descriptions = {
            "fiction": "an engaging story with characters and narrative",
            "documentary": "an informative documentary-style exploration",
            "tutorial": "a step-by-step learning guide",
            "podcast": "a conversational discussion",
            "technical": "a precise technical deep-dive",
        }
        style_desc = style_descriptions.get(preferred_style, "an informative exploration")
        
        # Expertise descriptions
        expertise_descriptions = {
            "beginner": "newcomer-friendly explanations",
            "intermediate": "balanced technical depth",
            "expert": "advanced technical details",
        }
        expertise_desc = expertise_descriptions.get(expertise_level, "appropriate explanations")
        
        summary = f"""Here's what I understand:

**Goal**: {stated_goal}

**Focus**: {focus_str}

**Style**: I'll create {style_desc} with {expertise_desc}.

**Length**: Approximately {time_preference} minutes.

Does this sound right?"""
        
        return {
            "summary": summary,
            "structured_intent": {
                "goal": stated_goal,
                "expertise": expertise_level,
                "focus_areas": focus_areas,
                "style": preferred_style,
                "duration_minutes": time_preference,
            },
            "ready_for_confirmation": True,
        }
    ```
    
    Avoid: Do NOT ask too many questions at once, do NOT skip conversation state tracking.
  </action>
  <verify>Follow-up question skill generates appropriate questions</verify>
  <done>suggest_follow_up_questions and summarize_intent skills</done>
</task>

<task type="auto">
  <n>Task 2: Add conversation state tracking to IntentSkills</n>
  <files>src/codestory/skills/intent.py</files>
  <action>
    Add conversation state management:
    
    ```python
    # Add to IntentSkills class
    
    @dataclass
    class ConversationState:
        """Tracks the state of an intent conversation."""
        turn_count: int = 0
        has_stated_goal: bool = False
        has_background: bool = False
        has_focus_areas: bool = False
        has_time_preference: bool = False
        stated_goal: str = ""
        technical_background: str = ""
        focus_areas: list[str] = field(default_factory=list)
        time_preference_minutes: int = 15
        preferred_style: str = "documentary"
        expertise_level: str = "intermediate"
        
        def update_from_message(self, message: str) -> None:
            """Update state based on user message content."""
            self.turn_count += 1
            message_lower = message.lower()
            
            # Detect goal statements
            goal_indicators = ["want to", "trying to", "need to", "looking to", "learn about", "understand"]
            if any(ind in message_lower for ind in goal_indicators):
                self.has_stated_goal = True
                self.stated_goal = message
            
            # Detect background information
            background_indicators = ["experience", "worked with", "familiar with", "new to", "years", "beginner", "expert"]
            if any(ind in message_lower for ind in background_indicators):
                self.has_background = True
                self.technical_background = message
            
            # Detect specific interests
            interest_indicators = ["interested in", "focus on", "specifically", "particular", "this part", "that section"]
            if any(ind in message_lower for ind in interest_indicators):
                self.has_focus_areas = True
            
            # Detect time preferences
            time_indicators = ["minutes", "quick", "brief", "detailed", "comprehensive", "short", "long"]
            if any(ind in message_lower for ind in time_indicators):
                self.has_time_preference = True
                # Try to extract time
                import re
                time_match = re.search(r'(\d+)\s*min', message_lower)
                if time_match:
                    self.time_preference_minutes = int(time_match.group(1))
        
        def is_complete(self) -> bool:
            """Check if enough information has been gathered."""
            return self.has_stated_goal and self.has_background
        
        def completeness_score(self) -> float:
            """Calculate how complete the conversation is."""
            factors = [
                self.has_stated_goal,
                self.has_background,
                self.has_focus_areas,
                self.has_time_preference,
            ]
            return sum(factors) / len(factors)
    
    
    # Add to IntentSkills __init__
    def __init__(self):
        super().__init__()
        self.conversation_state = ConversationState()
    
    def reset_conversation(self) -> None:
        """Reset conversation state for a new session."""
        self.conversation_state = ConversationState()
    
    def process_user_message(self, message: str) -> ConversationState:
        """Process a user message and update conversation state."""
        self.conversation_state.update_from_message(message)
        return self.conversation_state
    ```
    
    Add ConversationState to exports in __init__.py.
    
    Avoid: Do NOT reset state unintentionally, do NOT over-parse messages.
  </action>
  <verify>Conversation state tracks progress correctly</verify>
  <done>ConversationState class for tracking intent gathering progress</done>
</task>

<task type="auto">
  <n>Task 3: Finalize Intent Agent integration</n>
  <files>src/codestory/agents/intent.py</files>
  <action>
    Update IntentAgent to use conversation state:
    
    ```python
    # Update IntentAgent class
    
    async def continue_conversation(self, user_message: str) -> AgentResponse:
        """Continue the onboarding conversation.
        
        Args:
            user_message: User's response in the conversation
        
        Returns:
            Agent's next message
        """
        # Update conversation state in skills
        for skill in self.skills:
            if isinstance(skill, IntentSkills):
                skill.process_user_message(user_message)
                
                # Check if we should suggest generating plan
                if skill.conversation_state.is_complete():
                    self.intent_gathered = True
        
        response = await self.run(user_message)
        
        # Check if a story plan was generated
        for tool_call in response.tool_calls:
            if tool_call.get("name") == "generate_story_plan":
                self.intent_gathered = True
        
        return response
    
    def get_conversation_state(self) -> dict:
        """Get current conversation state."""
        for skill in self.skills:
            if isinstance(skill, IntentSkills):
                state = skill.conversation_state
                return {
                    "turn_count": state.turn_count,
                    "completeness": state.completeness_score(),
                    "has_goal": state.has_stated_goal,
                    "has_background": state.has_background,
                    "has_focus_areas": state.has_focus_areas,
                    "ready_to_generate": state.is_complete(),
                }
        return {}
    ```
    
    Avoid: Do NOT lose conversation context between turns.
  </action>
  <verify>IntentAgent integrates with conversation state</verify>
  <done>Complete IntentAgent with conversation flow management</done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] suggest_follow_up_questions generates appropriate questions
- [ ] ConversationState tracks all required information
- [ ] summarize_intent creates user-friendly summaries
- [ ] IntentAgent conversation flow works end-to-end
- [ ] Ready to generate story plans when conversation complete
</verification>

<success_criteria>
- Natural conversation flow with intelligent follow-ups
- State tracking for conversation progress
- Summary generation for user confirmation
- Complete Intent Agent ready for pipeline integration
</success_criteria>

<o>
After completion, create `plans/02-intent-agent/02-04-SUMMARY.md`

This completes Phase 2: Intent Agent. The Validation Gate should verify:
- IntentAgent can be instantiated and run
- Conversation flow tracks state correctly
- Story plans are generated with proper structure
- All skills registered and functional
</o>
