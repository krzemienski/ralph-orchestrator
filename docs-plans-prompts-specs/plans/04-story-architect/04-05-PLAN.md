---
phase: 04-story-architect
plan: 05
type: execute
domain: python-api
---

<objective>
Implement complete script assembly that combines chapters, transitions, and metadata into a final narrative script ready for voice synthesis.
</objective>

<context>
@BRIEF.md
@codestory/backend/skills/story/chapters.py
@codestory/backend/skills/story/transitions.py
</context>

<tasks>

<task type="auto">
  <n>Task 1: Create script assembly skill</n>
  <files>codestory/backend/skills/story/assembly.py</files>
  <action>
Create the script assembly module:

```python
"""Script assembly for Code Story narratives."""

from dataclasses import dataclass, field
from datetime import datetime
from typing import Any
import json

from backend.skills.decorators import skill
from backend.skills.story.styles import NarrativeStyle
from backend.skills.story.transitions import generate_transitions, calculate_pacing


@dataclass
class ScriptSegment:
    """A segment of the complete script."""
    
    segment_type: str  # "intro", "chapter", "transition", "outro"
    content: str
    chapter_number: int | None = None
    duration_estimate_seconds: float = 0
    voice_direction: dict[str, Any] = field(default_factory=dict)


@dataclass
class CompleteScript:
    """Complete assembled script ready for synthesis."""
    
    title: str
    repository_url: str
    style: NarrativeStyle
    segments: list[ScriptSegment]
    total_duration_seconds: float
    total_word_count: int
    chapter_count: int
    generated_at: str
    metadata: dict[str, Any] = field(default_factory=dict)
    
    def to_dict(self) -> dict[str, Any]:
        """Convert to dictionary for serialization."""
        return {
            "title": self.title,
            "repository_url": self.repository_url,
            "style": self.style.value,
            "segments": [
                {
                    "segment_type": s.segment_type,
                    "content": s.content,
                    "chapter_number": s.chapter_number,
                    "duration_estimate_seconds": s.duration_estimate_seconds,
                    "voice_direction": s.voice_direction,
                }
                for s in self.segments
            ],
            "total_duration_seconds": self.total_duration_seconds,
            "total_word_count": self.total_word_count,
            "chapter_count": self.chapter_count,
            "generated_at": self.generated_at,
            "metadata": self.metadata,
        }
    
    def to_json(self) -> str:
        """Serialize to JSON."""
        return json.dumps(self.to_dict(), indent=2)


INTRO_TEMPLATES = {
    NarrativeStyle.FICTION: "Welcome, traveler. Today we explore the realms of {repo_name}...",
    NarrativeStyle.DOCUMENTARY: "Welcome to Code Story. Today we examine {repo_name}...",
    NarrativeStyle.TUTORIAL: "Hey there! Today we're learning about {repo_name}...",
    NarrativeStyle.PODCAST: "What's up everyone! Today we're diving into {repo_name}...",
    NarrativeStyle.TECHNICAL: "Technical overview of {repo_name}. Beginning analysis...",
}

OUTRO_TEMPLATES = {
    NarrativeStyle.FICTION: "And so our adventure through {repo_name} comes to a close. Until next time...",
    NarrativeStyle.DOCUMENTARY: "This concludes our exploration of {repo_name}. Thank you for listening.",
    NarrativeStyle.TUTORIAL: "Great job! You've learned the key concepts of {repo_name}. Happy coding!",
    NarrativeStyle.PODCAST: "That's a wrap on {repo_name}! Thanks for tuning in. See you next time!",
    NarrativeStyle.TECHNICAL: "End of {repo_name} technical overview. Summary complete.",
}


def _extract_repo_name(url: str) -> str:
    """Extract repository name from URL."""
    # Handle github.com/owner/repo format
    parts = url.rstrip("/").split("/")
    return parts[-1] if parts else "this repository"


def _count_words(text: str) -> int:
    """Count words in text, excluding markers."""
    # Remove voice direction markers
    import re
    clean_text = re.sub(r'\[.*?\]', '', text)
    return len(clean_text.split())


def _estimate_duration(word_count: int) -> float:
    """Estimate speaking duration in seconds (150 words/minute average)."""
    return (word_count / 150) * 60


@skill(
    name="assemble_script",
    description="Assemble complete script from chapters and metadata",
)
async def assemble_script(
    chapters: list[dict[str, Any]],
    repository_url: str,
    style: str = "documentary",
    title: str | None = None,
    include_intro: bool = True,
    include_outro: bool = True,
) -> dict[str, Any]:
    """
    Assemble a complete script from chapter content.
    
    Args:
        chapters: List of chapter dictionaries with content
        repository_url: GitHub repository URL
        style: Narrative style to use
        title: Optional custom title
        include_intro: Whether to include intro segment
        include_outro: Whether to include outro segment
    
    Returns:
        Complete assembled script as dictionary
    """
    style_enum = NarrativeStyle(style)
    repo_name = _extract_repo_name(repository_url)
    
    segments: list[ScriptSegment] = []
    total_words = 0
    
    # Add intro
    if include_intro:
        intro_text = INTRO_TEMPLATES[style_enum].format(repo_name=repo_name)
        intro_words = _count_words(intro_text)
        segments.append(ScriptSegment(
            segment_type="intro",
            content=intro_text,
            duration_estimate_seconds=_estimate_duration(intro_words) + 2,  # +2s pause
            voice_direction={"pace": "slow", "emphasis": "warm"},
        ))
        total_words += intro_words
    
    # Generate transitions
    transitions = await generate_transitions(chapters, style)
    transition_map = {t["from_chapter"]: t["transition_text"] for t in transitions}
    
    # Add chapters with transitions
    for i, chapter in enumerate(chapters):
        chapter_num = i + 1
        content = chapter.get("content", chapter.get("script", ""))
        word_count = chapter.get("word_count", _count_words(content))
        
        segments.append(ScriptSegment(
            segment_type="chapter",
            content=content,
            chapter_number=chapter_num,
            duration_estimate_seconds=chapter.get(
                "duration_estimate_seconds", 
                _estimate_duration(word_count)
            ),
            voice_direction=chapter.get("voice_direction", {}),
        ))
        total_words += word_count
        
        # Add transition after chapter (except last)
        if chapter_num in transition_map:
            trans_text = transition_map[chapter_num]
            trans_words = _count_words(trans_text)
            segments.append(ScriptSegment(
                segment_type="transition",
                content=trans_text,
                duration_estimate_seconds=_estimate_duration(trans_words) + 3,  # +3s for pauses
                voice_direction={"pace": "slower"},
            ))
            total_words += trans_words
    
    # Add outro
    if include_outro:
        outro_text = OUTRO_TEMPLATES[style_enum].format(repo_name=repo_name)
        outro_words = _count_words(outro_text)
        segments.append(ScriptSegment(
            segment_type="outro",
            content=outro_text,
            duration_estimate_seconds=_estimate_duration(outro_words) + 2,  # +2s pause
            voice_direction={"pace": "slow", "emphasis": "warm"},
        ))
        total_words += outro_words
    
    # Calculate totals
    total_duration = sum(s.duration_estimate_seconds for s in segments)
    
    script = CompleteScript(
        title=title or f"Code Story: {repo_name}",
        repository_url=repository_url,
        style=style_enum,
        segments=segments,
        total_duration_seconds=total_duration,
        total_word_count=total_words,
        chapter_count=len(chapters),
        generated_at=datetime.utcnow().isoformat(),
        metadata={
            "has_intro": include_intro,
            "has_outro": include_outro,
            "transition_count": len(transitions),
        },
    )
    
    return script.to_dict()


@skill(
    name="get_script_for_synthesis",
    description="Get script content formatted for voice synthesis",
)
async def get_script_for_synthesis(
    assembled_script: dict[str, Any],
) -> list[dict[str, Any]]:
    """
    Extract synthesis-ready segments from assembled script.
    
    Returns list of segments with content and voice parameters.
    """
    synthesis_segments = []
    
    for segment in assembled_script.get("segments", []):
        synthesis_segments.append({
            "text": segment["content"],
            "segment_type": segment["segment_type"],
            "chapter_number": segment.get("chapter_number"),
            "voice_settings": _get_voice_settings(segment),
        })
    
    return synthesis_segments


def _get_voice_settings(segment: dict[str, Any]) -> dict[str, Any]:
    """Get ElevenLabs voice settings for segment."""
    direction = segment.get("voice_direction", {})
    
    # Map pace to stability/similarity_boost
    pace = direction.get("pace", "normal")
    settings = {
        "stability": 0.5,
        "similarity_boost": 0.75,
        "style": 0.0,
        "use_speaker_boost": True,
    }
    
    if pace == "slow":
        settings["stability"] = 0.6
    elif pace == "slower":
        settings["stability"] = 0.7
    elif pace == "fast":
        settings["stability"] = 0.4
    
    return settings
```
  </action>
  <verify>python -c "from codestory.backend.skills.story.assembly import assemble_script; print('Assembly OK')"</verify>
  <done>Script assembly skill created</done>
</task>

<task type="auto">
  <n>Task 2: Create StoryArchitectAgent integration</n>
  <files>codestory/backend/agents/story_architect.py</files>
  <action>
Update the Story Architect agent with full skill integration:

```python
"""Story Architect Agent for Code Story."""

from backend.agents.base import Agent
from backend.skills.story.chapters import generate_chapter, ChapterContent
from backend.skills.story.styles import NarrativeStyle, get_style_prompt
from backend.skills.story.transitions import generate_transitions, calculate_pacing
from backend.skills.story.assembly import assemble_script, get_script_for_synthesis


STORY_ARCHITECT_PROMPT = """You are the Story Architect agent for Code Story. Your role is to transform code analysis into compelling audio narratives.

## Your Capabilities

You create narrative scripts from repository analysis using these skills:
- generate_chapter: Create individual chapter scripts
- generate_transitions: Create smooth chapter transitions
- calculate_pacing: Calculate timing and pacing metrics
- assemble_script: Combine everything into a complete script
- get_script_for_synthesis: Prepare script for voice synthesis

## Narrative Process

When creating a story:

1. Review the repository analysis and user intent
2. Generate chapters that match the user's expertise level and interests
3. Use the appropriate narrative style (fiction, documentary, tutorial, podcast, technical)
4. Add transitions between chapters for smooth flow
5. Assemble the complete script with intro and outro
6. Prepare the script for voice synthesis

## Style Guidelines

Match your narrative approach to the user's chosen style:
- Fiction: Storytelling with characters and adventure
- Documentary: Informative, authoritative exploration
- Tutorial: Friendly, educational step-by-step
- Podcast: Conversational, engaging discussion
- Technical: Precise, detailed analysis

## Voice Direction Markers

Include markers for voice synthesis:
- [PAUSE Xs] - Pause for X seconds
- [EMPHASIS word] - Emphasize a word
- [SLOW] ... [/SLOW] - Slower section
- [CODE] ... [/CODE] - Code reading style

## Output Format

Your final output should be a complete assembled script ready for the Voice Director agent to synthesize into audio."""


class StoryArchitectAgent(Agent):
    """Agent that creates narrative scripts from code analysis."""
    
    def __init__(self):
        super().__init__(
            name="StoryArchitect",
            system_prompt=STORY_ARCHITECT_PROMPT,
            temperature=0.7,  # Creative for narrative
        )
        
        # Register skills
        self.register_skill(generate_chapter)
        self.register_skill(generate_transitions)
        self.register_skill(calculate_pacing)
        self.register_skill(assemble_script)
        self.register_skill(get_script_for_synthesis)
    
    async def create_story(
        self,
        analysis: dict,
        intent: dict,
        style: str = "documentary",
    ) -> dict:
        """
        Create a complete narrative script.
        
        Args:
            analysis: Repository analysis from Repo Analyzer
            intent: User intent from Intent Agent
            style: Narrative style to use
        
        Returns:
            Complete assembled script
        """
        # Build prompt with context
        prompt = f"""Create a Code Story narrative for this repository.

## Repository Analysis
{analysis}

## User Intent
- Category: {intent.get('category', 'general_onboarding')}
- Expertise: {intent.get('expertise_level', 'intermediate')}
- Focus Areas: {intent.get('focus_areas', [])}
- Goals: {intent.get('learning_goals', [])}
- Style: {style}

## Instructions

1. Use generate_chapter to create each chapter based on the user's focus areas
2. Use generate_transitions to create transitions between chapters
3. Use calculate_pacing to verify timing
4. Use assemble_script to create the final output
5. Return the assembled script

Create a compelling, well-paced narrative that matches the user's expertise level and learning goals."""

        response = await self.run(prompt)
        return response
```
  </action>
  <verify>python -c "from codestory.backend.agents.story_architect import StoryArchitectAgent; print('StoryArchitect OK')"</verify>
  <done>StoryArchitectAgent updated with full integration</done>
</task>

</tasks>

<playwright_validation_gate>
```
# Full story generation flow
analysis = repo_analyzer.analyze(github_url)
intent = intent_agent.get_intent(conversation)
script = story_architect.create_story(analysis, intent, style="documentary")

Assert: script["segments"] has length > 3
Assert: script["total_duration_seconds"] > 60
Assert: script["chapter_count"] >= 2
Assert: any segment has type "intro"
Assert: any segment has type "outro"
```
</playwright_validation_gate>
