# Plan 03-04: Architectural Pattern Recognition Skill

## Overview

**Phase**: 3 - Repo Analyzer Agent
**Plan**: 04 of 05
**Depends on**: 03-03 (Python AST Analysis)
**Enables**: 03-05 (Key Component Identification)

## Goal

Create a skill that identifies architectural patterns, design patterns, and structural conventions in analyzed repositories. This builds on AST analysis to provide higher-level insights about how the codebase is organized.

## Reasoning Guidance

Thoroughly analyze pattern detection heuristics before implementing. Pattern recognition involves subjective judgments - consider:

- **False positive vs false negative trade-offs**: A directory named "models" doesn't guarantee MVC. What confidence threshold balances accuracy vs usefulness?
- **Pattern overlap**: Many patterns share similar indicators (Factory vs Builder vs Abstract Factory). How to disambiguate?
- **Framework-specific conventions**: Django's patterns differ from FastAPI's. How to weight framework knowledge?
- **Partial implementations**: Real codebases often partially implement patterns. How to handle incomplete matches?

Consider multiple detection approaches:
- Rule-based (explicit indicators) - fast, interpretable, brittle
- Statistical (frequency analysis) - robust, requires calibration
- Structural (graph matching) - accurate, computationally expensive

The heuristic approach chosen here prioritizes interpretability and explainability over precision.

## Confidence Levels

Pattern detection confidence varies by indicator type:

| Detection Type | Confidence | Rationale |
|---------------|------------|-----------|
| Framework detection (FastAPI, Django) | HIGH | Explicit dependency markers |
| Directory-based architecture (MVC, Layered) | MEDIUM | Conventions vary by team |
| Class naming patterns (Repository, Factory) | MEDIUM | Naming is suggestive not definitive |
| Code pattern matching (Singleton _instance) | LOW-MEDIUM | Implementation varies widely |
| Anti-pattern detection | LOW | Highly subjective, context-dependent |

When reporting patterns, always include evidence and acknowledge uncertainty for lower-confidence matches.

## Tasks

### Task 1: Pattern Detection Engine

Create the pattern recognition skill with detectors for common architectural and design patterns.

**File**: `src/skills/analysis/pattern_skills.py`

```python
"""Architectural and design pattern recognition skills."""

from dataclasses import dataclass, field
from enum import Enum
from typing import Any

from src.skills.base import Skill, skill, handle_skill_errors


class ArchitecturalPattern(str, Enum):
    """High-level architectural patterns."""
    MVC = "mvc"
    MVP = "mvp"
    MVVM = "mvvm"
    LAYERED = "layered"
    MICROSERVICES = "microservices"
    MONOLITH = "monolith"
    EVENT_DRIVEN = "event_driven"
    HEXAGONAL = "hexagonal"
    CLEAN = "clean_architecture"
    CQRS = "cqrs"
    SERVERLESS = "serverless"


class DesignPattern(str, Enum):
    """GoF and common design patterns."""
    SINGLETON = "singleton"
    FACTORY = "factory"
    ABSTRACT_FACTORY = "abstract_factory"
    BUILDER = "builder"
    PROTOTYPE = "prototype"
    ADAPTER = "adapter"
    DECORATOR = "decorator"
    FACADE = "facade"
    PROXY = "proxy"
    OBSERVER = "observer"
    STRATEGY = "strategy"
    COMMAND = "command"
    STATE = "state"
    REPOSITORY = "repository"
    UNIT_OF_WORK = "unit_of_work"
    DEPENDENCY_INJECTION = "dependency_injection"


@dataclass
class PatternMatch:
    """Represents a detected pattern with evidence."""
    pattern_type: str
    pattern_name: str
    confidence: float  # 0.0 to 1.0
    evidence: list[str] = field(default_factory=list)
    locations: list[str] = field(default_factory=list)
    description: str = ""

    def to_dict(self) -> dict[str, Any]:
        return {
            "pattern_type": self.pattern_type,
            "pattern_name": self.pattern_name,
            "confidence": self.confidence,
            "evidence": self.evidence,
            "locations": self.locations,
            "description": self.description,
        }


@dataclass
class PatternAnalysisResult:
    """Complete pattern analysis for a repository."""
    architectural_patterns: list[PatternMatch] = field(default_factory=list)
    design_patterns: list[PatternMatch] = field(default_factory=list)
    framework_patterns: list[PatternMatch] = field(default_factory=list)
    conventions: list[str] = field(default_factory=list)
    anti_patterns: list[PatternMatch] = field(default_factory=list)

    def to_dict(self) -> dict[str, Any]:
        return {
            "architectural_patterns": [p.to_dict() for p in self.architectural_patterns],
            "design_patterns": [p.to_dict() for p in self.design_patterns],
            "framework_patterns": [p.to_dict() for p in self.framework_patterns],
            "conventions": self.conventions,
            "anti_patterns": [p.to_dict() for p in self.anti_patterns],
        }


# Pattern detection rules
ARCHITECTURAL_INDICATORS = {
    ArchitecturalPattern.MVC: {
        "directories": ["models", "views", "controllers"],
        "files": ["controller.py", "view.py", "model.py"],
        "imports": ["flask", "django", "rails"],
    },
    ArchitecturalPattern.LAYERED: {
        "directories": ["presentation", "business", "data", "domain", "infrastructure"],
        "files": ["service.py", "repository.py", "entity.py"],
    },
    ArchitecturalPattern.HEXAGONAL: {
        "directories": ["adapters", "ports", "domain", "application"],
        "files": ["port.py", "adapter.py"],
    },
    ArchitecturalPattern.CLEAN: {
        "directories": ["entities", "use_cases", "interfaces", "frameworks"],
        "files": ["use_case.py", "interactor.py"],
    },
    ArchitecturalPattern.MICROSERVICES: {
        "directories": ["services", "api-gateway"],
        "files": ["docker-compose.yml", "kubernetes"],
        "indicators": ["multiple_services", "api_gateway"],
    },
    ArchitecturalPattern.EVENT_DRIVEN: {
        "imports": ["kafka", "rabbitmq", "celery", "dramatiq"],
        "files": ["events.py", "handlers.py", "subscribers.py"],
    },
    ArchitecturalPattern.CQRS: {
        "directories": ["commands", "queries"],
        "files": ["command.py", "query.py", "command_handler.py", "query_handler.py"],
    },
}

DESIGN_PATTERN_SIGNATURES = {
    DesignPattern.SINGLETON: {
        "code_patterns": ["_instance", "__new__", "getInstance"],
        "class_patterns": ["Singleton", "single_instance"],
    },
    DesignPattern.FACTORY: {
        "code_patterns": ["create_", "make_", "build_"],
        "class_patterns": ["Factory", "Creator", "Builder"],
        "method_patterns": ["create", "make", "build", "get_instance"],
    },
    DesignPattern.REPOSITORY: {
        "class_patterns": ["Repository", "Repo"],
        "method_patterns": ["find", "save", "delete", "get_by_id", "get_all"],
    },
    DesignPattern.STRATEGY: {
        "code_patterns": ["strategy", "algorithm"],
        "class_patterns": ["Strategy", "Policy"],
    },
    DesignPattern.OBSERVER: {
        "code_patterns": ["subscribe", "notify", "observer", "listener"],
        "class_patterns": ["Observer", "Listener", "Subscriber", "Publisher"],
    },
    DesignPattern.DECORATOR: {
        "code_patterns": ["@", "wrapper", "decorated"],
        "class_patterns": ["Decorator", "Wrapper"],
    },
    DesignPattern.DEPENDENCY_INJECTION: {
        "code_patterns": ["inject", "container", "provider"],
        "imports": ["dependency_injector", "inject", "punq"],
    },
    DesignPattern.COMMAND: {
        "class_patterns": ["Command", "Handler"],
        "method_patterns": ["execute", "handle", "run"],
    },
}


class PatternSkills(Skill):
    """Skills for detecting architectural and design patterns."""

    @skill(
        name="detect_architectural_patterns",
        description="Analyze repository structure to identify high-level architectural patterns like MVC, layered, hexagonal, etc.",
    )
    @handle_skill_errors
    async def detect_architectural_patterns(
        self,
        directory_structure: list[str],
        file_list: list[str],
        imports_found: list[str],
    ) -> dict[str, Any]:
        """
        Detect architectural patterns from repository structure.
        
        Args:
            directory_structure: List of directory paths in the repository
            file_list: List of file paths in the repository
            imports_found: List of import statements found in codebase
        
        Returns:
            Dictionary containing detected architectural patterns with confidence scores
        """
        detected_patterns: list[PatternMatch] = []
        
        # Normalize inputs
        dirs_lower = [d.lower() for d in directory_structure]
        files_lower = [f.lower() for f in file_list]
        imports_lower = [i.lower() for i in imports_found]
        
        for pattern, indicators in ARCHITECTURAL_INDICATORS.items():
            evidence = []
            confidence = 0.0
            locations = []
            
            # Check directories
            if "directories" in indicators:
                for dir_pattern in indicators["directories"]:
                    matches = [d for d in dirs_lower if dir_pattern in d]
                    if matches:
                        evidence.append(f"Directory pattern '{dir_pattern}' found")
                        locations.extend(matches[:3])
                        confidence += 0.3 / len(indicators["directories"])
            
            # Check files
            if "files" in indicators:
                for file_pattern in indicators["files"]:
                    matches = [f for f in files_lower if file_pattern in f]
                    if matches:
                        evidence.append(f"File pattern '{file_pattern}' found")
                        locations.extend(matches[:3])
                        confidence += 0.3 / len(indicators["files"])
            
            # Check imports
            if "imports" in indicators:
                for import_pattern in indicators["imports"]:
                    if any(import_pattern in imp for imp in imports_lower):
                        evidence.append(f"Import '{import_pattern}' suggests pattern")
                        confidence += 0.2 / len(indicators["imports"])
            
            # Only include if confidence is meaningful
            if confidence >= 0.2 and evidence:
                detected_patterns.append(PatternMatch(
                    pattern_type="architectural",
                    pattern_name=pattern.value,
                    confidence=min(confidence, 1.0),
                    evidence=evidence,
                    locations=locations[:5],
                    description=self._get_pattern_description(pattern),
                ))
        
        # Sort by confidence
        detected_patterns.sort(key=lambda x: x.confidence, reverse=True)
        
        return {
            "patterns": [p.to_dict() for p in detected_patterns],
            "primary_pattern": detected_patterns[0].to_dict() if detected_patterns else None,
            "pattern_count": len(detected_patterns),
        }

    @skill(
        name="detect_design_patterns",
        description="Analyze code structure to identify design patterns like Factory, Singleton, Repository, Observer, etc.",
    )
    @handle_skill_errors
    async def detect_design_patterns(
        self,
        class_definitions: list[dict[str, Any]],
        function_definitions: list[dict[str, Any]],
        code_snippets: list[str],
    ) -> dict[str, Any]:
        """
        Detect design patterns from code structure.
        
        Args:
            class_definitions: List of class info dicts with 'name', 'methods', 'bases'
            function_definitions: List of function info dicts with 'name', 'decorators'
            code_snippets: List of code snippets to analyze for patterns
        
        Returns:
            Dictionary containing detected design patterns with evidence
        """
        detected_patterns: list[PatternMatch] = []
        
        class_names = [c.get("name", "").lower() for c in class_definitions]
        method_names = []
        for cls in class_definitions:
            method_names.extend([m.lower() for m in cls.get("methods", [])])
        
        func_names = [f.get("name", "").lower() for f in function_definitions]
        all_code = " ".join(code_snippets).lower()
        
        for pattern, signatures in DESIGN_PATTERN_SIGNATURES.items():
            evidence = []
            confidence = 0.0
            locations = []
            
            # Check class name patterns
            if "class_patterns" in signatures:
                for class_pattern in signatures["class_patterns"]:
                    matches = [c for c in class_names if class_pattern.lower() in c]
                    if matches:
                        evidence.append(f"Class naming suggests {pattern.value}")
                        locations.extend(matches[:3])
                        confidence += 0.35 / len(signatures["class_patterns"])
            
            # Check method patterns
            if "method_patterns" in signatures:
                for method_pattern in signatures["method_patterns"]:
                    if any(method_pattern in m for m in method_names + func_names):
                        evidence.append(f"Method '{method_pattern}' indicates pattern")
                        confidence += 0.25 / len(signatures["method_patterns"])
            
            # Check code patterns
            if "code_patterns" in signatures:
                for code_pattern in signatures["code_patterns"]:
                    if code_pattern.lower() in all_code:
                        evidence.append(f"Code contains '{code_pattern}'")
                        confidence += 0.2 / len(signatures["code_patterns"])
            
            if confidence >= 0.2 and evidence:
                detected_patterns.append(PatternMatch(
                    pattern_type="design",
                    pattern_name=pattern.value,
                    confidence=min(confidence, 1.0),
                    evidence=evidence,
                    locations=locations[:5],
                    description=self._get_design_pattern_description(pattern),
                ))
        
        detected_patterns.sort(key=lambda x: x.confidence, reverse=True)
        
        return {
            "patterns": [p.to_dict() for p in detected_patterns],
            "pattern_count": len(detected_patterns),
            "top_patterns": [p.pattern_name for p in detected_patterns[:5]],
        }

    @skill(
        name="detect_framework_patterns",
        description="Identify framework-specific patterns and conventions based on dependencies and code structure.",
    )
    @handle_skill_errors
    async def detect_framework_patterns(
        self,
        dependencies: list[str],
        file_structure: list[str],
        config_files: list[str],
    ) -> dict[str, Any]:
        """
        Detect framework-specific patterns.
        
        Args:
            dependencies: List of project dependencies/packages
            file_structure: List of file paths
            config_files: List of configuration file names
        
        Returns:
            Dictionary containing detected framework patterns
        """
        patterns: list[PatternMatch] = []
        deps_lower = [d.lower() for d in dependencies]
        files_lower = [f.lower() for f in file_structure]
        
        # FastAPI patterns
        if "fastapi" in deps_lower:
            evidence = ["FastAPI dependency detected"]
            if any("routers" in f or "routes" in f for f in files_lower):
                evidence.append("Router-based organization")
            if any("schemas" in f or "models" in f for f in files_lower):
                evidence.append("Pydantic schema separation")
            patterns.append(PatternMatch(
                pattern_type="framework",
                pattern_name="fastapi_standard",
                confidence=0.8,
                evidence=evidence,
                description="FastAPI with routers and Pydantic schemas",
            ))
        
        # Django patterns
        if "django" in deps_lower:
            evidence = ["Django framework detected"]
            if any("apps.py" in f for f in files_lower):
                evidence.append("Django app structure")
            if any("admin.py" in f for f in files_lower):
                evidence.append("Django admin integration")
            patterns.append(PatternMatch(
                pattern_type="framework",
                pattern_name="django_standard",
                confidence=0.85,
                evidence=evidence,
                description="Standard Django project structure",
            ))
        
        # React patterns
        if "react" in deps_lower or any("jsx" in f or "tsx" in f for f in files_lower):
            evidence = ["React framework detected"]
            if any("components" in f for f in files_lower):
                evidence.append("Component-based architecture")
            if any("hooks" in f for f in files_lower):
                evidence.append("Custom hooks pattern")
            if any("context" in f for f in files_lower):
                evidence.append("React Context for state")
            patterns.append(PatternMatch(
                pattern_type="framework",
                pattern_name="react_component",
                confidence=0.75,
                evidence=evidence,
                description="React component-based architecture",
            ))
        
        # Next.js patterns
        if "next" in deps_lower:
            evidence = ["Next.js framework detected"]
            if any("app/" in f or "pages/" in f for f in files_lower):
                evidence.append("File-based routing")
            if any("api/" in f for f in files_lower):
                evidence.append("API routes")
            patterns.append(PatternMatch(
                pattern_type="framework",
                pattern_name="nextjs_app",
                confidence=0.8,
                evidence=evidence,
                description="Next.js with App Router or Pages Router",
            ))
        
        # Express patterns
        if "express" in deps_lower:
            evidence = ["Express.js detected"]
            if any("middleware" in f for f in files_lower):
                evidence.append("Middleware architecture")
            if any("routes" in f for f in files_lower):
                evidence.append("Route separation")
            patterns.append(PatternMatch(
                pattern_type="framework",
                pattern_name="express_mvc",
                confidence=0.7,
                evidence=evidence,
                description="Express.js MVC-style pattern",
            ))
        
        return {
            "patterns": [p.to_dict() for p in patterns],
            "frameworks_detected": [p.pattern_name for p in patterns],
            "pattern_count": len(patterns),
        }

    def _get_pattern_description(self, pattern: ArchitecturalPattern) -> str:
        """Get human-readable description of architectural pattern."""
        descriptions = {
            ArchitecturalPattern.MVC: "Model-View-Controller separates data, presentation, and control logic",
            ArchitecturalPattern.LAYERED: "Layered architecture with distinct presentation, business, and data layers",
            ArchitecturalPattern.HEXAGONAL: "Hexagonal/Ports & Adapters isolates core domain from external systems",
            ArchitecturalPattern.CLEAN: "Clean Architecture with entities, use cases, and interface adapters",
            ArchitecturalPattern.MICROSERVICES: "Microservices with independent, loosely-coupled services",
            ArchitecturalPattern.EVENT_DRIVEN: "Event-driven architecture using message queues and event handlers",
            ArchitecturalPattern.CQRS: "Command Query Responsibility Segregation separates reads from writes",
            ArchitecturalPattern.MONOLITH: "Monolithic application with all functionality in single deployment",
        }
        return descriptions.get(pattern, "")

    def _get_design_pattern_description(self, pattern: DesignPattern) -> str:
        """Get human-readable description of design pattern."""
        descriptions = {
            DesignPattern.SINGLETON: "Singleton ensures only one instance exists globally",
            DesignPattern.FACTORY: "Factory creates objects without specifying exact class",
            DesignPattern.REPOSITORY: "Repository abstracts data persistence behind collection-like interface",
            DesignPattern.STRATEGY: "Strategy defines family of interchangeable algorithms",
            DesignPattern.OBSERVER: "Observer notifies dependents of state changes",
            DesignPattern.DECORATOR: "Decorator adds behavior to objects dynamically",
            DesignPattern.DEPENDENCY_INJECTION: "Dependency Injection provides dependencies externally",
            DesignPattern.COMMAND: "Command encapsulates requests as objects",
        }
        return descriptions.get(pattern, "")
```

### Task 2: Pattern Analysis Integration

Update the Repo Analyzer Agent to incorporate pattern detection into analysis workflow.

**File**: `src/skills/analysis/__init__.py`

```python
"""Analysis skills package."""

from src.skills.analysis.ast_skills import ASTSkills
from src.skills.analysis.pattern_skills import (
    PatternSkills,
    PatternMatch,
    PatternAnalysisResult,
    ArchitecturalPattern,
    DesignPattern,
)

__all__ = [
    "ASTSkills",
    "PatternSkills",
    "PatternMatch",
    "PatternAnalysisResult",
    "ArchitecturalPattern",
    "DesignPattern",
]
```

**Update to**: `src/agents/repo_analyzer.py` (add pattern skills)

```python
# Add to imports
from src.skills.analysis.pattern_skills import PatternSkills

# Update RepoAnalyzerAgent.__init__
def __init__(self, api_key: str):
    super().__init__(
        name="repo_analyzer",
        system_prompt=REPO_ANALYZER_SYSTEM_PROMPT,
        api_key=api_key,
        temperature=0.3,
    )
    self.register_skill(GitHubSkills())
    self.register_skill(ASTSkills())
    self.register_skill(PatternSkills())  # Add pattern skills
```

## Files Created/Modified

| File | Action | Purpose |
|------|--------|---------|
| `src/skills/analysis/pattern_skills.py` | Create | Pattern detection engine with architectural and design pattern recognition |
| `src/skills/analysis/__init__.py` | Update | Export pattern skill classes |
| `src/agents/repo_analyzer.py` | Update | Register PatternSkills with agent |

## Dependencies

- Plan 03-03 (AST Analysis Skill) provides class/function definitions input
- Plan 03-02 (GitHub API) provides repository structure

## Validation Criteria

1. PatternSkills instantiates without errors
2. detect_architectural_patterns identifies MVC pattern from Flask/Django repos
3. detect_design_patterns finds Repository pattern from class names
4. detect_framework_patterns correctly identifies FastAPI, Django, React projects
5. Confidence scores are between 0.0 and 1.0
6. Evidence lists contain meaningful descriptions
7. Patterns are sorted by confidence descending

## Notes

- Pattern detection is heuristic-based (no ML required)
- Confidence thresholds tuned to minimize false positives
- Framework patterns help Story Architect tailor narratives
- Anti-pattern detection deferred to future enhancement
