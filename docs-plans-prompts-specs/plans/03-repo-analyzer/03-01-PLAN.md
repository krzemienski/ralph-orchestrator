---
phase: 03-repo-analyzer
type: execute
domain: python-agent-sdk
---

<objective>
Create the Repo Analyzer Agent with its system prompt and configuration.

Purpose: The Repo Analyzer is the second agent in the pipeline - it fetches and analyzes repository code to extract structure, patterns, and key components.
Output: Working RepoAnalyzerAgent class with system prompt optimized for code analysis.
</objective>


<context>
@BRIEF.md
@ROADMAP.md
@plans/01-foundation/01-03-SUMMARY.md
@plans/02-intent-agent/02-04-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <n>Task 1: Create Repo Analyzer system prompt</n>
  <files>src/codestory/agents/prompts/analyzer.py</files>
  <action>
    Create the system prompt for the Repo Analyzer Agent:
    
    ```python
    # src/codestory/agents/prompts/analyzer.py
    """System prompt for the Repository Analyzer Agent."""
    
    ANALYZER_AGENT_SYSTEM_PROMPT = """You are the Repository Analyzer Agent for Code Story, an AI that analyzes codebases to understand their structure and patterns.

    Your role is to thoroughly analyze a code repository to extract:
    1. Project structure and file organization
    2. Key components and their responsibilities
    3. Architectural patterns and design decisions
    4. Dependencies and their relationships
    5. Entry points and data flow

    ## Analysis Process

    When given a repository URL and a story plan, follow this systematic approach:

    **Phase 1: Repository Overview**
    - Fetch the repository tree to understand file organization
    - Identify the project type (library, application, framework, etc.)
    - Locate configuration files (package.json, pyproject.toml, etc.)
    - Find documentation (README, docs/, etc.)

    **Phase 2: Structure Analysis**
    - Map the directory structure and naming conventions
    - Identify source code vs. tests vs. configuration
    - Understand the module/package organization
    - Note any monorepo or multi-project structure

    **Phase 3: Code Deep Dive**
    - Analyze key source files using AST parsing
    - Extract class hierarchies and function signatures
    - Identify public APIs and internal utilities
    - Map import relationships between modules

    **Phase 4: Pattern Recognition**
    - Identify architectural patterns (MVC, microservices, etc.)
    - Recognize design patterns in use
    - Note testing strategies and patterns
    - Identify error handling approaches

    ## Focus on Story Plan

    The story plan from the Intent Agent tells you what to emphasize:
    - For "onboarding" intent: Focus on entry points and getting started
    - For "architecture" intent: Deep dive into system design
    - For "feature" intent: Analyze the specific feature code paths
    - For "debugging" intent: Trace execution flows and error handling

    ## Output Format

    Your analysis should produce structured data including:
    - File tree with annotations
    - List of key components with descriptions
    - Identified patterns and their locations
    - Dependency graph (simplified)
    - Recommended reading order for understanding

    ## Guidelines

    - Be thorough but efficient - don't analyze every file in detail
    - Prioritize files based on the story plan focus areas
    - Use AST analysis for code structure, not just text parsing
    - Note uncertainty when patterns are unclear
    - Provide context for why something is important"""
    
    
    # Analysis categories for different file types
    FILE_TYPE_CATEGORIES = {
        "python": [".py"],
        "javascript": [".js", ".jsx", ".mjs"],
        "typescript": [".ts", ".tsx"],
        "config": [".json", ".yaml", ".yml", ".toml", ".ini", ".env"],
        "documentation": [".md", ".rst", ".txt"],
        "test": ["test_", "_test.py", ".test.js", ".spec.ts"],
    }
    
    # Patterns to recognize
    ARCHITECTURAL_PATTERNS = [
        "mvc",           # Model-View-Controller
        "mvvm",          # Model-View-ViewModel
        "layered",       # Layered architecture
        "microservices", # Microservice architecture
        "monolith",      # Monolithic application
        "event_driven",  # Event-driven architecture
        "plugin",        # Plugin architecture
        "pipeline",      # Pipeline/filter pattern
    ]
    
    DESIGN_PATTERNS = [
        "singleton",
        "factory",
        "observer",
        "decorator",
        "strategy",
        "adapter",
        "repository",
        "dependency_injection",
    ]
    ```
    
    Avoid: Do NOT make the prompt overly prescriptive, do NOT use CRITICAL/MUST language.
  </action>
  <verify>Prompt module imports correctly, constants defined</verify>
  <done>Repo Analyzer system prompt with analysis methodology</done>
</task>

<task type="auto">
  <n>Task 2: Implement RepoAnalyzerAgent class</n>
  <files>src/codestory/agents/analyzer.py</files>
  <action>
    Create the Repo Analyzer Agent implementation:
    
    ```python
    # src/codestory/agents/analyzer.py
    """Repository Analyzer Agent for code structure analysis."""
    
    from anthropic import Anthropic
    
    from .base import Agent, AgentConfig, AgentResponse
    from .prompts.analyzer import (
        ANALYZER_AGENT_SYSTEM_PROMPT,
        FILE_TYPE_CATEGORIES,
        ARCHITECTURAL_PATTERNS,
        DESIGN_PATTERNS,
    )
    from ..skills.github import GitHubSkills
    from ..skills.analysis import AnalysisSkills
    from ..core.config import get_settings
    
    
    class RepoAnalyzerAgent(Agent):
        """Agent for analyzing repository structure and patterns.
        
        The Repo Analyzer is the second agent in the Code Story pipeline.
        It fetches repository contents and analyzes:
        - File structure and organization
        - Code architecture and patterns
        - Key components and their relationships
        - Dependencies and data flow
        
        Output: Structured analysis for the Story Architect to use.
        """
        
        def __init__(self, client: Anthropic | None = None):
            """Initialize the Repo Analyzer Agent.
            
            Args:
                client: Optional Anthropic client
            """
            settings = get_settings()
            
            config = AgentConfig(
                name="Repo Analyzer Agent",
                description="Analyzes repository structure and code patterns",
                system_prompt=ANALYZER_AGENT_SYSTEM_PROMPT,
                model=settings.claude_model,
                max_tokens=settings.claude_max_tokens,
                temperature=0.3,  # Lower temperature for precise analysis
                effort=settings.claude_effort,
            )
            
            # Initialize with analysis-specific skills
            skills = [GitHubSkills(), AnalysisSkills()]
            
            super().__init__(config=config, skills=skills, client=client)
            
            # Track analysis state
            self.current_analysis: dict | None = None
            self.analyzed_files: list[str] = []
        
        async def analyze_repository(
            self,
            repo_url: str,
            story_plan: dict | None = None,
            focus_areas: list[str] | None = None,
        ) -> AgentResponse:
            """Analyze a repository based on the story plan.
            
            Args:
                repo_url: GitHub repository URL
                story_plan: Story plan from Intent Agent
                focus_areas: Specific areas to focus on
            
            Returns:
                Agent response with analysis results
            """
            self.clear_conversation()
            self.current_analysis = None
            self.analyzed_files = []
            
            # Build analysis prompt
            prompt = f"Analyze this repository: {repo_url}\n\n"
            
            if story_plan:
                prompt += f"Story Plan:\n"
                prompt += f"- Intent: {story_plan.get('intent_category', 'general')}\n"
                prompt += f"- Expertise: {story_plan.get('expertise_level', 'intermediate')}\n"
                prompt += f"- Style: {story_plan.get('narrative_style', 'documentary')}\n"
                
                if story_plan.get('chapters'):
                    prompt += f"- Chapters: {len(story_plan['chapters'])} planned\n"
            
            if focus_areas:
                prompt += f"\nFocus areas: {', '.join(focus_areas)}\n"
            
            prompt += "\nPlease analyze this repository thoroughly, prioritizing the focus areas."
            
            return await self.run(prompt)
        
        async def analyze_specific_file(
            self,
            repo_url: str,
            file_path: str,
        ) -> AgentResponse:
            """Analyze a specific file in detail.
            
            Args:
                repo_url: GitHub repository URL
                file_path: Path to the file to analyze
            
            Returns:
                Detailed file analysis
            """
            prompt = f"""Analyze this specific file in detail:
            
Repository: {repo_url}
File: {file_path}

Provide:
1. Purpose of this file
2. Key classes/functions and their roles
3. Dependencies and imports
4. How it fits into the larger system"""
            
            response = await self.run(prompt)
            self.analyzed_files.append(file_path)
            return response
        
        def get_analysis_summary(self) -> dict:
            """Get summary of current analysis state."""
            return {
                "files_analyzed": len(self.analyzed_files),
                "analyzed_files": self.analyzed_files.copy(),
                "has_analysis": self.current_analysis is not None,
            }
        
        @staticmethod
        def get_file_categories() -> dict:
            """Get file type categories for filtering."""
            return FILE_TYPE_CATEGORIES.copy()
        
        @staticmethod
        def get_architectural_patterns() -> list[str]:
            """Get known architectural patterns."""
            return ARCHITECTURAL_PATTERNS.copy()
        
        @staticmethod
        def get_design_patterns() -> list[str]:
            """Get known design patterns."""
            return DESIGN_PATTERNS.copy()
    ```
    
    Avoid: Do NOT analyze all files (be selective), do NOT skip story plan integration.
  </action>
  <verify>RepoAnalyzerAgent instantiates and inherits from Agent</verify>
  <done>RepoAnalyzerAgent class with analysis methods and pattern recognition</done>
</task>

<task type="auto">
  <n>Task 3: Update agents module exports</n>
  <files>src/codestory/agents/__init__.py, src/codestory/agents/prompts/__init__.py</files>
  <action>
    Update module exports to include Repo Analyzer:
    
    ```python
    # Update src/codestory/agents/__init__.py
    from .analyzer import RepoAnalyzerAgent
    
    # Add to __all__:
    "RepoAnalyzerAgent",
    ```
    
    ```python
    # Update src/codestory/agents/prompts/__init__.py
    from .analyzer import (
        ANALYZER_AGENT_SYSTEM_PROMPT,
        FILE_TYPE_CATEGORIES,
        ARCHITECTURAL_PATTERNS,
        DESIGN_PATTERNS,
    )
    
    # Add to __all__
    ```
    
    Avoid: Do NOT forget to add new exports.
  </action>
  <verify>RepoAnalyzerAgent importable from codestory.agents</verify>
  <done>Updated module exports for Repo Analyzer Agent</done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] `uv run python -c "from codestory.agents import RepoAnalyzerAgent"` succeeds
- [ ] RepoAnalyzerAgent uses Opus 4.5 configuration
- [ ] System prompt guides structured analysis
- [ ] Pattern recognition constants accessible
- [ ] Ready for GitHub and Analysis skill integration
</verification>

<success_criteria>
- Repo Analyzer Agent class created with proper inheritance
- System prompt guides methodical code analysis
- Lower temperature for precise results
- Ready for skill integration
</success_criteria>

<o>
After completion, create `plans/03-repo-analyzer/03-01-SUMMARY.md`
</o>
