---
phase: 06-fastapi-backend
plan: 03
type: execute
domain: python-api
---

<objective>
Implement story CRUD endpoints for creating, listing, retrieving, and deleting code stories.
</objective>

<context>
@BRIEF.md
@codestory/backend/models/story.py
@codestory/backend/api/deps.py
</context>

<tasks>

<task type="auto">
  <n>Task 1: Create story schemas</n>
  <files>codestory/backend/api/schemas/story.py</files>
  <action>
Create story request/response schemas:

```python
"""Story schemas for Code Story API."""

from datetime import datetime
from enum import Enum
from typing import Any
from pydantic import BaseModel, Field, HttpUrl


class StoryStatus(str, Enum):
    """Story generation status."""
    
    PENDING = "pending"
    ANALYZING = "analyzing"
    GENERATING = "generating"
    SYNTHESIZING = "synthesizing"
    COMPLETE = "complete"
    FAILED = "failed"


class NarrativeStyle(str, Enum):
    """Narrative style options."""
    
    FICTION = "fiction"
    DOCUMENTARY = "documentary"
    TUTORIAL = "tutorial"
    PODCAST = "podcast"
    TECHNICAL = "technical"


class ExpertiseLevel(str, Enum):
    """User expertise level."""
    
    BEGINNER = "beginner"
    INTERMEDIATE = "intermediate"
    ADVANCED = "advanced"


class StoryCreate(BaseModel):
    """Create story request."""
    
    repository_url: HttpUrl
    style: NarrativeStyle = NarrativeStyle.DOCUMENTARY
    expertise_level: ExpertiseLevel = ExpertiseLevel.INTERMEDIATE
    focus_areas: list[str] = Field(default_factory=list)
    custom_intent: str | None = None


class StoryQuickCreate(BaseModel):
    """Quick story creation (minimal input)."""
    
    repository_url: HttpUrl
    style: NarrativeStyle = NarrativeStyle.DOCUMENTARY


class ChapterResponse(BaseModel):
    """Chapter in a story."""
    
    number: int
    title: str
    duration_seconds: float
    start_time_seconds: float
    summary: str | None = None


class StoryResponse(BaseModel):
    """Story response."""
    
    id: str
    repository_url: str
    title: str
    status: StoryStatus
    style: NarrativeStyle
    expertise_level: ExpertiseLevel
    
    # Timing
    total_duration_seconds: float | None = None
    total_duration_formatted: str | None = None
    
    # Content
    chapters: list[ChapterResponse] = Field(default_factory=list)
    
    # URLs
    audio_url: str | None = None
    thumbnail_url: str | None = None
    
    # Metadata
    created_at: datetime
    completed_at: datetime | None = None
    error_message: str | None = None
    
    class Config:
        from_attributes = True


class StoryListResponse(BaseModel):
    """Paginated story list."""
    
    stories: list[StoryResponse]
    total: int
    page: int
    page_size: int
    has_more: bool


class StoryProgress(BaseModel):
    """Story generation progress."""
    
    story_id: str
    status: StoryStatus
    progress_percent: int = 0
    current_step: str = ""
    steps_completed: list[str] = Field(default_factory=list)
    estimated_seconds_remaining: int | None = None


class IntentMessage(BaseModel):
    """Message in intent conversation."""
    
    role: str  # "user" or "assistant"
    content: str


class IntentConversation(BaseModel):
    """Intent conversation for custom story creation."""
    
    story_id: str
    messages: list[IntentMessage]
    is_complete: bool
    extracted_intent: dict[str, Any] | None = None
```
  </action>
  <verify>python -c "from codestory.backend.api.schemas.story import StoryCreate; print('Story schemas OK')"</verify>
  <done>Story schemas created</done>
</task>

<task type="auto">
  <n>Task 2: Create stories router</n>
  <files>codestory/backend/api/routers/stories.py</files>
  <action>
Create story endpoints:

```python
"""Stories router for Code Story API."""

from datetime import datetime
from typing import Annotated
from uuid import UUID

from fastapi import APIRouter, Query, BackgroundTasks
from sqlalchemy import select, func
from sqlalchemy.orm import selectinload

from backend.api.deps import CurrentUser, DBSession
from backend.api.schemas.story import (
    StoryCreate,
    StoryQuickCreate,
    StoryResponse,
    StoryListResponse,
    StoryProgress,
    ChapterResponse,
    IntentMessage,
    IntentConversation,
)
from backend.api.exceptions import NotFoundError, ForbiddenError
from backend.models.story import Story, StoryChapter, StoryIntent
from backend.tasks.story import generate_story_task

router = APIRouter()


@router.post("", response_model=StoryResponse)
async def create_story(
    data: StoryCreate,
    user: CurrentUser,
    db: DBSession,
    background_tasks: BackgroundTasks,
) -> StoryResponse:
    """Create a new story from a repository URL."""
    # Create story record
    story = Story(
        user_id=user.id,
        repository_url=str(data.repository_url),
        title=f"Story: {_extract_repo_name(str(data.repository_url))}",
        status="pending",
        style=data.style.value,
        expertise_level=data.expertise_level.value,
    )
    db.add(story)
    
    # Create intent record
    intent = StoryIntent(
        story_id=story.id,
        focus_areas=data.focus_areas,
        custom_intent=data.custom_intent,
    )
    db.add(intent)
    
    await db.commit()
    await db.refresh(story)
    
    # Queue generation task
    background_tasks.add_task(
        generate_story_task,
        story_id=str(story.id),
    )
    
    return StoryResponse.model_validate(story)


@router.post("/quick", response_model=StoryResponse)
async def create_quick_story(
    data: StoryQuickCreate,
    user: CurrentUser,
    db: DBSession,
    background_tasks: BackgroundTasks,
) -> StoryResponse:
    """Create a story with minimal input (Quick Mode)."""
    story = Story(
        user_id=user.id,
        repository_url=str(data.repository_url),
        title=f"Story: {_extract_repo_name(str(data.repository_url))}",
        status="pending",
        style=data.style.value,
        expertise_level="intermediate",
    )
    db.add(story)
    await db.commit()
    await db.refresh(story)
    
    # Queue generation task
    background_tasks.add_task(
        generate_story_task,
        story_id=str(story.id),
    )
    
    return StoryResponse.model_validate(story)


@router.get("", response_model=StoryListResponse)
async def list_stories(
    user: CurrentUser,
    db: DBSession,
    page: Annotated[int, Query(ge=1)] = 1,
    page_size: Annotated[int, Query(ge=1, le=50)] = 20,
) -> StoryListResponse:
    """List user's stories with pagination."""
    offset = (page - 1) * page_size
    
    # Get total count
    count_result = await db.execute(
        select(func.count()).select_from(Story).where(Story.user_id == user.id)
    )
    total = count_result.scalar()
    
    # Get stories
    result = await db.execute(
        select(Story)
        .where(Story.user_id == user.id)
        .order_by(Story.created_at.desc())
        .offset(offset)
        .limit(page_size)
    )
    stories = result.scalars().all()
    
    return StoryListResponse(
        stories=[StoryResponse.model_validate(s) for s in stories],
        total=total,
        page=page,
        page_size=page_size,
        has_more=offset + len(stories) < total,
    )


@router.get("/{story_id}", response_model=StoryResponse)
async def get_story(
    story_id: str,
    user: CurrentUser,
    db: DBSession,
) -> StoryResponse:
    """Get a specific story by ID."""
    story = await _get_user_story(db, story_id, user.id)
    
    # Load chapters
    result = await db.execute(
        select(StoryChapter)
        .where(StoryChapter.story_id == story.id)
        .order_by(StoryChapter.chapter_number)
    )
    chapters = result.scalars().all()
    
    response = StoryResponse.model_validate(story)
    response.chapters = [
        ChapterResponse(
            number=c.chapter_number,
            title=c.title,
            duration_seconds=c.duration_seconds or 0,
            start_time_seconds=c.start_time_seconds or 0,
            summary=c.summary,
        )
        for c in chapters
    ]
    
    return response


@router.get("/{story_id}/progress", response_model=StoryProgress)
async def get_story_progress(
    story_id: str,
    user: CurrentUser,
    db: DBSession,
) -> StoryProgress:
    """Get story generation progress."""
    story = await _get_user_story(db, story_id, user.id)
    
    # Calculate progress based on status
    progress_map = {
        "pending": 0,
        "analyzing": 25,
        "generating": 50,
        "synthesizing": 75,
        "complete": 100,
        "failed": 0,
    }
    
    steps_map = {
        "pending": [],
        "analyzing": ["Repository fetched"],
        "generating": ["Repository fetched", "Analysis complete"],
        "synthesizing": ["Repository fetched", "Analysis complete", "Script generated"],
        "complete": ["Repository fetched", "Analysis complete", "Script generated", "Audio synthesized"],
        "failed": [],
    }
    
    return StoryProgress(
        story_id=str(story.id),
        status=story.status,
        progress_percent=progress_map.get(story.status, 0),
        current_step=story.status.replace("_", " ").title(),
        steps_completed=steps_map.get(story.status, []),
    )


@router.delete("/{story_id}")
async def delete_story(
    story_id: str,
    user: CurrentUser,
    db: DBSession,
) -> dict:
    """Delete a story."""
    story = await _get_user_story(db, story_id, user.id)
    
    await db.delete(story)
    await db.commit()
    
    return {"message": "Story deleted successfully"}


async def _get_user_story(db: DBSession, story_id: str, user_id: UUID) -> Story:
    """Get story and verify ownership."""
    try:
        story_uuid = UUID(story_id)
    except ValueError:
        raise NotFoundError("Story", story_id)
    
    story = await db.get(Story, story_uuid)
    
    if not story:
        raise NotFoundError("Story", story_id)
    
    if story.user_id != user_id:
        raise ForbiddenError("You don't have access to this story")
    
    return story


def _extract_repo_name(url: str) -> str:
    """Extract repository name from URL."""
    parts = url.rstrip("/").split("/")
    return parts[-1] if parts else "Repository"
```
  </action>
  <verify>python -c "from codestory.backend.api.routers.stories import router; print('Stories router OK')"</verify>
  <done>Stories router created</done>
</task>

</tasks>

<playwright_validation_gate>
```
# Create story
Playwright Action: HTTP POST /api/stories
Headers: Authorization: Bearer {token}
Body: {"repository_url": "https://github.com/owner/repo", "style": "documentary"}
Expected: 200 OK with story_id and status "pending"

# List stories
Playwright Action: HTTP GET /api/stories
Headers: Authorization: Bearer {token}
Expected: 200 OK with stories array

# Get story
Playwright Action: HTTP GET /api/stories/{story_id}
Expected: 200 OK with full story details
```
</playwright_validation_gate>
