---
phase: 06-fastapi-backend
plan: 05
type: execute
domain: python-api
---

<objective>
Implement WebSocket endpoint for real-time story generation progress updates.
</objective>

<context>
@BRIEF.md
@codestory/backend/tasks/progress.py
@codestory/backend/api/deps.py
</context>

<tasks>

<task type="auto">
  <n>Task 1: Create WebSocket manager</n>
  <files>codestory/backend/api/websocket.py</files>
  <action>
Create WebSocket connection manager:

```python
"""WebSocket connection manager for Code Story."""

import asyncio
import json
import logging
from typing import Any
from collections import defaultdict

from fastapi import WebSocket, WebSocketDisconnect
import redis.asyncio as redis

from backend.core.config import get_settings

logger = logging.getLogger(__name__)
settings = get_settings()


class ConnectionManager:
    """Manage WebSocket connections for progress updates."""
    
    def __init__(self):
        # story_id -> list of WebSocket connections
        self.connections: dict[str, list[WebSocket]] = defaultdict(list)
        self._redis: redis.Redis | None = None
        self._listener_task: asyncio.Task | None = None
    
    async def get_redis(self) -> redis.Redis:
        """Get async Redis client."""
        if not self._redis:
            self._redis = redis.from_url(settings.redis_url)
        return self._redis
    
    async def connect(self, websocket: WebSocket, story_id: str) -> None:
        """Accept WebSocket connection for a story."""
        await websocket.accept()
        self.connections[story_id].append(websocket)
        logger.info(f"WebSocket connected for story: {story_id}")
        
        # Start listener if not running
        if not self._listener_task or self._listener_task.done():
            self._listener_task = asyncio.create_task(self._listen_for_updates())
    
    async def disconnect(self, websocket: WebSocket, story_id: str) -> None:
        """Remove WebSocket connection."""
        if websocket in self.connections[story_id]:
            self.connections[story_id].remove(websocket)
            logger.info(f"WebSocket disconnected for story: {story_id}")
        
        # Clean up empty lists
        if not self.connections[story_id]:
            del self.connections[story_id]
    
    async def send_progress(self, story_id: str, data: dict[str, Any]) -> None:
        """Send progress update to all connections for a story."""
        dead_connections = []
        
        for websocket in self.connections.get(story_id, []):
            try:
                await websocket.send_json(data)
            except Exception as e:
                logger.warning(f"Failed to send to WebSocket: {e}")
                dead_connections.append(websocket)
        
        # Clean up dead connections
        for ws in dead_connections:
            await self.disconnect(ws, story_id)
    
    async def broadcast(self, data: dict[str, Any]) -> None:
        """Broadcast to all connections."""
        for story_id in list(self.connections.keys()):
            await self.send_progress(story_id, data)
    
    async def _listen_for_updates(self) -> None:
        """Listen for Redis pub/sub updates."""
        try:
            client = await self.get_redis()
            pubsub = client.pubsub()
            
            # Subscribe to pattern for all stories
            await pubsub.psubscribe("story:*")
            
            logger.info("Started Redis pub/sub listener")
            
            async for message in pubsub.listen():
                if message["type"] == "pmessage":
                    channel = message["channel"].decode()
                    story_id = channel.split(":")[1]
                    data = json.loads(message["data"])
                    
                    await self.send_progress(story_id, data)
                    
        except asyncio.CancelledError:
            logger.info("Redis listener cancelled")
        except Exception as e:
            logger.exception(f"Redis listener error: {e}")
    
    async def close(self) -> None:
        """Close all connections and cleanup."""
        if self._listener_task:
            self._listener_task.cancel()
        
        if self._redis:
            await self._redis.close()
        
        for story_id in list(self.connections.keys()):
            for ws in self.connections[story_id]:
                try:
                    await ws.close()
                except Exception:
                    pass


# Global connection manager
manager = ConnectionManager()
```
  </action>
  <verify>python -c "from codestory.backend.api.websocket import ConnectionManager; print('WebSocket manager OK')"</verify>
  <done>WebSocket manager created</done>
</task>

<task type="auto">
  <n>Task 2: Create WebSocket router</n>
  <files>codestory/backend/api/routers/ws.py</files>
  <action>
Create WebSocket endpoints:

```python
"""WebSocket router for Code Story API."""

import asyncio
import logging
from uuid import UUID

from fastapi import APIRouter, WebSocket, WebSocketDisconnect, Query
from sqlalchemy import select

from backend.api.websocket import manager
from backend.core.database import async_session_factory
from backend.core.security import decode_jwt_token
from backend.models.story import Story
from backend.tasks.progress import get_story_progress

logger = logging.getLogger(__name__)
router = APIRouter()


@router.websocket("/ws/stories/{story_id}/progress")
async def story_progress_websocket(
    websocket: WebSocket,
    story_id: str,
    token: str = Query(None),
) -> None:
    """
    WebSocket endpoint for real-time story progress.
    
    Connect: ws://host/ws/stories/{story_id}/progress?token={jwt_token}
    
    Receives JSON messages:
    {
        "story_id": "...",
        "status": "analyzing|generating|synthesizing|complete|failed",
        "progress_percent": 0-100,
        "current_step": "Human readable step",
        "updated_at": "ISO timestamp"
    }
    """
    # Validate token
    user_id = await _validate_websocket_token(token)
    if not user_id:
        await websocket.close(code=4001, reason="Invalid token")
        return
    
    # Validate story access
    if not await _validate_story_access(story_id, user_id):
        await websocket.close(code=4003, reason="Access denied")
        return
    
    # Connect
    await manager.connect(websocket, story_id)
    
    try:
        # Send current progress immediately
        current_progress = get_story_progress(story_id)
        if current_progress:
            await websocket.send_json(current_progress)
        
        # Keep connection alive and handle client messages
        while True:
            try:
                # Wait for client messages (ping/pong or commands)
                data = await asyncio.wait_for(
                    websocket.receive_text(),
                    timeout=30.0,
                )
                
                # Handle ping
                if data == "ping":
                    await websocket.send_text("pong")
                
                # Handle status request
                elif data == "status":
                    progress = get_story_progress(story_id)
                    if progress:
                        await websocket.send_json(progress)
                        
            except asyncio.TimeoutError:
                # Send keepalive ping
                try:
                    await websocket.send_text("ping")
                except Exception:
                    break
                    
    except WebSocketDisconnect:
        logger.info(f"WebSocket disconnected: {story_id}")
    except Exception as e:
        logger.exception(f"WebSocket error: {e}")
    finally:
        await manager.disconnect(websocket, story_id)


@router.websocket("/ws/user/stories")
async def user_stories_websocket(
    websocket: WebSocket,
    token: str = Query(None),
) -> None:
    """
    WebSocket for all user story updates.
    
    Useful for dashboard real-time updates.
    """
    user_id = await _validate_websocket_token(token)
    if not user_id:
        await websocket.close(code=4001, reason="Invalid token")
        return
    
    await websocket.accept()
    
    try:
        # Subscribe to user's stories
        async with async_session_factory() as db:
            result = await db.execute(
                select(Story.id).where(Story.user_id == user_id)
            )
            story_ids = [str(row[0]) for row in result.all()]
        
        # Register for all story updates
        for story_id in story_ids:
            manager.connections[story_id].append(websocket)
        
        # Keep alive
        while True:
            data = await websocket.receive_text()
            if data == "ping":
                await websocket.send_text("pong")
                
    except WebSocketDisconnect:
        pass
    finally:
        # Cleanup
        for story_id in story_ids:
            if websocket in manager.connections.get(story_id, []):
                manager.connections[story_id].remove(websocket)


async def _validate_websocket_token(token: str | None) -> str | None:
    """Validate JWT token for WebSocket connection."""
    if not token:
        return None
    
    payload = decode_jwt_token(token)
    if not payload:
        return None
    
    return payload.get("sub")


async def _validate_story_access(story_id: str, user_id: str) -> bool:
    """Check if user has access to story."""
    try:
        story_uuid = UUID(story_id)
        user_uuid = UUID(user_id)
    except ValueError:
        return False
    
    async with async_session_factory() as db:
        story = await db.get(Story, story_uuid)
        return story is not None and story.user_id == user_uuid
```
  </action>
  <verify>python -c "from codestory.backend.api.routers.ws import router; print('WS router OK')"</verify>
  <done>WebSocket router created</done>
</task>

</tasks>

<playwright_validation_gate>
```
# WebSocket connection test
Playwright Action: Connect WebSocket to /ws/stories/{story_id}/progress?token={jwt}
Expected: Connection accepted

# Progress update received
Wait: For message
Expected: JSON with status, progress_percent, current_step

# Ping/pong keepalive
Playwright Action: Send "ping"
Expected: Receive "pong"
```
</playwright_validation_gate>
