---
phase: 06-fastapi-backend
plan: 01
type: execute
domain: python-api
---

<objective>
Set up FastAPI application structure with routers, middleware, dependency injection, and exception handling.
</objective>

<context>
@BRIEF.md
@codestory/backend/core/config.py
</context>

<tasks>

<task type="auto">
  <n>Task 1: Create FastAPI application factory</n>
  <files>codestory/backend/api/app.py, codestory/backend/api/__init__.py</files>
  <action>
Create the main FastAPI application:

```python
"""FastAPI application factory for Code Story."""

from contextlib import asynccontextmanager
from typing import AsyncGenerator

from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from fastapi.middleware.gzip import GZipMiddleware

from backend.core.config import get_settings
from backend.api.routers import auth, stories, health, users
from backend.api.middleware import RequestLoggingMiddleware, RateLimitMiddleware
from backend.api.exceptions import register_exception_handlers
from backend.core.database import engine, init_db


@asynccontextmanager
async def lifespan(app: FastAPI) -> AsyncGenerator[None, None]:
    """Application lifespan handler."""
    # Startup
    await init_db()
    yield
    # Shutdown
    await engine.dispose()


def create_app() -> FastAPI:
    """Create and configure the FastAPI application."""
    settings = get_settings()
    
    app = FastAPI(
        title="Code Story API",
        description="Transform code repositories into audio narratives",
        version="1.0.0",
        docs_url="/api/docs" if not settings.is_production else None,
        redoc_url="/api/redoc" if not settings.is_production else None,
        lifespan=lifespan,
    )
    
    # Configure CORS
    app.add_middleware(
        CORSMiddleware,
        allow_origins=settings.cors_origins,
        allow_credentials=True,
        allow_methods=["*"],
        allow_headers=["*"],
    )
    
    # Add compression
    app.add_middleware(GZipMiddleware, minimum_size=1000)
    
    # Add custom middleware
    app.add_middleware(RequestLoggingMiddleware)
    
    if settings.rate_limit_enabled:
        app.add_middleware(RateLimitMiddleware)
    
    # Register exception handlers
    register_exception_handlers(app)
    
    # Include routers
    app.include_router(health.router, prefix="/api", tags=["health"])
    app.include_router(auth.router, prefix="/api/auth", tags=["auth"])
    app.include_router(users.router, prefix="/api/users", tags=["users"])
    app.include_router(stories.router, prefix="/api/stories", tags=["stories"])
    
    return app


# Application instance
app = create_app()
```

Create __init__.py:

```python
"""Code Story API package."""

from backend.api.app import app, create_app

__all__ = ["app", "create_app"]
```
  </action>
  <verify>python -c "from codestory.backend.api.app import create_app; print('App OK')"</verify>
  <done>FastAPI application created</done>
</task>

<task type="auto">
  <n>Task 2: Create middleware modules</n>
  <files>codestory/backend/api/middleware.py</files>
  <action>
Create custom middleware:

```python
"""Custom middleware for Code Story API."""

import time
import logging
from typing import Callable
from collections import defaultdict

from fastapi import Request, Response
from starlette.middleware.base import BaseHTTPMiddleware

from backend.core.config import get_settings

logger = logging.getLogger(__name__)


class RequestLoggingMiddleware(BaseHTTPMiddleware):
    """Log all requests with timing."""
    
    async def dispatch(
        self,
        request: Request,
        call_next: Callable,
    ) -> Response:
        start_time = time.time()
        
        # Log request
        logger.info(
            f"Request: {request.method} {request.url.path}",
            extra={
                "method": request.method,
                "path": request.url.path,
                "client": request.client.host if request.client else None,
            },
        )
        
        response = await call_next(request)
        
        # Log response with timing
        duration = time.time() - start_time
        logger.info(
            f"Response: {response.status_code} in {duration:.3f}s",
            extra={
                "status_code": response.status_code,
                "duration_seconds": duration,
            },
        )
        
        # Add timing header
        response.headers["X-Process-Time"] = f"{duration:.3f}"
        
        return response


class RateLimitMiddleware(BaseHTTPMiddleware):
    """Simple in-memory rate limiting."""
    
    def __init__(self, app, requests_per_minute: int = 60):
        super().__init__(app)
        self.requests_per_minute = requests_per_minute
        self.request_counts: dict[str, list[float]] = defaultdict(list)
    
    async def dispatch(
        self,
        request: Request,
        call_next: Callable,
    ) -> Response:
        # Get client identifier
        client_id = self._get_client_id(request)
        current_time = time.time()
        
        # Clean old entries
        self.request_counts[client_id] = [
            t for t in self.request_counts[client_id]
            if current_time - t < 60
        ]
        
        # Check rate limit
        if len(self.request_counts[client_id]) >= self.requests_per_minute:
            return Response(
                content='{"detail": "Rate limit exceeded"}',
                status_code=429,
                media_type="application/json",
                headers={"Retry-After": "60"},
            )
        
        # Record request
        self.request_counts[client_id].append(current_time)
        
        response = await call_next(request)
        
        # Add rate limit headers
        remaining = self.requests_per_minute - len(self.request_counts[client_id])
        response.headers["X-RateLimit-Limit"] = str(self.requests_per_minute)
        response.headers["X-RateLimit-Remaining"] = str(remaining)
        
        return response
    
    def _get_client_id(self, request: Request) -> str:
        """Get unique client identifier."""
        # Use API key if present, else IP
        api_key = request.headers.get("X-API-Key")
        if api_key:
            return f"api:{api_key[:16]}"
        
        forwarded = request.headers.get("X-Forwarded-For")
        if forwarded:
            return f"ip:{forwarded.split(',')[0].strip()}"
        
        if request.client:
            return f"ip:{request.client.host}"
        
        return "unknown"
```
  </action>
  <verify>python -c "from codestory.backend.api.middleware import RequestLoggingMiddleware; print('Middleware OK')"</verify>
  <done>Middleware modules created</done>
</task>

<task type="auto">
  <n>Task 3: Create exception handlers</n>
  <files>codestory/backend/api/exceptions.py</files>
  <action>
Create exception handling:

```python
"""Exception handlers for Code Story API."""

import logging
from typing import Any

from fastapi import FastAPI, Request
from fastapi.responses import JSONResponse
from pydantic import ValidationError

logger = logging.getLogger(__name__)


class APIError(Exception):
    """Base API error."""
    
    def __init__(
        self,
        message: str,
        status_code: int = 400,
        details: dict[str, Any] | None = None,
    ):
        self.message = message
        self.status_code = status_code
        self.details = details or {}
        super().__init__(message)


class NotFoundError(APIError):
    """Resource not found."""
    
    def __init__(self, resource: str, resource_id: str | None = None):
        message = f"{resource} not found"
        if resource_id:
            message = f"{resource} '{resource_id}' not found"
        super().__init__(message, status_code=404)


class UnauthorizedError(APIError):
    """Authentication required."""
    
    def __init__(self, message: str = "Authentication required"):
        super().__init__(message, status_code=401)


class ForbiddenError(APIError):
    """Access denied."""
    
    def __init__(self, message: str = "Access denied"):
        super().__init__(message, status_code=403)


class ConflictError(APIError):
    """Resource conflict."""
    
    def __init__(self, message: str):
        super().__init__(message, status_code=409)


class RateLimitError(APIError):
    """Rate limit exceeded."""
    
    def __init__(self, retry_after: int = 60):
        super().__init__(
            "Rate limit exceeded",
            status_code=429,
            details={"retry_after": retry_after},
        )


async def api_error_handler(request: Request, exc: APIError) -> JSONResponse:
    """Handle APIError exceptions."""
    return JSONResponse(
        status_code=exc.status_code,
        content={
            "error": exc.message,
            "details": exc.details,
        },
    )


async def validation_error_handler(request: Request, exc: ValidationError) -> JSONResponse:
    """Handle Pydantic validation errors."""
    return JSONResponse(
        status_code=422,
        content={
            "error": "Validation error",
            "details": exc.errors(),
        },
    )


async def generic_error_handler(request: Request, exc: Exception) -> JSONResponse:
    """Handle unexpected exceptions."""
    logger.exception("Unexpected error", exc_info=exc)
    return JSONResponse(
        status_code=500,
        content={
            "error": "Internal server error",
            "details": {},
        },
    )


def register_exception_handlers(app: FastAPI) -> None:
    """Register all exception handlers."""
    app.add_exception_handler(APIError, api_error_handler)
    app.add_exception_handler(ValidationError, validation_error_handler)
    app.add_exception_handler(Exception, generic_error_handler)
```
  </action>
  <verify>python -c "from codestory.backend.api.exceptions import APIError; print('Exceptions OK')"</verify>
  <done>Exception handlers created</done>
</task>

</tasks>

<playwright_validation_gate>
```
Playwright Action: HTTP GET /api/docs
Expected: 200 OK (in development)

Playwright Action: HTTP GET /api/health
Expected: 200 OK with status "healthy"
```
</playwright_validation_gate>
