---
phase: 06-fastapi-backend
plan: 02
type: execute
domain: python-api
---

<objective>
Implement JWT-based authentication with user registration, login, token refresh, and protected route dependencies.
</objective>

<context>
@BRIEF.md
@codestory/backend/core/security.py
@codestory/backend/models/user.py
</context>

<reasoning_guidance>
JWT implementation is security-critical. Deeply consider the implications of each design choice:

**Token Storage (client-side)**:
- httpOnly cookies: Immune to XSS, vulnerable to CSRF (mitigate with SameSite)
- localStorage: Convenient, vulnerable to XSS attacks
- Memory only: Most secure, lost on page refresh
- Recommendation: httpOnly cookies with SameSite=Strict for web, secure storage for mobile

**Token Expiry Trade-offs**:
- Short-lived access tokens (15-30 min): More secure, frequent refresh needed
- Long-lived access tokens (hours/days): Better UX, higher risk if compromised
- Refresh tokens: Enable short access tokens with good UX, but add complexity
- Recommendation: 15-30 min access, 7-day refresh with rotation

**Refresh Token Rotation**:
- Issue new refresh token on each refresh (OWASP recommended)
- Invalidate old refresh token immediately
- Detect token reuse as potential theft indicator
- Store refresh token family for revocation

**Algorithm Selection**:
- HS256 (symmetric): Simple, shared secret, suitable for single-service
- RS256 (asymmetric): Public key verification, better for microservices
- Recommendation: HS256 for monolith, RS256 if services need to verify tokens independently

**Additional Security Measures**:
- Include `jti` (JWT ID) for token revocation capability
- Include `iat` (issued at) for freshness checks
- Validate `aud` (audience) to prevent token misuse across services
- Hash passwords with bcrypt (cost factor 12+) or argon2id

Verify implementation against OWASP JWT Security Cheat Sheet.
</reasoning_guidance>

<tasks>

<task type="auto">
  <n>Task 1: Create auth schemas and dependencies</n>
  <files>codestory/backend/api/schemas/auth.py, codestory/backend/api/deps.py</files>
  <action>
Create auth schemas:

```python
"""Authentication schemas for Code Story API."""

from datetime import datetime
from pydantic import BaseModel, EmailStr, Field


class UserRegister(BaseModel):
    """User registration request."""
    
    email: EmailStr
    password: str = Field(..., min_length=8, max_length=100)
    name: str = Field(..., min_length=1, max_length=100)


class UserLogin(BaseModel):
    """User login request."""
    
    email: EmailStr
    password: str


class TokenResponse(BaseModel):
    """JWT token response."""
    
    access_token: str
    refresh_token: str
    token_type: str = "bearer"
    expires_in: int  # seconds


class TokenRefresh(BaseModel):
    """Token refresh request."""
    
    refresh_token: str


class UserResponse(BaseModel):
    """User response."""
    
    id: str
    email: str
    name: str
    is_active: bool
    created_at: datetime
    
    class Config:
        from_attributes = True


class PasswordChange(BaseModel):
    """Password change request."""
    
    current_password: str
    new_password: str = Field(..., min_length=8, max_length=100)
```

Create dependencies:

```python
"""FastAPI dependencies for Code Story API."""

from typing import Annotated

from fastapi import Depends, Header
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from sqlalchemy.ext.asyncio import AsyncSession

from backend.core.database import get_session
from backend.core.security import decode_jwt_token
from backend.models.user import User
from backend.api.exceptions import UnauthorizedError, ForbiddenError


security = HTTPBearer()


async def get_db() -> AsyncSession:
    """Get database session."""
    async for session in get_session():
        yield session


async def get_current_user(
    credentials: Annotated[HTTPAuthorizationCredentials, Depends(security)],
    db: Annotated[AsyncSession, Depends(get_db)],
) -> User:
    """Get current authenticated user from JWT token."""
    token = credentials.credentials
    
    payload = decode_jwt_token(token)
    if not payload:
        raise UnauthorizedError("Invalid or expired token")
    
    user_id = payload.get("sub")
    if not user_id:
        raise UnauthorizedError("Invalid token payload")
    
    user = await db.get(User, user_id)
    if not user:
        raise UnauthorizedError("User not found")
    
    if not user.is_active:
        raise ForbiddenError("User account is disabled")
    
    return user


async def get_current_active_user(
    user: Annotated[User, Depends(get_current_user)],
) -> User:
    """Ensure user is active."""
    if not user.is_active:
        raise ForbiddenError("User account is disabled")
    return user


async def get_optional_user(
    credentials: Annotated[HTTPAuthorizationCredentials | None, Depends(HTTPBearer(auto_error=False))],
    db: Annotated[AsyncSession, Depends(get_db)],
) -> User | None:
    """Get user if authenticated, None otherwise."""
    if not credentials:
        return None
    
    try:
        return await get_current_user(credentials, db)
    except UnauthorizedError:
        return None


async def get_api_key_user(
    x_api_key: Annotated[str | None, Header()] = None,
    db: Annotated[AsyncSession, Depends(get_db)] = None,
) -> User | None:
    """Get user from API key header."""
    if not x_api_key:
        return None
    
    from backend.models.api_key import APIKey
    from sqlalchemy import select
    
    result = await db.execute(
        select(APIKey).where(
            APIKey.key_hash == APIKey.hash_key(x_api_key),
            APIKey.is_active == True,
        )
    )
    api_key = result.scalar_one_or_none()
    
    if not api_key:
        return None
    
    # Update last used
    api_key.last_used_at = datetime.utcnow()
    await db.commit()
    
    return await db.get(User, api_key.user_id)


# Type aliases for cleaner signatures
CurrentUser = Annotated[User, Depends(get_current_user)]
ActiveUser = Annotated[User, Depends(get_current_active_user)]
OptionalUser = Annotated[User | None, Depends(get_optional_user)]
DBSession = Annotated[AsyncSession, Depends(get_db)]
```
  </action>
  <verify>python -c "from codestory.backend.api.schemas.auth import UserRegister; print('Schemas OK')"</verify>
  <done>Auth schemas and dependencies created</done>
</task>

<task type="auto">
  <n>Task 2: Create auth router</n>
  <files>codestory/backend/api/routers/auth.py</files>
  <action>
Create auth endpoints:

```python
"""Authentication router for Code Story API."""

from datetime import datetime, timedelta

from fastapi import APIRouter, Depends, BackgroundTasks
from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession

from backend.api.deps import get_db, CurrentUser, DBSession
from backend.api.schemas.auth import (
    UserRegister,
    UserLogin,
    TokenResponse,
    TokenRefresh,
    UserResponse,
    PasswordChange,
)
from backend.api.exceptions import (
    UnauthorizedError,
    ConflictError,
    NotFoundError,
)
from backend.models.user import User
from backend.core.security import (
    hash_password,
    verify_password,
    create_jwt_token,
    decode_jwt_token,
)
from backend.core.config import get_settings

router = APIRouter()
settings = get_settings()


@router.post("/register", response_model=TokenResponse)
async def register(
    data: UserRegister,
    db: DBSession,
) -> TokenResponse:
    """Register a new user."""
    # Check if email exists
    result = await db.execute(
        select(User).where(User.email == data.email)
    )
    if result.scalar_one_or_none():
        raise ConflictError("Email already registered")
    
    # Create user
    user = User(
        email=data.email,
        password_hash=hash_password(data.password),
        name=data.name,
    )
    db.add(user)
    await db.commit()
    await db.refresh(user)
    
    # Generate tokens
    access_token = create_jwt_token(
        {"sub": str(user.id), "type": "access"},
        expires_delta=timedelta(minutes=settings.jwt_access_token_expire_minutes),
    )
    refresh_token = create_jwt_token(
        {"sub": str(user.id), "type": "refresh"},
        expires_delta=timedelta(days=settings.jwt_refresh_token_expire_days),
    )
    
    return TokenResponse(
        access_token=access_token,
        refresh_token=refresh_token,
        expires_in=settings.jwt_access_token_expire_minutes * 60,
    )


@router.post("/login", response_model=TokenResponse)
async def login(
    data: UserLogin,
    db: DBSession,
) -> TokenResponse:
    """Login with email and password."""
    result = await db.execute(
        select(User).where(User.email == data.email)
    )
    user = result.scalar_one_or_none()
    
    if not user or not verify_password(data.password, user.password_hash):
        raise UnauthorizedError("Invalid email or password")
    
    if not user.is_active:
        raise UnauthorizedError("Account is disabled")
    
    # Update last login
    user.last_login_at = datetime.utcnow()
    await db.commit()
    
    # Generate tokens
    access_token = create_jwt_token(
        {"sub": str(user.id), "type": "access"},
        expires_delta=timedelta(minutes=settings.jwt_access_token_expire_minutes),
    )
    refresh_token = create_jwt_token(
        {"sub": str(user.id), "type": "refresh"},
        expires_delta=timedelta(days=settings.jwt_refresh_token_expire_days),
    )
    
    return TokenResponse(
        access_token=access_token,
        refresh_token=refresh_token,
        expires_in=settings.jwt_access_token_expire_minutes * 60,
    )


@router.post("/refresh", response_model=TokenResponse)
async def refresh_token(
    data: TokenRefresh,
    db: DBSession,
) -> TokenResponse:
    """Refresh access token using refresh token."""
    payload = decode_jwt_token(data.refresh_token)
    
    if not payload or payload.get("type") != "refresh":
        raise UnauthorizedError("Invalid refresh token")
    
    user_id = payload.get("sub")
    user = await db.get(User, user_id)
    
    if not user or not user.is_active:
        raise UnauthorizedError("User not found or disabled")
    
    # Generate new access token
    access_token = create_jwt_token(
        {"sub": str(user.id), "type": "access"},
        expires_delta=timedelta(minutes=settings.jwt_access_token_expire_minutes),
    )
    
    # Optionally rotate refresh token
    new_refresh_token = create_jwt_token(
        {"sub": str(user.id), "type": "refresh"},
        expires_delta=timedelta(days=settings.jwt_refresh_token_expire_days),
    )
    
    return TokenResponse(
        access_token=access_token,
        refresh_token=new_refresh_token,
        expires_in=settings.jwt_access_token_expire_minutes * 60,
    )


@router.get("/me", response_model=UserResponse)
async def get_me(
    user: CurrentUser,
) -> UserResponse:
    """Get current user profile."""
    return UserResponse.model_validate(user)


@router.post("/change-password")
async def change_password(
    data: PasswordChange,
    user: CurrentUser,
    db: DBSession,
) -> dict:
    """Change user password."""
    if not verify_password(data.current_password, user.password_hash):
        raise UnauthorizedError("Current password is incorrect")
    
    user.password_hash = hash_password(data.new_password)
    await db.commit()
    
    return {"message": "Password changed successfully"}


@router.post("/logout")
async def logout(
    user: CurrentUser,
) -> dict:
    """Logout current user (client should discard tokens)."""
    # In a more complete implementation, you might:
    # - Add the token to a blacklist
    # - Clear server-side sessions
    return {"message": "Logged out successfully"}
```
  </action>
  <verify>python -c "from codestory.backend.api.routers.auth import router; print('Auth router OK')"</verify>
  <done>Auth router created</done>
</task>

</tasks>

<playwright_validation_gate>
```
# Registration flow
Playwright Action: HTTP POST /api/auth/register
Body: {"email": "test@example.com", "password": "securepass123", "name": "Test User"}
Expected: 200 OK with access_token and refresh_token

# Login flow
Playwright Action: HTTP POST /api/auth/login
Body: {"email": "test@example.com", "password": "securepass123"}
Expected: 200 OK with tokens

# Protected route
Playwright Action: HTTP GET /api/auth/me
Headers: Authorization: Bearer {access_token}
Expected: 200 OK with user data
```
</playwright_validation_gate>
