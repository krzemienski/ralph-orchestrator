---
phase: 06-fastapi-backend
plan: 04
type: execute
domain: python-api
---

<objective>
Implement Redis-backed Celery task queue for asynchronous story generation with progress tracking.
</objective>

<context>
@BRIEF.md
@codestory/backend/core/config.py
@codestory/backend/agents/orchestrator.py
</context>

<error_recovery>
Redis and Celery are distributed system dependencies. Implement resilience:

**Redis Connection Failures:**
1. Use connection pooling with health checks
2. Implement retry logic for transient disconnections:
   - Retry connection 3 times with 1s, 2s, 4s delays
   - Use exponential backoff for reconnection attempts
3. Circuit breaker pattern: after N failures, fail fast for M seconds
4. Log all connection events for debugging

**Redis Unavailable at Startup:**
- FastAPI should start without Redis (graceful degradation)
- Queue endpoints return 503 with clear message
- Health check endpoint reports Redis status

**Celery Worker Crashes:**
- Use `task_acks_late=True` to prevent message loss
- Configure `task_reject_on_worker_lost=True` for redelivery
- Monitor task failures with appropriate alerting

**Task Failures:**
- Implement task retry with backoff: `max_retries=3, retry_backoff=True`
- Dead letter queue for permanently failed tasks
- Store failure reason in task result for debugging

**Memory/Storage Issues:**
- Set `result_expires` to auto-cleanup old results
- Monitor Redis memory usage
- Implement key expiration for progress tracking data

**Recovery Actions:**
- On Redis recovery, no manual intervention needed (Celery reconnects)
- Failed tasks visible in result backend for retry
- Admin endpoint to manually retry failed story generation

**Fallback Mode:**
- If Redis unavailable, offer synchronous generation (slower, no progress)
- Clearly communicate degraded mode to user
</error_recovery>

<tasks>

<task type="auto">
  <n>Task 1: Create Celery configuration</n>
  <files>codestory/backend/core/celery.py</files>
  <action>
Create Celery app configuration:

```python
"""Celery configuration for Code Story."""

from celery import Celery

from backend.core.config import get_settings

settings = get_settings()


def create_celery_app() -> Celery:
    """Create and configure Celery application."""
    app = Celery(
        "codestory",
        broker=settings.celery_broker_url,
        backend=settings.celery_result_backend,
    )
    
    app.conf.update(
        # Task settings
        task_serializer="json",
        accept_content=["json"],
        result_serializer="json",
        timezone="UTC",
        enable_utc=True,
        
        # Task execution
        task_acks_late=True,
        task_reject_on_worker_lost=True,
        worker_prefetch_multiplier=1,
        
        # Result backend
        result_expires=86400,  # 24 hours
        
        # Task routing
        task_routes={
            "backend.tasks.story.*": {"queue": "stories"},
            "backend.tasks.audio.*": {"queue": "audio"},
        },
        
        # Rate limiting
        task_annotations={
            "backend.tasks.story.generate_story_task": {
                "rate_limit": "10/m",
            },
        },
        
        # Retry settings
        task_default_retry_delay=60,
        task_max_retries=3,
    )
    
    # Auto-discover tasks
    app.autodiscover_tasks([
        "backend.tasks.story",
        "backend.tasks.audio",
    ])
    
    return app


celery_app = create_celery_app()
```
  </action>
  <verify>python -c "from codestory.backend.core.celery import celery_app; print('Celery OK')"</verify>
  <done>Celery configuration created</done>
</task>

<task type="auto">
  <n>Task 2: Create story generation task</n>
  <files>codestory/backend/tasks/story.py, codestory/backend/tasks/__init__.py</files>
  <action>
Create story generation Celery task:

```python
"""Story generation tasks for Code Story."""

import asyncio
import logging
from datetime import datetime

from celery import shared_task
from celery.exceptions import MaxRetriesExceededError
from sqlalchemy import select

from backend.core.celery import celery_app
from backend.core.database import async_session_factory
from backend.models.story import Story, StoryChapter
from backend.agents.orchestrator import Orchestrator
from backend.tasks.progress import update_story_progress

logger = logging.getLogger(__name__)


@celery_app.task(
    bind=True,
    name="backend.tasks.story.generate_story_task",
    max_retries=3,
    default_retry_delay=60,
)
def generate_story_task(self, story_id: str) -> dict:
    """
    Generate a code story asynchronously.
    
    This is the main entry point for story generation.
    Runs the 4-agent pipeline: Intent → Analysis → Story → Voice
    """
    logger.info(f"Starting story generation for {story_id}")
    
    try:
        # Run async code in sync context
        result = asyncio.get_event_loop().run_until_complete(
            _generate_story_async(story_id, self)
        )
        return result
        
    except Exception as exc:
        logger.exception(f"Story generation failed: {story_id}")
        
        # Update story status to failed
        asyncio.get_event_loop().run_until_complete(
            _mark_story_failed(story_id, str(exc))
        )
        
        # Retry if retries remaining
        try:
            self.retry(exc=exc)
        except MaxRetriesExceededError:
            logger.error(f"Max retries exceeded for story {story_id}")
            raise


async def _generate_story_async(story_id: str, task) -> dict:
    """Async story generation logic."""
    async with async_session_factory() as db:
        # Load story
        story = await db.get(Story, story_id)
        if not story:
            raise ValueError(f"Story not found: {story_id}")
        
        # Update status: analyzing
        story.status = "analyzing"
        await db.commit()
        update_story_progress(story_id, "analyzing", 10)
        
        # Initialize orchestrator
        orchestrator = Orchestrator()
        
        # Run Intent Agent (if custom mode)
        intent_data = await _get_or_generate_intent(db, story)
        update_story_progress(story_id, "analyzing", 25)
        
        # Run Repo Analyzer Agent
        story.status = "analyzing"
        await db.commit()
        
        analysis = await orchestrator.run_repo_analyzer(
            repository_url=story.repository_url,
        )
        update_story_progress(story_id, "generating", 40)
        
        # Run Story Architect Agent
        story.status = "generating"
        await db.commit()
        
        script = await orchestrator.run_story_architect(
            analysis=analysis,
            intent=intent_data,
            style=story.style,
        )
        update_story_progress(story_id, "synthesizing", 60)
        
        # Run Voice Director Agent
        story.status = "synthesizing"
        await db.commit()
        
        audio_result = await orchestrator.run_voice_director(
            script=script,
            output_dir=f"/tmp/stories/{story_id}",
        )
        update_story_progress(story_id, "synthesizing", 90)
        
        # Save chapters
        for i, chapter in enumerate(script.get("chapters", [])):
            db_chapter = StoryChapter(
                story_id=story.id,
                chapter_number=i + 1,
                title=chapter.get("title", f"Chapter {i + 1}"),
                content=chapter.get("content", ""),
                duration_seconds=chapter.get("duration_seconds"),
                start_time_seconds=chapter.get("start_time_seconds"),
            )
            db.add(db_chapter)
        
        # Update story with results
        story.status = "complete"
        story.completed_at = datetime.utcnow()
        story.title = script.get("title", story.title)
        story.audio_url = audio_result.get("audio_url")
        story.total_duration_seconds = audio_result.get("total_duration_seconds")
        story.analysis_cache = analysis
        
        await db.commit()
        update_story_progress(story_id, "complete", 100)
        
        logger.info(f"Story generation complete: {story_id}")
        
        return {
            "story_id": story_id,
            "status": "complete",
            "audio_url": story.audio_url,
        }


async def _get_or_generate_intent(db, story: Story) -> dict:
    """Get existing intent or generate default."""
    result = await db.execute(
        select(StoryIntent).where(StoryIntent.story_id == story.id)
    )
    intent = result.scalar_one_or_none()
    
    if intent and intent.extracted_intent:
        return intent.extracted_intent
    
    # Default intent for quick mode
    return {
        "category": "general_onboarding",
        "expertise_level": story.expertise_level,
        "focus_areas": intent.focus_areas if intent else [],
        "learning_goals": ["Understand the codebase"],
        "preferred_style": story.style,
    }


async def _mark_story_failed(story_id: str, error_message: str) -> None:
    """Mark story as failed."""
    async with async_session_factory() as db:
        story = await db.get(Story, story_id)
        if story:
            story.status = "failed"
            story.error_message = error_message[:500]  # Truncate
            await db.commit()


# Import for tasks __init__.py
from backend.models.story import StoryIntent
```

Create tasks __init__.py:

```python
"""Celery tasks for Code Story."""

from backend.tasks.story import generate_story_task

__all__ = ["generate_story_task"]
```
  </action>
  <verify>python -c "from codestory.backend.tasks.story import generate_story_task; print('Tasks OK')"</verify>
  <done>Story generation task created</done>
</task>

<task type="auto">
  <n>Task 3: Create progress tracking</n>
  <files>codestory/backend/tasks/progress.py</files>
  <action>
Create progress tracking with Redis:

```python
"""Progress tracking for story generation."""

import json
import logging
from datetime import datetime
from typing import Any

import redis

from backend.core.config import get_settings

logger = logging.getLogger(__name__)
settings = get_settings()


def get_redis_client() -> redis.Redis:
    """Get Redis client."""
    return redis.from_url(settings.redis_url)


def update_story_progress(
    story_id: str,
    status: str,
    progress_percent: int,
    current_step: str = "",
    metadata: dict[str, Any] | None = None,
) -> None:
    """
    Update story generation progress in Redis.
    
    Args:
        story_id: Story UUID
        status: Current status
        progress_percent: Progress percentage (0-100)
        current_step: Human-readable current step
        metadata: Additional metadata
    """
    client = get_redis_client()
    
    progress_data = {
        "story_id": story_id,
        "status": status,
        "progress_percent": progress_percent,
        "current_step": current_step or status.replace("_", " ").title(),
        "updated_at": datetime.utcnow().isoformat(),
        "metadata": metadata or {},
    }
    
    key = f"story_progress:{story_id}"
    
    # Store progress (expires after 1 hour)
    client.setex(key, 3600, json.dumps(progress_data))
    
    # Publish to channel for WebSocket subscribers
    client.publish(f"story:{story_id}", json.dumps(progress_data))
    
    logger.debug(f"Progress update: {story_id} - {status} ({progress_percent}%)")


def get_story_progress(story_id: str) -> dict[str, Any] | None:
    """
    Get current story progress from Redis.
    
    Args:
        story_id: Story UUID
    
    Returns:
        Progress data or None if not found
    """
    client = get_redis_client()
    key = f"story_progress:{story_id}"
    
    data = client.get(key)
    if data:
        return json.loads(data)
    
    return None


def clear_story_progress(story_id: str) -> None:
    """Clear story progress from Redis."""
    client = get_redis_client()
    key = f"story_progress:{story_id}"
    client.delete(key)


class ProgressSubscriber:
    """Subscribe to story progress updates."""
    
    def __init__(self, story_id: str):
        self.story_id = story_id
        self.client = get_redis_client()
        self.pubsub = self.client.pubsub()
        self.channel = f"story:{story_id}"
    
    async def subscribe(self):
        """Subscribe to progress channel."""
        self.pubsub.subscribe(self.channel)
    
    async def get_message(self, timeout: float = 1.0) -> dict[str, Any] | None:
        """Get next progress message."""
        message = self.pubsub.get_message(timeout=timeout)
        if message and message["type"] == "message":
            return json.loads(message["data"])
        return None
    
    async def unsubscribe(self):
        """Unsubscribe from channel."""
        self.pubsub.unsubscribe(self.channel)
        self.pubsub.close()
```
  </action>
  <verify>python -c "from codestory.backend.tasks.progress import update_story_progress; print('Progress OK')"</verify>
  <done>Progress tracking created</done>
</task>

</tasks>

<playwright_validation_gate>
```
# Create story and verify task queued
Playwright Action: HTTP POST /api/stories
Body: {"repository_url": "https://github.com/owner/repo"}
Expected: 200 OK

# Poll progress
Playwright Action: HTTP GET /api/stories/{story_id}/progress
Expected: 200 OK with status and progress_percent

# Verify completion (after waiting)
Wait: 60 seconds
Playwright Action: HTTP GET /api/stories/{story_id}
Expected: status is "complete" or "analyzing" (in progress)
```
</playwright_validation_gate>
