# Plan 11-03: Usage Analytics and Cost Tracking

## Overview
Implement comprehensive analytics dashboard showing platform usage metrics, cost tracking for API calls (Anthropic, ElevenLabs, S3), user growth trends, and revenue insights. Enables data-driven decisions about pricing, capacity, and feature development.

## Dependencies
- Plan 11-01: Admin authentication
- Phase 6: Database with usage data

## Implementation

### 1. Analytics Models

**models/analytics.py:**
```python
"""Analytics and cost tracking models."""
from datetime import datetime, date
from decimal import Decimal
from sqlalchemy import Column, String, Integer, DateTime, Date, Numeric, JSON
from database import Base


class DailyMetrics(Base):
    """Aggregated daily platform metrics."""
    __tablename__ = "daily_metrics"
    
    id = Column(String(36), primary_key=True)
    date = Column(Date, unique=True, nullable=False, index=True)
    
    # User metrics
    new_users = Column(Integer, default=0)
    active_users = Column(Integer, default=0)  # Users with activity
    churned_users = Column(Integer, default=0)  # Canceled subscriptions
    
    # Story metrics
    stories_created = Column(Integer, default=0)
    stories_completed = Column(Integer, default=0)
    stories_failed = Column(Integer, default=0)
    total_chapters = Column(Integer, default=0)
    total_audio_minutes = Column(Numeric(10, 2), default=0)
    
    # API metrics
    api_requests = Column(Integer, default=0)
    api_errors = Column(Integer, default=0)
    
    # Cost metrics (in cents)
    anthropic_cost = Column(Integer, default=0)
    elevenlabs_cost = Column(Integer, default=0)
    s3_cost = Column(Integer, default=0)
    total_cost = Column(Integer, default=0)
    
    # Revenue (in cents)
    revenue = Column(Integer, default=0)
    
    created_at = Column(DateTime, default=datetime.utcnow)


class UserActivity(Base):
    """Track individual user activity for analytics."""
    __tablename__ = "user_activity"
    
    id = Column(String(36), primary_key=True)
    user_id = Column(String(36), nullable=False, index=True)
    date = Column(Date, nullable=False, index=True)
    
    # Activity counts
    stories_created = Column(Integer, default=0)
    api_calls = Column(Integer, default=0)
    audio_minutes = Column(Numeric(10, 2), default=0)
    
    # Cost attribution
    cost_cents = Column(Integer, default=0)
    
    __table_args__ = (
        {'unique_constraint': ('user_id', 'date')},
    )


class APICallLog(Base):
    """Log individual API calls for cost tracking."""
    __tablename__ = "api_call_logs"
    
    id = Column(String(36), primary_key=True)
    user_id = Column(String(36), nullable=False, index=True)
    story_id = Column(String(36), nullable=True, index=True)
    
    # Call details
    service = Column(String(50), nullable=False)  # anthropic, elevenlabs, s3
    operation = Column(String(100), nullable=False)
    
    # Usage metrics
    input_tokens = Column(Integer, default=0)
    output_tokens = Column(Integer, default=0)
    characters = Column(Integer, default=0)  # For ElevenLabs
    bytes_transferred = Column(Integer, default=0)  # For S3
    
    # Cost (in cents)
    cost_cents = Column(Integer, default=0)
    
    created_at = Column(DateTime, default=datetime.utcnow, index=True)
```

### 2. Analytics Service

**services/analytics_service.py:**
```python
"""Analytics aggregation and querying service."""
import uuid
from datetime import datetime, date, timedelta
from decimal import Decimal
from typing import Optional
from sqlalchemy import func, and_
from sqlalchemy.orm import Session

from models.analytics import DailyMetrics, UserActivity, APICallLog
from models.user import User
from models.story import Story


class AnalyticsService:
    """Service for analytics operations."""
    
    def __init__(self, db: Session):
        self.db = db
    
    def get_dashboard_metrics(
        self,
        start_date: date,
        end_date: date
    ) -> dict:
        """Get aggregated metrics for dashboard."""
        metrics = self.db.query(DailyMetrics).filter(
            DailyMetrics.date >= start_date,
            DailyMetrics.date <= end_date
        ).all()
        
        # Aggregate
        totals = {
            "new_users": sum(m.new_users for m in metrics),
            "active_users": max((m.active_users for m in metrics), default=0),
            "stories_created": sum(m.stories_created for m in metrics),
            "stories_completed": sum(m.stories_completed for m in metrics),
            "total_audio_minutes": sum(float(m.total_audio_minutes) for m in metrics),
            "api_requests": sum(m.api_requests for m in metrics),
            "total_cost_cents": sum(m.total_cost for m in metrics),
            "revenue_cents": sum(m.revenue for m in metrics),
        }
        
        # Calculate profit margin
        if totals["revenue_cents"] > 0:
            totals["profit_margin"] = (
                (totals["revenue_cents"] - totals["total_cost_cents"]) 
                / totals["revenue_cents"] * 100
            )
        else:
            totals["profit_margin"] = 0
        
        # Daily breakdown for charts
        daily = [
            {
                "date": m.date.isoformat(),
                "new_users": m.new_users,
                "active_users": m.active_users,
                "stories": m.stories_created,
                "cost": m.total_cost / 100,  # Convert to dollars
                "revenue": m.revenue / 100,
            }
            for m in sorted(metrics, key=lambda x: x.date)
        ]
        
        return {
            "totals": totals,
            "daily": daily,
            "period": {
                "start": start_date.isoformat(),
                "end": end_date.isoformat(),
                "days": (end_date - start_date).days + 1,
            }
        }
    
    def get_cost_breakdown(
        self,
        start_date: date,
        end_date: date
    ) -> dict:
        """Get cost breakdown by service."""
        metrics = self.db.query(DailyMetrics).filter(
            DailyMetrics.date >= start_date,
            DailyMetrics.date <= end_date
        ).all()
        
        # Service totals
        anthropic = sum(m.anthropic_cost for m in metrics)
        elevenlabs = sum(m.elevenlabs_cost for m in metrics)
        s3 = sum(m.s3_cost for m in metrics)
        total = anthropic + elevenlabs + s3
        
        # Percentages
        breakdown = {
            "anthropic": {
                "cost_cents": anthropic,
                "cost_dollars": anthropic / 100,
                "percentage": (anthropic / total * 100) if total > 0 else 0,
            },
            "elevenlabs": {
                "cost_cents": elevenlabs,
                "cost_dollars": elevenlabs / 100,
                "percentage": (elevenlabs / total * 100) if total > 0 else 0,
            },
            "s3": {
                "cost_cents": s3,
                "cost_dollars": s3 / 100,
                "percentage": (s3 / total * 100) if total > 0 else 0,
            },
            "total": {
                "cost_cents": total,
                "cost_dollars": total / 100,
            }
        }
        
        # Daily trend
        daily = [
            {
                "date": m.date.isoformat(),
                "anthropic": m.anthropic_cost / 100,
                "elevenlabs": m.elevenlabs_cost / 100,
                "s3": m.s3_cost / 100,
            }
            for m in sorted(metrics, key=lambda x: x.date)
        ]
        
        return {"breakdown": breakdown, "daily": daily}
    
    def get_user_growth(
        self,
        start_date: date,
        end_date: date
    ) -> dict:
        """Get user growth metrics."""
        metrics = self.db.query(DailyMetrics).filter(
            DailyMetrics.date >= start_date,
            DailyMetrics.date <= end_date
        ).order_by(DailyMetrics.date).all()
        
        # Cumulative user count
        total_users = self.db.query(func.count(User.id)).filter(
            User.created_at < datetime.combine(start_date, datetime.min.time())
        ).scalar() or 0
        
        cumulative = []
        for m in metrics:
            total_users += m.new_users
            cumulative.append({
                "date": m.date.isoformat(),
                "new_users": m.new_users,
                "total_users": total_users,
                "active_users": m.active_users,
                "churned": m.churned_users,
            })
        
        # Growth rate
        if len(cumulative) >= 2:
            first = cumulative[0]["total_users"]
            last = cumulative[-1]["total_users"]
            growth_rate = ((last - first) / first * 100) if first > 0 else 0
        else:
            growth_rate = 0
        
        return {
            "daily": cumulative,
            "growth_rate": growth_rate,
            "total_new": sum(m.new_users for m in metrics),
            "total_churned": sum(m.churned_users for m in metrics),
        }
    
    def get_top_users(
        self,
        start_date: date,
        end_date: date,
        limit: int = 10,
        sort_by: str = "cost"
    ) -> list:
        """Get top users by cost or usage."""
        query = self.db.query(
            UserActivity.user_id,
            func.sum(UserActivity.stories_created).label("stories"),
            func.sum(UserActivity.api_calls).label("api_calls"),
            func.sum(UserActivity.audio_minutes).label("audio_minutes"),
            func.sum(UserActivity.cost_cents).label("total_cost"),
        ).filter(
            UserActivity.date >= start_date,
            UserActivity.date <= end_date
        ).group_by(UserActivity.user_id)
        
        if sort_by == "cost":
            query = query.order_by(func.sum(UserActivity.cost_cents).desc())
        elif sort_by == "stories":
            query = query.order_by(func.sum(UserActivity.stories_created).desc())
        elif sort_by == "api_calls":
            query = query.order_by(func.sum(UserActivity.api_calls).desc())
        
        results = query.limit(limit).all()
        
        # Enrich with user data
        user_ids = [r.user_id for r in results]
        users = {u.id: u for u in self.db.query(User).filter(User.id.in_(user_ids)).all()}
        
        return [
            {
                "user_id": r.user_id,
                "email": users.get(r.user_id, {}).email if r.user_id in users else None,
                "stories": r.stories,
                "api_calls": r.api_calls,
                "audio_minutes": float(r.audio_minutes),
                "cost_dollars": r.total_cost / 100,
            }
            for r in results
        ]
    
    def log_api_call(
        self,
        user_id: str,
        service: str,
        operation: str,
        cost_cents: int,
        story_id: Optional[str] = None,
        **metrics
    ):
        """Log an API call for cost tracking."""
        log = APICallLog(
            id=str(uuid.uuid4()),
            user_id=user_id,
            story_id=story_id,
            service=service,
            operation=operation,
            cost_cents=cost_cents,
            **metrics
        )
        self.db.add(log)
        
        # Update daily metrics
        self._update_daily_metrics(service, cost_cents)
        
        # Update user activity
        self._update_user_activity(user_id, cost_cents)
        
        self.db.commit()
    
    def _update_daily_metrics(self, service: str, cost_cents: int):
        """Update or create daily metrics."""
        today = date.today()
        
        metrics = self.db.query(DailyMetrics).filter(
            DailyMetrics.date == today
        ).first()
        
        if not metrics:
            metrics = DailyMetrics(
                id=str(uuid.uuid4()),
                date=today
            )
            self.db.add(metrics)
        
        metrics.api_requests += 1
        metrics.total_cost += cost_cents
        
        if service == "anthropic":
            metrics.anthropic_cost += cost_cents
        elif service == "elevenlabs":
            metrics.elevenlabs_cost += cost_cents
        elif service == "s3":
            metrics.s3_cost += cost_cents
    
    def _update_user_activity(self, user_id: str, cost_cents: int):
        """Update user activity for the day."""
        today = date.today()
        
        activity = self.db.query(UserActivity).filter(
            UserActivity.user_id == user_id,
            UserActivity.date == today
        ).first()
        
        if not activity:
            activity = UserActivity(
                id=str(uuid.uuid4()),
                user_id=user_id,
                date=today
            )
            self.db.add(activity)
        
        activity.api_calls += 1
        activity.cost_cents += cost_cents
```

### 3. Analytics Router

**routers/admin_analytics.py:**
```python
"""Admin analytics endpoints."""
from datetime import date, timedelta
from fastapi import APIRouter, Depends, Query
from sqlalchemy.orm import Session

from database import get_db
from models.admin import AdminUser, Permission
from services.analytics_service import AnalyticsService
from auth.admin_auth import require_permission

router = APIRouter(prefix="/admin/analytics", tags=["admin-analytics"])


@router.get("/dashboard")
async def get_dashboard(
    start_date: date = Query(default_factory=lambda: date.today() - timedelta(days=30)),
    end_date: date = Query(default_factory=date.today),
    admin: AdminUser = Depends(require_permission(Permission.VIEW_ANALYTICS)),
    db: Session = Depends(get_db)
):
    """Get dashboard metrics."""
    service = AnalyticsService(db)
    return service.get_dashboard_metrics(start_date, end_date)


@router.get("/costs")
async def get_costs(
    start_date: date = Query(default_factory=lambda: date.today() - timedelta(days=30)),
    end_date: date = Query(default_factory=date.today),
    admin: AdminUser = Depends(require_permission(Permission.VIEW_ANALYTICS)),
    db: Session = Depends(get_db)
):
    """Get cost breakdown by service."""
    service = AnalyticsService(db)
    return service.get_cost_breakdown(start_date, end_date)


@router.get("/users/growth")
async def get_user_growth(
    start_date: date = Query(default_factory=lambda: date.today() - timedelta(days=30)),
    end_date: date = Query(default_factory=date.today),
    admin: AdminUser = Depends(require_permission(Permission.VIEW_ANALYTICS)),
    db: Session = Depends(get_db)
):
    """Get user growth metrics."""
    service = AnalyticsService(db)
    return service.get_user_growth(start_date, end_date)


@router.get("/users/top")
async def get_top_users(
    start_date: date = Query(default_factory=lambda: date.today() - timedelta(days=30)),
    end_date: date = Query(default_factory=date.today),
    limit: int = Query(10, ge=1, le=100),
    sort_by: str = Query("cost", regex="^(cost|stories|api_calls)$"),
    admin: AdminUser = Depends(require_permission(Permission.VIEW_ANALYTICS)),
    db: Session = Depends(get_db)
):
    """Get top users by usage or cost."""
    service = AnalyticsService(db)
    return service.get_top_users(start_date, end_date, limit, sort_by)


@router.get("/export")
async def export_analytics(
    start_date: date = Query(...),
    end_date: date = Query(...),
    format: str = Query("csv", regex="^(csv|json)$"),
    admin: AdminUser = Depends(require_permission(Permission.EXPORT_DATA)),
    db: Session = Depends(get_db)
):
    """Export analytics data."""
    service = AnalyticsService(db)
    data = service.get_dashboard_metrics(start_date, end_date)
    
    if format == "csv":
        import csv
        import io
        from fastapi.responses import StreamingResponse
        
        output = io.StringIO()
        writer = csv.writer(output)
        writer.writerow(["Date", "New Users", "Active Users", "Stories", "Cost", "Revenue"])
        
        for day in data["daily"]:
            writer.writerow([
                day["date"],
                day["new_users"],
                day["active_users"],
                day["stories"],
                day["cost"],
                day["revenue"],
            ])
        
        output.seek(0)
        return StreamingResponse(
            iter([output.getvalue()]),
            media_type="text/csv",
            headers={"Content-Disposition": f"attachment; filename=analytics_{start_date}_{end_date}.csv"}
        )
    
    return data
```

### 4. Analytics Dashboard Component

**apps/admin-dashboard/src/pages/AnalyticsPage.tsx:**
```typescript
import { useState } from "react";
import { useQuery } from "@tanstack/react-query";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Button } from "@/components/ui/button";
import { Calendar } from "@/components/ui/calendar";
import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from "@/components/ui/popover";
import {
  LineChart,
  Line,
  AreaChart,
  Area,
  BarChart,
  Bar,
  PieChart,
  Pie,
  Cell,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  Legend,
  ResponsiveContainer,
} from "recharts";
import { format, subDays } from "date-fns";
import { Calendar as CalendarIcon, Download, Users, DollarSign, FileAudio, TrendingUp } from "lucide-react";
import { adminApi } from "@/lib/api";
import { cn } from "@/lib/utils";

const COLORS = ["#8884d8", "#82ca9d", "#ffc658"];

export default function AnalyticsPage() {
  const [dateRange, setDateRange] = useState({
    start: subDays(new Date(), 30),
    end: new Date(),
  });

  const { data: dashboard, isLoading } = useQuery({
    queryKey: ["analytics-dashboard", dateRange],
    queryFn: () =>
      adminApi.get("/admin/analytics/dashboard", {
        params: {
          start_date: format(dateRange.start, "yyyy-MM-dd"),
          end_date: format(dateRange.end, "yyyy-MM-dd"),
        },
      }),
  });

  const { data: costs } = useQuery({
    queryKey: ["analytics-costs", dateRange],
    queryFn: () =>
      adminApi.get("/admin/analytics/costs", {
        params: {
          start_date: format(dateRange.start, "yyyy-MM-dd"),
          end_date: format(dateRange.end, "yyyy-MM-dd"),
        },
      }),
  });

  const { data: growth } = useQuery({
    queryKey: ["analytics-growth", dateRange],
    queryFn: () =>
      adminApi.get("/admin/analytics/users/growth", {
        params: {
          start_date: format(dateRange.start, "yyyy-MM-dd"),
          end_date: format(dateRange.end, "yyyy-MM-dd"),
        },
      }),
  });

  const exportData = async () => {
    const response = await adminApi.get("/admin/analytics/export", {
      params: {
        start_date: format(dateRange.start, "yyyy-MM-dd"),
        end_date: format(dateRange.end, "yyyy-MM-dd"),
        format: "csv",
      },
      responseType: "blob",
    });
    
    const url = window.URL.createObjectURL(new Blob([response]));
    const link = document.createElement("a");
    link.href = url;
    link.setAttribute("download", `analytics_${format(dateRange.start, "yyyy-MM-dd")}.csv`);
    document.body.appendChild(link);
    link.click();
    link.remove();
  };

  const totals = dashboard?.totals || {};
  const costBreakdown = costs?.breakdown || {};

  return (
    <div className="p-6 space-y-6">
      <div className="flex justify-between items-center">
        <h1 className="text-2xl font-bold">Analytics</h1>
        <div className="flex gap-2">
          <Popover>
            <PopoverTrigger asChild>
              <Button variant="outline">
                <CalendarIcon className="h-4 w-4 mr-2" />
                {format(dateRange.start, "MMM d")} - {format(dateRange.end, "MMM d, yyyy")}
              </Button>
            </PopoverTrigger>
            <PopoverContent className="w-auto p-0" align="end">
              <Calendar
                mode="range"
                selected={{ from: dateRange.start, to: dateRange.end }}
                onSelect={(range) => {
                  if (range?.from && range?.to) {
                    setDateRange({ start: range.from, end: range.to });
                  }
                }}
              />
            </PopoverContent>
          </Popover>
          <Button onClick={exportData}>
            <Download className="h-4 w-4 mr-2" />
            Export
          </Button>
        </div>
      </div>

      {/* KPI Cards */}
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
        <Card>
          <CardHeader className="flex flex-row items-center justify-between pb-2">
            <CardTitle className="text-sm font-medium">New Users</CardTitle>
            <Users className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{totals.new_users?.toLocaleString()}</div>
            <p className="text-xs text-muted-foreground">
              {growth?.growth_rate?.toFixed(1)}% growth
            </p>
          </CardContent>
        </Card>

        <Card>
          <CardHeader className="flex flex-row items-center justify-between pb-2">
            <CardTitle className="text-sm font-medium">Stories Created</CardTitle>
            <FileAudio className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{totals.stories_created?.toLocaleString()}</div>
            <p className="text-xs text-muted-foreground">
              {totals.total_audio_minutes?.toFixed(0)} min audio
            </p>
          </CardContent>
        </Card>

        <Card>
          <CardHeader className="flex flex-row items-center justify-between pb-2">
            <CardTitle className="text-sm font-medium">Total Cost</CardTitle>
            <DollarSign className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">
              ${(totals.total_cost_cents / 100)?.toFixed(2)}
            </div>
            <p className="text-xs text-muted-foreground">
              ${(costBreakdown.anthropic?.cost_dollars || 0).toFixed(2)} Anthropic
            </p>
          </CardContent>
        </Card>

        <Card>
          <CardHeader className="flex flex-row items-center justify-between pb-2">
            <CardTitle className="text-sm font-medium">Revenue</CardTitle>
            <TrendingUp className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">
              ${(totals.revenue_cents / 100)?.toFixed(2)}
            </div>
            <p className="text-xs text-muted-foreground">
              {totals.profit_margin?.toFixed(1)}% margin
            </p>
          </CardContent>
        </Card>
      </div>

      <Tabs defaultValue="usage">
        <TabsList>
          <TabsTrigger value="usage">Usage</TabsTrigger>
          <TabsTrigger value="costs">Costs</TabsTrigger>
          <TabsTrigger value="users">Users</TabsTrigger>
        </TabsList>

        <TabsContent value="usage" className="space-y-4">
          <Card>
            <CardHeader>
              <CardTitle>Stories Over Time</CardTitle>
            </CardHeader>
            <CardContent>
              <ResponsiveContainer width="100%" height={300}>
                <AreaChart data={dashboard?.daily || []}>
                  <CartesianGrid strokeDasharray="3 3" />
                  <XAxis dataKey="date" tickFormatter={(v) => format(new Date(v), "MMM d")} />
                  <YAxis />
                  <Tooltip labelFormatter={(v) => format(new Date(v), "MMM d, yyyy")} />
                  <Area type="monotone" dataKey="stories" stroke="#8884d8" fill="#8884d8" fillOpacity={0.3} />
                </AreaChart>
              </ResponsiveContainer>
            </CardContent>
          </Card>
        </TabsContent>

        <TabsContent value="costs" className="space-y-4">
          <div className="grid grid-cols-1 lg:grid-cols-2 gap-4">
            <Card>
              <CardHeader>
                <CardTitle>Cost Breakdown</CardTitle>
              </CardHeader>
              <CardContent>
                <ResponsiveContainer width="100%" height={300}>
                  <PieChart>
                    <Pie
                      data={[
                        { name: "Anthropic", value: costBreakdown.anthropic?.cost_dollars || 0 },
                        { name: "ElevenLabs", value: costBreakdown.elevenlabs?.cost_dollars || 0 },
                        { name: "S3", value: costBreakdown.s3?.cost_dollars || 0 },
                      ]}
                      cx="50%"
                      cy="50%"
                      outerRadius={100}
                      dataKey="value"
                      label={({ name, percent }) => `${name} ${(percent * 100).toFixed(0)}%`}
                    >
                      {COLORS.map((color, index) => (
                        <Cell key={`cell-${index}`} fill={color} />
                      ))}
                    </Pie>
                    <Tooltip formatter={(value: number) => `$${value.toFixed(2)}`} />
                  </PieChart>
                </ResponsiveContainer>
              </CardContent>
            </Card>

            <Card>
              <CardHeader>
                <CardTitle>Daily Costs</CardTitle>
              </CardHeader>
              <CardContent>
                <ResponsiveContainer width="100%" height={300}>
                  <BarChart data={costs?.daily || []}>
                    <CartesianGrid strokeDasharray="3 3" />
                    <XAxis dataKey="date" tickFormatter={(v) => format(new Date(v), "MMM d")} />
                    <YAxis tickFormatter={(v) => `$${v}`} />
                    <Tooltip formatter={(value: number) => `$${value.toFixed(2)}`} />
                    <Legend />
                    <Bar dataKey="anthropic" stackId="a" fill="#8884d8" name="Anthropic" />
                    <Bar dataKey="elevenlabs" stackId="a" fill="#82ca9d" name="ElevenLabs" />
                    <Bar dataKey="s3" stackId="a" fill="#ffc658" name="S3" />
                  </BarChart>
                </ResponsiveContainer>
              </CardContent>
            </Card>
          </div>
        </TabsContent>

        <TabsContent value="users" className="space-y-4">
          <Card>
            <CardHeader>
              <CardTitle>User Growth</CardTitle>
            </CardHeader>
            <CardContent>
              <ResponsiveContainer width="100%" height={300}>
                <LineChart data={growth?.daily || []}>
                  <CartesianGrid strokeDasharray="3 3" />
                  <XAxis dataKey="date" tickFormatter={(v) => format(new Date(v), "MMM d")} />
                  <YAxis />
                  <Tooltip labelFormatter={(v) => format(new Date(v), "MMM d, yyyy")} />
                  <Legend />
                  <Line type="monotone" dataKey="total_users" stroke="#8884d8" name="Total Users" />
                  <Line type="monotone" dataKey="active_users" stroke="#82ca9d" name="Active Users" />
                </LineChart>
              </ResponsiveContainer>
            </CardContent>
          </Card>
        </TabsContent>
      </Tabs>
    </div>
  );
}
```

## File Structure
```
backend/
├── models/
│   └── analytics.py
├── services/
│   └── analytics_service.py
└── routers/
    └── admin_analytics.py

apps/admin-dashboard/
└── src/
    └── pages/
        └── AnalyticsPage.tsx
```

## Validation Gates

### Gate 1: Dashboard Metrics
```python
def test_dashboard_metrics():
    """Verify dashboard returns aggregated metrics."""
    response = client.get(
        "/admin/analytics/dashboard",
        params={"start_date": "2024-01-01", "end_date": "2024-01-31"},
        headers=admin_headers
    )
    
    assert response.status_code == 200
    data = response.json()
    
    assert "totals" in data
    assert "daily" in data
    assert "new_users" in data["totals"]
    assert "total_cost_cents" in data["totals"]
```

### Gate 2: Cost Breakdown
```python
def test_cost_breakdown():
    """Verify cost breakdown by service."""
    response = client.get(
        "/admin/analytics/costs",
        params={"start_date": "2024-01-01", "end_date": "2024-01-31"},
        headers=admin_headers
    )
    
    assert response.status_code == 200
    data = response.json()
    
    assert "breakdown" in data
    assert "anthropic" in data["breakdown"]
    assert "elevenlabs" in data["breakdown"]
    assert "s3" in data["breakdown"]
```

### Gate 3: Data Export
```python
def test_export_csv():
    """Verify CSV export functionality."""
    response = client.get(
        "/admin/analytics/export",
        params={
            "start_date": "2024-01-01",
            "end_date": "2024-01-31",
            "format": "csv"
        },
        headers=admin_headers
    )
    
    assert response.status_code == 200
    assert response.headers["content-type"] == "text/csv"
    assert "Date,New Users" in response.text
```

### Gate 4: Charts Render
```typescript
test("analytics charts render", async ({ page }) => {
  await page.goto("/admin/analytics");
  
  // Wait for data to load
  await page.waitForSelector(".recharts-wrapper");
  
  // Check KPI cards
  await expect(page.locator("text=New Users")).toBeVisible();
  await expect(page.locator("text=Total Cost")).toBeVisible();
  
  // Check charts
  await expect(page.locator(".recharts-area")).toBeVisible();
  
  // Switch to costs tab
  await page.click('button:has-text("Costs")');
  await expect(page.locator(".recharts-pie")).toBeVisible();
});
```

## Definition of Done
- [ ] Daily metrics model and aggregation
- [ ] User activity tracking
- [ ] API call logging with costs
- [ ] Dashboard metrics endpoint
- [ ] Cost breakdown by service
- [ ] User growth metrics
- [ ] Top users by usage/cost
- [ ] CSV export functionality
- [ ] Analytics dashboard UI with charts
- [ ] Date range picker
- [ ] All validation gates passing
