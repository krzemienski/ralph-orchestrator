# Plan 11-01: Admin Authentication and Authorization

## Overview
Implement secure admin authentication with role-based access control, protecting administrative endpoints and the admin dashboard. Supports super-admin, admin, and support roles with granular permissions.

## Dependencies
- Phase 6: FastAPI backend with JWT authentication
- Plan 10-01: API key management infrastructure

## Security Reasoning

Admin authentication is the highest-security component. Deeply consider attack vectors:

**Authentication Hardening:**
- Require strong passwords (12+ chars, complexity requirements)
- Enforce MFA for all admin accounts (TOTP or WebAuthn)
- Rate limit login attempts (5 attempts, then 15-min lockout)
- Log all authentication events with IP and user agent
- Session timeout: 1 hour inactive, 8 hours absolute

**Authorization Design:**
- Principle of least privilege: start with no permissions, add explicitly
- Separate admin tokens from user tokens (different signing keys?)
- Short-lived admin tokens (15-30 min) with frequent refresh
- Permission checks on every admin endpoint (defense in depth)

**Attack Mitigation:**
- CSRF protection on all state-changing operations
- IP allowlisting option for admin endpoints
- Detect and alert on impossible travel (login from distant locations)
- Admin action audit trail (who did what, when, from where)

**Privilege Escalation Prevention:**
- Super-admin can't be created via API (seed data only)
- Role changes require higher-role approval
- Self-modification limits (can't elevate own role)
- Separation of duties where feasible

**Incident Response:**
- Ability to revoke all admin sessions instantly
- Admin account disable (not delete) for investigation
- Detailed audit logs for forensics
- Alerting on suspicious admin activity patterns

**Operational Security:**
- Initial admin credentials via secure channel (not email)
- Forced password change on first login
- Regular access reviews (who still needs admin?)
- Admin endpoint on separate subdomain (admin.codestory.io)

This is security-critical code. Review against OWASP Admin Security guidelines.

## Implementation

### 1. Admin Role Models

**models/admin.py:**
```python
"""Admin role and permission models."""
from enum import Enum
from datetime import datetime
from sqlalchemy import Column, String, DateTime, Boolean, ForeignKey, Table, Enum as SQLEnum
from sqlalchemy.orm import relationship

from database import Base


class AdminRole(str, Enum):
    """Admin role levels."""
    SUPER_ADMIN = "super_admin"  # Full system access
    ADMIN = "admin"              # User and content management
    SUPPORT = "support"          # Read-only access, limited actions


class Permission(str, Enum):
    """Granular permissions."""
    # User management
    VIEW_USERS = "view_users"
    EDIT_USERS = "edit_users"
    DELETE_USERS = "delete_users"
    MANAGE_QUOTAS = "manage_quotas"
    
    # Content management
    VIEW_STORIES = "view_stories"
    DELETE_STORIES = "delete_stories"
    
    # API key management
    VIEW_API_KEYS = "view_api_keys"
    REVOKE_API_KEYS = "revoke_api_keys"
    
    # Analytics
    VIEW_ANALYTICS = "view_analytics"
    EXPORT_DATA = "export_data"
    
    # System
    VIEW_AUDIT_LOGS = "view_audit_logs"
    MANAGE_ADMINS = "manage_admins"
    SYSTEM_SETTINGS = "system_settings"


# Role to permissions mapping
ROLE_PERMISSIONS = {
    AdminRole.SUPER_ADMIN: list(Permission),
    AdminRole.ADMIN: [
        Permission.VIEW_USERS, Permission.EDIT_USERS, Permission.MANAGE_QUOTAS,
        Permission.VIEW_STORIES, Permission.DELETE_STORIES,
        Permission.VIEW_API_KEYS, Permission.REVOKE_API_KEYS,
        Permission.VIEW_ANALYTICS, Permission.EXPORT_DATA,
        Permission.VIEW_AUDIT_LOGS,
    ],
    AdminRole.SUPPORT: [
        Permission.VIEW_USERS,
        Permission.VIEW_STORIES,
        Permission.VIEW_API_KEYS,
        Permission.VIEW_ANALYTICS,
    ],
}


class AdminUser(Base):
    """Admin user with elevated privileges."""
    __tablename__ = "admin_users"
    
    id = Column(String(36), primary_key=True)
    user_id = Column(String(36), ForeignKey("users.id"), unique=True, nullable=False)
    role = Column(SQLEnum(AdminRole), nullable=False, default=AdminRole.SUPPORT)
    
    # Status
    is_active = Column(Boolean, default=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    created_by = Column(String(36), ForeignKey("admin_users.id"), nullable=True)
    deactivated_at = Column(DateTime, nullable=True)
    
    # Two-factor authentication
    totp_secret = Column(String(32), nullable=True)
    totp_enabled = Column(Boolean, default=False)
    
    # Session management
    last_login_at = Column(DateTime, nullable=True)
    last_login_ip = Column(String(45), nullable=True)
    
    # Relationships
    user = relationship("User", back_populates="admin_profile")
    audit_logs = relationship("AuditLog", back_populates="admin")
    
    def has_permission(self, permission: Permission) -> bool:
        """Check if admin has a specific permission."""
        if not self.is_active:
            return False
        return permission in ROLE_PERMISSIONS.get(self.role, [])
    
    def get_permissions(self) -> list[Permission]:
        """Get all permissions for this admin."""
        return ROLE_PERMISSIONS.get(self.role, [])


class AdminSession(Base):
    """Track admin sessions for security."""
    __tablename__ = "admin_sessions"
    
    id = Column(String(36), primary_key=True)
    admin_id = Column(String(36), ForeignKey("admin_users.id"), nullable=False)
    
    # Session data
    token_hash = Column(String(64), nullable=False, unique=True)
    ip_address = Column(String(45), nullable=False)
    user_agent = Column(String(500), nullable=True)
    
    # Lifecycle
    created_at = Column(DateTime, default=datetime.utcnow)
    expires_at = Column(DateTime, nullable=False)
    revoked_at = Column(DateTime, nullable=True)
    
    # Activity
    last_activity_at = Column(DateTime, default=datetime.utcnow)
```

### 2. Admin Authentication Service

**services/admin_auth_service.py:**
```python
"""Admin authentication service with 2FA support."""
import uuid
import pyotp
import hashlib
from datetime import datetime, timedelta
from typing import Optional
from sqlalchemy.orm import Session

from models.admin import AdminUser, AdminSession, AdminRole, Permission
from models.user import User
from schemas.admin import AdminLoginRequest, AdminLoginResponse
from auth import create_access_token, verify_password


class AdminAuthService:
    """Service for admin authentication operations."""
    
    def __init__(self, db: Session):
        self.db = db
        self.session_duration = timedelta(hours=8)
        self.max_sessions = 3
    
    def authenticate(
        self,
        email: str,
        password: str,
        ip_address: str,
        user_agent: Optional[str] = None
    ) -> tuple[Optional[AdminUser], Optional[str]]:
        """Authenticate admin and return admin user or error."""
        # Find user by email
        user = self.db.query(User).filter(User.email == email).first()
        if not user:
            return None, "Invalid credentials"
        
        # Verify password
        if not verify_password(password, user.password_hash):
            return None, "Invalid credentials"
        
        # Check if user is an admin
        admin = self.db.query(AdminUser).filter(
            AdminUser.user_id == user.id,
            AdminUser.is_active == True
        ).first()
        
        if not admin:
            return None, "Not authorized for admin access"
        
        # Update login info
        admin.last_login_at = datetime.utcnow()
        admin.last_login_ip = ip_address
        self.db.commit()
        
        return admin, None
    
    def verify_totp(self, admin: AdminUser, code: str) -> bool:
        """Verify TOTP code for 2FA."""
        if not admin.totp_enabled or not admin.totp_secret:
            return True  # 2FA not enabled
        
        totp = pyotp.TOTP(admin.totp_secret)
        return totp.verify(code, valid_window=1)
    
    def create_admin_session(
        self,
        admin: AdminUser,
        ip_address: str,
        user_agent: Optional[str] = None
    ) -> str:
        """Create admin session and return JWT token."""
        # Enforce max sessions
        active_sessions = self.db.query(AdminSession).filter(
            AdminSession.admin_id == admin.id,
            AdminSession.revoked_at.is_(None),
            AdminSession.expires_at > datetime.utcnow()
        ).order_by(AdminSession.created_at.asc()).all()
        
        if len(active_sessions) >= self.max_sessions:
            # Revoke oldest session
            oldest = active_sessions[0]
            oldest.revoked_at = datetime.utcnow()
        
        # Create JWT with admin claims
        token_data = {
            "sub": admin.user_id,
            "admin_id": admin.id,
            "role": admin.role.value,
            "permissions": [p.value for p in admin.get_permissions()],
            "type": "admin",
        }
        token = create_access_token(token_data, expires_delta=self.session_duration)
        
        # Store session
        session = AdminSession(
            id=str(uuid.uuid4()),
            admin_id=admin.id,
            token_hash=hashlib.sha256(token.encode()).hexdigest(),
            ip_address=ip_address,
            user_agent=user_agent,
            expires_at=datetime.utcnow() + self.session_duration
        )
        self.db.add(session)
        self.db.commit()
        
        return token
    
    def validate_session(self, token: str) -> Optional[AdminSession]:
        """Validate admin session token."""
        token_hash = hashlib.sha256(token.encode()).hexdigest()
        
        session = self.db.query(AdminSession).filter(
            AdminSession.token_hash == token_hash,
            AdminSession.revoked_at.is_(None),
            AdminSession.expires_at > datetime.utcnow()
        ).first()
        
        if session:
            session.last_activity_at = datetime.utcnow()
            self.db.commit()
        
        return session
    
    def revoke_session(self, session_id: str, admin_id: str) -> bool:
        """Revoke an admin session."""
        session = self.db.query(AdminSession).filter(
            AdminSession.id == session_id,
            AdminSession.admin_id == admin_id
        ).first()
        
        if not session:
            return False
        
        session.revoked_at = datetime.utcnow()
        self.db.commit()
        return True
    
    def revoke_all_sessions(self, admin_id: str) -> int:
        """Revoke all sessions for an admin."""
        result = self.db.query(AdminSession).filter(
            AdminSession.admin_id == admin_id,
            AdminSession.revoked_at.is_(None)
        ).update({"revoked_at": datetime.utcnow()})
        
        self.db.commit()
        return result
    
    def setup_totp(self, admin: AdminUser) -> str:
        """Generate TOTP secret for 2FA setup."""
        secret = pyotp.random_base32()
        admin.totp_secret = secret
        self.db.commit()
        
        return pyotp.totp.TOTP(secret).provisioning_uri(
            name=admin.user.email,
            issuer_name="Code Story Admin"
        )
    
    def enable_totp(self, admin: AdminUser, code: str) -> bool:
        """Enable 2FA after verifying setup code."""
        if not admin.totp_secret:
            return False
        
        totp = pyotp.TOTP(admin.totp_secret)
        if totp.verify(code):
            admin.totp_enabled = True
            self.db.commit()
            return True
        
        return False
```

### 3. Admin Authentication Middleware

**auth/admin_auth.py:**
```python
"""Admin authentication middleware and dependencies."""
from fastapi import Request, HTTPException, status, Depends
from fastapi.security import HTTPBearer
from sqlalchemy.orm import Session
from jose import jwt, JWTError

from database import get_db
from config import settings
from models.admin import AdminUser, Permission
from services.admin_auth_service import AdminAuthService

http_bearer = HTTPBearer()


async def get_current_admin(
    request: Request,
    token: str = Depends(http_bearer),
    db: Session = Depends(get_db)
) -> AdminUser:
    """Get current authenticated admin."""
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Invalid admin credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    
    try:
        payload = jwt.decode(
            token.credentials,
            settings.SECRET_KEY,
            algorithms=[settings.ALGORITHM]
        )
        
        # Verify admin token type
        if payload.get("type") != "admin":
            raise credentials_exception
        
        admin_id = payload.get("admin_id")
        if not admin_id:
            raise credentials_exception
            
    except JWTError:
        raise credentials_exception
    
    # Validate session
    service = AdminAuthService(db)
    session = service.validate_session(token.credentials)
    if not session:
        raise credentials_exception
    
    # Get admin user
    admin = db.query(AdminUser).filter(
        AdminUser.id == admin_id,
        AdminUser.is_active == True
    ).first()
    
    if not admin:
        raise credentials_exception
    
    # Store admin in request state for audit logging
    request.state.admin = admin
    
    return admin


def require_permission(permission: Permission):
    """Dependency factory for permission checking."""
    
    async def check_permission(
        admin: AdminUser = Depends(get_current_admin)
    ) -> AdminUser:
        if not admin.has_permission(permission):
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail=f"Permission denied: {permission.value}"
            )
        return admin
    
    return check_permission


# Convenience dependencies for common permissions
require_view_users = require_permission(Permission.VIEW_USERS)
require_edit_users = require_permission(Permission.EDIT_USERS)
require_manage_admins = require_permission(Permission.MANAGE_ADMINS)
require_view_analytics = require_permission(Permission.VIEW_ANALYTICS)
require_system_settings = require_permission(Permission.SYSTEM_SETTINGS)
```

### 4. Admin Authentication Router

**routers/admin_auth.py:**
```python
"""Admin authentication endpoints."""
from fastapi import APIRouter, Depends, HTTPException, status, Request
from sqlalchemy.orm import Session

from database import get_db
from models.admin import AdminUser
from schemas.admin import (
    AdminLoginRequest,
    AdminLoginResponse,
    AdminTOTPSetup,
    AdminTOTPVerify,
    AdminSessionList,
)
from services.admin_auth_service import AdminAuthService
from auth.admin_auth import get_current_admin

router = APIRouter(prefix="/admin/auth", tags=["admin-auth"])


@router.post("/login", response_model=AdminLoginResponse)
async def admin_login(
    request: Request,
    login_data: AdminLoginRequest,
    db: Session = Depends(get_db)
):
    """Authenticate admin user."""
    service = AdminAuthService(db)
    
    ip_address = request.client.host if request.client else "unknown"
    user_agent = request.headers.get("user-agent")
    
    admin, error = service.authenticate(
        email=login_data.email,
        password=login_data.password,
        ip_address=ip_address,
        user_agent=user_agent
    )
    
    if error:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail=error
        )
    
    # Check 2FA if enabled
    if admin.totp_enabled:
        if not login_data.totp_code:
            return AdminLoginResponse(
                requires_2fa=True,
                message="2FA code required"
            )
        
        if not service.verify_totp(admin, login_data.totp_code):
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Invalid 2FA code"
            )
    
    # Create session
    token = service.create_admin_session(admin, ip_address, user_agent)
    
    return AdminLoginResponse(
        access_token=token,
        token_type="bearer",
        admin_id=admin.id,
        role=admin.role.value,
        permissions=[p.value for p in admin.get_permissions()]
    )


@router.post("/logout")
async def admin_logout(
    admin: AdminUser = Depends(get_current_admin),
    db: Session = Depends(get_db)
):
    """Logout current admin session."""
    service = AdminAuthService(db)
    service.revoke_all_sessions(admin.id)
    return {"message": "Logged out successfully"}


@router.get("/me", response_model=dict)
async def get_current_admin_info(
    admin: AdminUser = Depends(get_current_admin)
):
    """Get current admin user info."""
    return {
        "id": admin.id,
        "user_id": admin.user_id,
        "email": admin.user.email,
        "role": admin.role.value,
        "permissions": [p.value for p in admin.get_permissions()],
        "totp_enabled": admin.totp_enabled,
        "last_login_at": admin.last_login_at,
    }


@router.post("/2fa/setup", response_model=AdminTOTPSetup)
async def setup_2fa(
    admin: AdminUser = Depends(get_current_admin),
    db: Session = Depends(get_db)
):
    """Generate 2FA setup QR code."""
    if admin.totp_enabled:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="2FA already enabled"
        )
    
    service = AdminAuthService(db)
    provisioning_uri = service.setup_totp(admin)
    
    return AdminTOTPSetup(
        secret=admin.totp_secret,
        provisioning_uri=provisioning_uri
    )


@router.post("/2fa/verify")
async def verify_2fa(
    data: AdminTOTPVerify,
    admin: AdminUser = Depends(get_current_admin),
    db: Session = Depends(get_db)
):
    """Verify 2FA code and enable 2FA."""
    service = AdminAuthService(db)
    
    if not service.enable_totp(admin, data.code):
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Invalid verification code"
        )
    
    return {"message": "2FA enabled successfully"}


@router.get("/sessions", response_model=AdminSessionList)
async def list_sessions(
    admin: AdminUser = Depends(get_current_admin),
    db: Session = Depends(get_db)
):
    """List active admin sessions."""
    from models.admin import AdminSession
    
    sessions = db.query(AdminSession).filter(
        AdminSession.admin_id == admin.id,
        AdminSession.revoked_at.is_(None),
        AdminSession.expires_at > datetime.utcnow()
    ).all()
    
    return AdminSessionList(sessions=sessions)


@router.delete("/sessions/{session_id}")
async def revoke_session(
    session_id: str,
    admin: AdminUser = Depends(get_current_admin),
    db: Session = Depends(get_db)
):
    """Revoke a specific session."""
    service = AdminAuthService(db)
    
    if not service.revoke_session(session_id, admin.id):
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Session not found"
        )
    
    return {"message": "Session revoked"}
```

## File Structure
```
backend/
├── models/
│   └── admin.py
├── schemas/
│   └── admin.py
├── services/
│   └── admin_auth_service.py
├── routers/
│   └── admin_auth.py
└── auth/
    └── admin_auth.py
```

## Validation Gates

### Gate 1: Admin Login
```python
def test_admin_login():
    """Verify admin can authenticate."""
    response = client.post("/admin/auth/login", json={
        "email": "admin@codestory.dev",
        "password": "secure_password"
    })
    
    assert response.status_code == 200
    data = response.json()
    assert "access_token" in data
    assert data["role"] in ["super_admin", "admin", "support"]
```

### Gate 2: Permission Enforcement
```python
def test_permission_enforcement():
    """Verify permissions are enforced."""
    # Login as support (limited permissions)
    support_token = login_as_support()
    
    # Try to delete user (requires EDIT_USERS)
    response = client.delete(
        "/admin/users/user_123",
        headers={"Authorization": f"Bearer {support_token}"}
    )
    
    assert response.status_code == 403
    assert "Permission denied" in response.json()["detail"]
```

### Gate 3: 2FA Flow
```python
def test_2fa_setup_and_login():
    """Verify 2FA setup and authentication."""
    # Setup 2FA
    setup_resp = client.post(
        "/admin/auth/2fa/setup",
        headers=admin_headers
    )
    secret = setup_resp.json()["secret"]
    
    # Generate valid TOTP
    import pyotp
    totp = pyotp.TOTP(secret)
    code = totp.now()
    
    # Verify and enable
    client.post("/admin/auth/2fa/verify", json={"code": code}, headers=admin_headers)
    
    # Logout and login with 2FA
    client.post("/admin/auth/logout", headers=admin_headers)
    
    # Login without 2FA code
    login_resp = client.post("/admin/auth/login", json={
        "email": "admin@codestory.dev",
        "password": "secure_password"
    })
    assert login_resp.json()["requires_2fa"] == True
    
    # Login with 2FA code
    new_code = totp.now()
    login_resp = client.post("/admin/auth/login", json={
        "email": "admin@codestory.dev",
        "password": "secure_password",
        "totp_code": new_code
    })
    assert "access_token" in login_resp.json()
```

### Gate 4: Session Management
```python
def test_session_management():
    """Verify session listing and revocation."""
    # List sessions
    sessions_resp = client.get("/admin/auth/sessions", headers=admin_headers)
    sessions = sessions_resp.json()["sessions"]
    assert len(sessions) >= 1
    
    # Revoke session
    session_id = sessions[0]["id"]
    client.delete(f"/admin/auth/sessions/{session_id}", headers=admin_headers)
    
    # Verify session is revoked (can't use old token)
    # This requires the revoked session's token
```

## Security Considerations

1. **Separate Admin JWT**: Admin tokens have distinct claims from user tokens
2. **2FA Support**: TOTP-based two-factor authentication
3. **Session Tracking**: All sessions tracked with IP and user agent
4. **Session Limits**: Maximum 3 concurrent sessions per admin
5. **Audit Trail**: Login attempts and actions logged
6. **IP Logging**: Track login locations for security
7. **Token Rotation**: Short-lived tokens (8 hours)

## Definition of Done
- [ ] Admin user model with roles
- [ ] Permission system with role-based access
- [ ] Admin authentication service
- [ ] TOTP 2FA setup and verification
- [ ] Admin session management
- [ ] Permission checking middleware
- [ ] Admin auth endpoints
- [ ] Session listing and revocation
- [ ] All validation gates passing
