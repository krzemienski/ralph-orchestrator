---
phase: 01-foundation
type: execute
domain: python-agent-sdk
---

<objective>
Create the base skill library structure with shared utility functions and placeholder skill modules.

Purpose: Establish the skill infrastructure that all 4 agents will use, with common utilities for HTTP requests, data parsing, and error handling.
Output: Skill module structure with base utilities ready for domain-specific skill implementation.
</objective>


<context>
@BRIEF.md
@ROADMAP.md
@plans/01-foundation/01-01-SUMMARY.md
@plans/01-foundation/01-02-SUMMARY.md
@plans/01-foundation/01-03-SUMMARY.md
@plans/01-foundation/01-04-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <n>Task 1: Create shared utility module for skills</n>
  <files>src/codestory/skills/utils.py</files>
  <action>
    Implement shared utilities used across all skill modules:
    
    ```python
    # src/codestory/skills/utils.py
    """Shared utilities for Code Story skills."""
    
    import asyncio
    import json
    import re
    from typing import Any, TypeVar, Callable
    from functools import wraps
    import httpx
    from datetime import datetime
    
    
    T = TypeVar("T")
    
    
    class SkillError(Exception):
        """Base exception for skill errors."""
        
        def __init__(self, message: str, code: str | None = None, details: dict | None = None):
            super().__init__(message)
            self.code = code
            self.details = details or {}
    
    
    class RateLimitError(SkillError):
        """Raised when an API rate limit is hit."""
        pass
    
    
    class APIError(SkillError):
        """Raised when an external API returns an error."""
        pass
    
    
    class ValidationError(SkillError):
        """Raised when input validation fails."""
        pass
    
    
    # HTTP Client with retry logic
    class HTTPClient:
        """Async HTTP client with retry and rate limiting support."""
        
        def __init__(
            self,
            base_url: str = "",
            headers: dict[str, str] | None = None,
            timeout: float = 30.0,
            max_retries: int = 3,
            retry_delay: float = 1.0,
        ):
            self.base_url = base_url.rstrip("/")
            self.default_headers = headers or {}
            self.timeout = timeout
            self.max_retries = max_retries
            self.retry_delay = retry_delay
            self._client: httpx.AsyncClient | None = None
        
        async def _get_client(self) -> httpx.AsyncClient:
            """Get or create the HTTP client."""
            if self._client is None:
                self._client = httpx.AsyncClient(
                    base_url=self.base_url,
                    headers=self.default_headers,
                    timeout=self.timeout,
                )
            return self._client
        
        async def close(self) -> None:
            """Close the HTTP client."""
            if self._client:
                await self._client.aclose()
                self._client = None
        
        async def request(
            self,
            method: str,
            path: str,
            **kwargs,
        ) -> dict[str, Any]:
            """Make an HTTP request with retry logic.
            
            Args:
                method: HTTP method (GET, POST, etc.)
                path: URL path (will be joined with base_url)
                **kwargs: Additional arguments passed to httpx
            
            Returns:
                Parsed JSON response
            
            Raises:
                APIError: If the request fails after retries
                RateLimitError: If rate limited
            """
            client = await self._get_client()
            last_error: Exception | None = None
            
            for attempt in range(self.max_retries):
                try:
                    response = await client.request(method, path, **kwargs)
                    
                    # Handle rate limiting
                    if response.status_code == 429:
                        retry_after = int(response.headers.get("Retry-After", self.retry_delay * 2))
                        if attempt < self.max_retries - 1:
                            await asyncio.sleep(retry_after)
                            continue
                        raise RateLimitError(
                            f"Rate limited on {path}",
                            code="RATE_LIMITED",
                            details={"retry_after": retry_after},
                        )
                    
                    # Handle errors
                    if response.status_code >= 400:
                        error_body = response.text
                        try:
                            error_body = response.json()
                        except json.JSONDecodeError:
                            pass
                        
                        raise APIError(
                            f"API error {response.status_code} on {path}",
                            code=f"HTTP_{response.status_code}",
                            details={"response": error_body},
                        )
                    
                    # Parse response
                    if response.headers.get("content-type", "").startswith("application/json"):
                        return response.json()
                    return {"content": response.text}
                    
                except (httpx.ConnectError, httpx.TimeoutException) as e:
                    last_error = e
                    if attempt < self.max_retries - 1:
                        await asyncio.sleep(self.retry_delay * (attempt + 1))
                        continue
            
            raise APIError(
                f"Request failed after {self.max_retries} retries: {last_error}",
                code="CONNECTION_FAILED",
            )
        
        async def get(self, path: str, **kwargs) -> dict[str, Any]:
            """Make a GET request."""
            return await self.request("GET", path, **kwargs)
        
        async def post(self, path: str, **kwargs) -> dict[str, Any]:
            """Make a POST request."""
            return await self.request("POST", path, **kwargs)
    
    
    # Data parsing utilities
    def parse_github_url(url: str) -> tuple[str, str]:
        """Parse a GitHub URL to extract owner and repo.
        
        Args:
            url: GitHub repository URL
        
        Returns:
            Tuple of (owner, repo_name)
        
        Raises:
            ValidationError: If URL is not a valid GitHub URL
        """
        patterns = [
            r"github\.com[:/]([^/]+)/([^/\.]+)",  # HTTPS or SSH
            r"^([^/]+)/([^/]+)$",  # owner/repo format
        ]
        
        for pattern in patterns:
            match = re.search(pattern, url)
            if match:
                owner, repo = match.groups()
                repo = repo.rstrip(".git")
                return owner, repo
        
        raise ValidationError(
            f"Invalid GitHub URL: {url}",
            code="INVALID_GITHUB_URL",
        )
    
    
    def truncate_text(text: str, max_length: int, suffix: str = "...") -> str:
        """Truncate text to a maximum length.
        
        Args:
            text: Text to truncate
            max_length: Maximum length including suffix
            suffix: String to append when truncating
        
        Returns:
            Truncated text
        """
        if len(text) <= max_length:
            return text
        return text[: max_length - len(suffix)] + suffix
    
    
    def safe_json_parse(text: str, default: T = None) -> dict | list | T:
        """Safely parse JSON text.
        
        Args:
            text: JSON string to parse
            default: Default value if parsing fails
        
        Returns:
            Parsed JSON or default value
        """
        try:
            return json.loads(text)
        except json.JSONDecodeError:
            return default
    
    
    def format_timestamp(dt: datetime | None = None) -> str:
        """Format a datetime as ISO 8601 string.
        
        Args:
            dt: Datetime to format (defaults to now)
        
        Returns:
            ISO 8601 formatted string
        """
        if dt is None:
            dt = datetime.utcnow()
        return dt.strftime("%Y-%m-%dT%H:%M:%SZ")
    
    
    def estimate_tokens(text: str) -> int:
        """Estimate the number of tokens in text.
        
        Uses a simple heuristic of ~4 characters per token.
        
        Args:
            text: Text to estimate
        
        Returns:
            Estimated token count
        """
        return len(text) // 4
    
    
    def chunk_text(text: str, max_tokens: int = 4000) -> list[str]:
        """Split text into chunks that fit within token limits.
        
        Args:
            text: Text to chunk
            max_tokens: Maximum tokens per chunk
        
        Returns:
            List of text chunks
        """
        max_chars = max_tokens * 4  # Approximate
        chunks = []
        
        # Try to split on paragraph boundaries
        paragraphs = text.split("\n\n")
        current_chunk = ""
        
        for para in paragraphs:
            if len(current_chunk) + len(para) + 2 <= max_chars:
                if current_chunk:
                    current_chunk += "\n\n"
                current_chunk += para
            else:
                if current_chunk:
                    chunks.append(current_chunk)
                # If single paragraph exceeds limit, force split
                if len(para) > max_chars:
                    for i in range(0, len(para), max_chars):
                        chunks.append(para[i : i + max_chars])
                    current_chunk = ""
                else:
                    current_chunk = para
        
        if current_chunk:
            chunks.append(current_chunk)
        
        return chunks
    
    
    # Decorator for skill method error handling
    def handle_skill_errors(func: Callable) -> Callable:
        """Decorator to handle and wrap skill errors consistently.
        
        Usage:
            @handle_skill_errors
            async def my_skill_method(self, ...):
                ...
        """
        @wraps(func)
        async def wrapper(*args, **kwargs):
            try:
                return await func(*args, **kwargs)
            except SkillError:
                raise  # Re-raise skill errors as-is
            except Exception as e:
                raise SkillError(
                    f"Unexpected error in {func.__name__}: {str(e)}",
                    code="UNEXPECTED_ERROR",
                    details={"original_error": str(e)},
                )
        return wrapper
    ```
    
    Avoid: Do NOT skip error handling, do NOT hardcode timeouts without configuration.
  </action>
  <verify>Utils module imports correctly, HTTP client works, parsing functions tested</verify>
  <done>Shared utility module with HTTP client, error handling, and parsing utilities</done>
</task>

<task type="auto">
  <n>Task 2: Create placeholder skill modules with structure</n>
  <files>src/codestory/skills/github.py, src/codestory/skills/analysis.py, src/codestory/skills/narrative.py, src/codestory/skills/voice.py</files>
  <action>
    Create placeholder skill modules with proper structure:
    
    **github.py** - GitHub API skills (placeholder):
    ```python
    # src/codestory/skills/github.py
    """GitHub API skills for repository analysis."""
    
    from ..agents.base import Skill, skill
    from .utils import HTTPClient, parse_github_url, handle_skill_errors
    from ..core.config import get_settings
    
    
    class GitHubSkills(Skill):
        """Skills for interacting with the GitHub API.
        
        Provides tools for:
        - Fetching repository structure
        - Reading file contents
        - Getting commit history
        - Analyzing pull requests
        """
        
        def __init__(self):
            super().__init__()
            settings = get_settings()
            headers = {}
            if settings.has_github_token():
                headers["Authorization"] = f"Bearer {settings.github_token}"
            headers["Accept"] = "application/vnd.github.v3+json"
            
            self.client = HTTPClient(
                base_url=settings.github_api_base,
                headers=headers,
            )
        
        @skill(description="Fetch the directory tree structure of a GitHub repository")
        @handle_skill_errors
        async def fetch_repo_tree(self, repo_url: str, branch: str = "main") -> dict:
            """Fetch repository file tree.
            
            Args:
                repo_url: GitHub repository URL
                branch: Branch name to fetch (default: main)
            
            Returns:
                Repository tree structure with files and directories
            """
            owner, repo = parse_github_url(repo_url)
            # Implementation will be added in Phase 3
            return {
                "owner": owner,
                "repo": repo,
                "branch": branch,
                "tree": [],
                "status": "placeholder",
            }
        
        @skill(description="Fetch the contents of a specific file from a GitHub repository")
        @handle_skill_errors
        async def fetch_file_content(self, repo_url: str, file_path: str) -> dict:
            """Fetch a file's contents from a repository.
            
            Args:
                repo_url: GitHub repository URL
                file_path: Path to the file within the repository
            
            Returns:
                File content and metadata
            """
            owner, repo = parse_github_url(repo_url)
            # Implementation will be added in Phase 3
            return {
                "owner": owner,
                "repo": repo,
                "path": file_path,
                "content": "",
                "status": "placeholder",
            }
        
        async def close(self) -> None:
            """Close HTTP client connections."""
            await self.client.close()
    ```
    
    **analysis.py** - Code analysis skills (placeholder):
    ```python
    # src/codestory/skills/analysis.py
    """Code analysis skills for understanding repository structure."""
    
    from ..agents.base import Skill, skill
    from .utils import handle_skill_errors
    
    
    class AnalysisSkills(Skill):
        """Skills for analyzing code structure and patterns.
        
        Provides tools for:
        - Parsing Python AST
        - Identifying architectural patterns
        - Mapping dependencies
        - Finding key components
        """
        
        @skill(description="Analyze Python file structure including classes, functions, and imports")
        @handle_skill_errors
        async def analyze_python_structure(self, code: str, filename: str = "") -> dict:
            """Analyze Python code structure.
            
            Args:
                code: Python source code
                filename: Optional filename for context
            
            Returns:
                Structured analysis of classes, functions, imports
            """
            # Implementation will be added in Phase 3
            return {
                "filename": filename,
                "classes": [],
                "functions": [],
                "imports": [],
                "status": "placeholder",
            }
        
        @skill(description="Identify architectural patterns in the codebase")
        @handle_skill_errors
        async def identify_patterns(self, file_tree: dict, sample_files: list) -> dict:
            """Identify architectural patterns.
            
            Args:
                file_tree: Repository file tree structure
                sample_files: List of sample file contents for analysis
            
            Returns:
                Identified patterns and architecture description
            """
            # Implementation will be added in Phase 3
            return {
                "patterns": [],
                "architecture": "",
                "status": "placeholder",
            }
    ```
    
    **narrative.py** - Narrative generation skills (placeholder):
    ```python
    # src/codestory/skills/narrative.py
    """Narrative generation skills for creating story scripts."""
    
    from ..agents.base import Skill, skill
    from .utils import handle_skill_errors
    
    
    class NarrativeSkills(Skill):
        """Skills for generating narrative content.
        
        Provides tools for:
        - Creating chapter scripts
        - Applying narrative styles
        - Calculating pacing
        - Adding voice direction markers
        """
        
        @skill(description="Generate a chapter script from code analysis")
        @handle_skill_errors
        async def create_chapter_script(
            self,
            chapter_topic: str,
            analysis_data: dict,
            style: str = "documentary",
        ) -> dict:
            """Create a chapter script.
            
            Args:
                chapter_topic: Topic or focus of the chapter
                analysis_data: Code analysis data for the chapter
                style: Narrative style to use
            
            Returns:
                Chapter script with content and metadata
            """
            # Implementation will be added in Phase 4
            return {
                "topic": chapter_topic,
                "style": style,
                "script": "",
                "duration_estimate": 0,
                "status": "placeholder",
            }
        
        @skill(description="Calculate optimal pacing for the narrative")
        @handle_skill_errors
        async def calculate_pacing(
            self,
            total_content: str,
            target_duration_minutes: int = 10,
        ) -> dict:
            """Calculate narrative pacing.
            
            Args:
                total_content: Full narrative content
                target_duration_minutes: Target duration in minutes
            
            Returns:
                Pacing recommendations and timing breakdown
            """
            # Implementation will be added in Phase 4
            return {
                "target_duration": target_duration_minutes,
                "recommended_wpm": 150,
                "sections": [],
                "status": "placeholder",
            }
    ```
    
    **voice.py** - Voice synthesis skills (placeholder):
    ```python
    # src/codestory/skills/voice.py
    """Voice synthesis skills for audio generation."""
    
    from ..agents.base import Skill, skill
    from .utils import HTTPClient, handle_skill_errors, chunk_text
    from ..core.config import get_settings
    
    
    class VoiceSkills(Skill):
        """Skills for voice synthesis with ElevenLabs.
        
        Provides tools for:
        - Text-to-speech synthesis
        - Audio chunking for API limits
        - Audio file assembly
        - Voice style configuration
        """
        
        def __init__(self):
            super().__init__()
            settings = get_settings()
            headers = {}
            if settings.has_elevenlabs_key():
                headers["xi-api-key"] = settings.elevenlabs_api_key
            
            self.client = HTTPClient(
                base_url="https://api.elevenlabs.io/v1",
                headers=headers,
            )
            self.default_voice = settings.elevenlabs_default_voice
            self.model = settings.elevenlabs_model
        
        @skill(description="Synthesize speech from text using ElevenLabs")
        @handle_skill_errors
        async def synthesize_speech(
            self,
            text: str,
            voice_id: str | None = None,
            stability: float = 0.5,
            similarity_boost: float = 0.75,
        ) -> dict:
            """Synthesize speech from text.
            
            Args:
                text: Text to synthesize
                voice_id: ElevenLabs voice ID (uses default if not specified)
                stability: Voice stability (0-1)
                similarity_boost: Similarity boost (0-1)
            
            Returns:
                Audio data or URL to audio file
            """
            voice = voice_id or self.default_voice
            # Implementation will be added in Phase 5
            return {
                "voice_id": voice,
                "text_length": len(text),
                "audio_url": "",
                "status": "placeholder",
            }
        
        @skill(description="Prepare long text for synthesis by chunking appropriately")
        @handle_skill_errors
        async def prepare_for_synthesis(
            self,
            script: str,
            max_chunk_chars: int = 5000,
        ) -> dict:
            """Prepare a script for synthesis by chunking.
            
            Args:
                script: Full script text
                max_chunk_chars: Maximum characters per chunk
            
            Returns:
                List of text chunks ready for synthesis
            """
            chunks = chunk_text(script, max_tokens=max_chunk_chars // 4)
            return {
                "total_length": len(script),
                "chunk_count": len(chunks),
                "chunks": chunks,
                "status": "placeholder",
            }
        
        async def close(self) -> None:
            """Close HTTP client connections."""
            await self.client.close()
    ```
    
    Avoid: Do NOT implement full functionality yet (Phase 3-5), do NOT skip HTTP client setup.
  </action>
  <verify>All skill modules import correctly, placeholder methods work</verify>
  <done>Placeholder skill modules for GitHub, Analysis, Narrative, and Voice</done>
</task>

<task type="auto">
  <n>Task 3: Update skills module exports</n>
  <files>src/codestory/skills/__init__.py</files>
  <action>
    Create comprehensive skills module exports:
    
    ```python
    # src/codestory/skills/__init__.py
    """Skill library for Code Story agents.
    
    Skills are collections of tools that agents can use to perform tasks.
    Each skill module provides domain-specific functionality:
    
    - github: GitHub API integration for repository access
    - analysis: Code structure analysis and pattern recognition  
    - narrative: Story script generation and pacing
    - voice: ElevenLabs voice synthesis
    """
    
    from .utils import (
        SkillError,
        RateLimitError,
        APIError,
        ValidationError,
        HTTPClient,
        parse_github_url,
        truncate_text,
        safe_json_parse,
        format_timestamp,
        estimate_tokens,
        chunk_text,
        handle_skill_errors,
    )
    
    from .github import GitHubSkills
    from .analysis import AnalysisSkills
    from .narrative import NarrativeSkills
    from .voice import VoiceSkills
    
    
    __all__ = [
        # Utilities
        "SkillError",
        "RateLimitError",
        "APIError",
        "ValidationError",
        "HTTPClient",
        "parse_github_url",
        "truncate_text",
        "safe_json_parse",
        "format_timestamp",
        "estimate_tokens",
        "chunk_text",
        "handle_skill_errors",
        # Skill classes
        "GitHubSkills",
        "AnalysisSkills",
        "NarrativeSkills",
        "VoiceSkills",
    ]
    ```
    
    Avoid: Do NOT skip utility exports, do NOT mix up class names.
  </action>
  <verify>All exports working, `from codestory.skills import *` succeeds</verify>
  <done>Complete skills module exports with utilities and all skill classes</done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] `uv run python -c "from codestory.skills import GitHubSkills, AnalysisSkills"` succeeds
- [ ] HTTPClient with retry logic instantiates correctly
- [ ] parse_github_url correctly parses various URL formats
- [ ] All skill classes extend base Skill class
- [ ] @skill decorator registers tools on skill classes
</verification>

<success_criteria>
- Utility module with HTTP client and helpers ready
- All 4 skill modules created with placeholder implementations
- Skills module exports all components
- Foundation ready for domain-specific implementation in Phases 3-5
</success_criteria>

<o>
After completion, create `plans/01-foundation/01-05-SUMMARY.md`

This completes Phase 1: Foundation. The Validation Gate should verify:
- Project initializes with `uv sync`
- All imports work: codestory.agents, codestory.skills, codestory.core, codestory.models
- Agent framework can instantiate (Agent, Skill, Orchestrator classes)
- Database models define correct schema
</o>
