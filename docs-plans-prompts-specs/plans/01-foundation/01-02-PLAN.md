---
phase: 01-foundation
type: execute
domain: database
---

<objective>
Design and implement PostgreSQL database schema with SQLAlchemy models and Alembic migrations.

Purpose: Establish the data layer that persists users, repositories, story intents, generated stories, and usage tracking.
Output: Working database models, migration files, and database connection utilities.
</objective>


<context>
@BRIEF.md
@ROADMAP.md
@plans/01-foundation/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <n>Task 1: Create SQLAlchemy database configuration</n>
  <files>src/codestory/models/database.py</files>
  <action>
    Implement database setup with async SQLAlchemy:
    
    ```python
    # src/codestory/models/database.py
    from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession, async_sessionmaker
    from sqlalchemy.orm import DeclarativeBase
    from typing import AsyncGenerator
    
    class Base(DeclarativeBase):
        """Base class for all SQLAlchemy models."""
        pass
    
    # Engine and session factory (initialized from config)
    engine = None
    async_session_factory = None
    
    async def init_db(database_url: str) -> None:
        """Initialize database engine and session factory."""
        global engine, async_session_factory
        engine = create_async_engine(database_url, echo=False)
        async_session_factory = async_sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)
    
    async def get_session() -> AsyncGenerator[AsyncSession, None]:
        """Dependency for FastAPI to get database session."""
        if async_session_factory is None:
            raise RuntimeError("Database not initialized. Call init_db() first.")
        async with async_session_factory() as session:
            yield session
    
    async def close_db() -> None:
        """Close database connections."""
        global engine
        if engine:
            await engine.dispose()
    ```
    
    Avoid: Do NOT use synchronous SQLAlchemy, do NOT hardcode connection strings.
  </action>
  <verify>File exists with proper async setup, imports work correctly</verify>
  <done>Async SQLAlchemy database configuration with engine, session factory, and dependency injection</done>
</task>

<task type="auto">
  <n>Task 2: Implement SQLAlchemy models</n>
  <files>src/codestory/models/user.py, src/codestory/models/story.py, src/codestory/models/intent.py</files>
  <action>
    Create SQLAlchemy models matching the schema design:
    
    **user.py** - User and API key models:
    ```python
    from sqlalchemy import Column, String, DateTime, Boolean, Integer, ForeignKey, JSON
    from sqlalchemy.orm import relationship
    from sqlalchemy.dialects.postgresql import UUID
    from datetime import datetime
    import uuid
    from .database import Base
    
    class User(Base):
        __tablename__ = "users"
        
        id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
        email = Column(String(255), unique=True, nullable=False, index=True)
        password_hash = Column(String(255), nullable=False)
        subscription_tier = Column(String(50), default="free")  # free, pro, enterprise
        preferences = Column(JSON, default=dict)
        usage_quota = Column(Integer, default=10)  # stories per month
        created_at = Column(DateTime, default=datetime.utcnow)
        updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
        
        # Relationships
        stories = relationship("Story", back_populates="user")
        intents = relationship("StoryIntent", back_populates="user")
        api_keys = relationship("APIKey", back_populates="user")
    
    class APIKey(Base):
        __tablename__ = "api_keys"
        
        id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
        user_id = Column(UUID(as_uuid=True), ForeignKey("users.id"), nullable=False)
        name = Column(String(100), nullable=False)
        key_hash = Column(String(255), nullable=False, unique=True)
        permissions = Column(JSON, default=list)
        rate_limit = Column(Integer, default=100)  # requests per hour
        is_active = Column(Boolean, default=True)
        last_used_at = Column(DateTime, nullable=True)
        created_at = Column(DateTime, default=datetime.utcnow)
        
        user = relationship("User", back_populates="api_keys")
    ```
    
    **story.py** - Story and chapter models:
    ```python
    from sqlalchemy import Column, String, DateTime, Integer, ForeignKey, Text, JSON, Float
    from sqlalchemy.orm import relationship
    from sqlalchemy.dialects.postgresql import UUID
    from datetime import datetime
    import uuid
    from .database import Base
    
    class Repository(Base):
        __tablename__ = "repositories"
        
        id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
        user_id = Column(UUID(as_uuid=True), ForeignKey("users.id"), nullable=False)
        repo_url = Column(String(500), nullable=False)
        repo_owner = Column(String(100), nullable=False)
        repo_name = Column(String(100), nullable=False)
        default_branch = Column(String(100), default="main")
        analysis_cache = Column(JSON, nullable=True)  # Cached analysis results
        last_analyzed_at = Column(DateTime, nullable=True)
        created_at = Column(DateTime, default=datetime.utcnow)
        
        stories = relationship("Story", back_populates="repository")
        intents = relationship("StoryIntent", back_populates="repository")
    
    class Story(Base):
        __tablename__ = "stories"
        
        id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
        user_id = Column(UUID(as_uuid=True), ForeignKey("users.id"), nullable=False)
        repository_id = Column(UUID(as_uuid=True), ForeignKey("repositories.id"), nullable=False)
        intent_id = Column(UUID(as_uuid=True), ForeignKey("story_intents.id"), nullable=True)
        
        title = Column(String(255), nullable=False)
        narrative_style = Column(String(50), nullable=False)  # fiction, documentary, tutorial, podcast, technical
        voice_id = Column(String(100), nullable=True)  # ElevenLabs voice ID
        
        script_text = Column(Text, nullable=True)
        audio_url = Column(String(500), nullable=True)
        duration_seconds = Column(Float, nullable=True)
        
        status = Column(String(50), default="pending")  # pending, analyzing, generating, synthesizing, complete, failed
        error_message = Column(Text, nullable=True)
        
        created_at = Column(DateTime, default=datetime.utcnow)
        completed_at = Column(DateTime, nullable=True)
        
        user = relationship("User", back_populates="stories")
        repository = relationship("Repository", back_populates="stories")
        intent = relationship("StoryIntent", back_populates="story")
        chapters = relationship("StoryChapter", back_populates="story", order_by="StoryChapter.chapter_number")
    
    class StoryChapter(Base):
        __tablename__ = "story_chapters"
        
        id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
        story_id = Column(UUID(as_uuid=True), ForeignKey("stories.id"), nullable=False)
        
        chapter_number = Column(Integer, nullable=False)
        title = Column(String(255), nullable=False)
        start_time_seconds = Column(Float, nullable=False)
        duration_seconds = Column(Float, nullable=True)
        
        script_segment = Column(Text, nullable=True)
        audio_url = Column(String(500), nullable=True)
        
        created_at = Column(DateTime, default=datetime.utcnow)
        
        story = relationship("Story", back_populates="chapters")
    ```
    
    **intent.py** - Story intent model:
    ```python
    from sqlalchemy import Column, String, DateTime, ForeignKey, Text, JSON
    from sqlalchemy.orm import relationship
    from sqlalchemy.dialects.postgresql import UUID
    from datetime import datetime
    import uuid
    from .database import Base
    
    class StoryIntent(Base):
        __tablename__ = "story_intents"
        
        id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
        user_id = Column(UUID(as_uuid=True), ForeignKey("users.id"), nullable=False)
        repository_id = Column(UUID(as_uuid=True), ForeignKey("repositories.id"), nullable=False)
        
        intent_category = Column(String(100), nullable=False)  # onboarding, architecture, feature, debugging
        expertise_level = Column(String(50), default="intermediate")  # beginner, intermediate, expert
        focus_areas = Column(JSON, default=list)  # List of components/features to focus on
        learning_goals = Column(Text, nullable=True)
        
        conversation_history = Column(JSON, default=list)  # Chat history with Intent Agent
        generated_plan = Column(JSON, nullable=True)  # Structured story plan
        
        created_at = Column(DateTime, default=datetime.utcnow)
        updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
        
        user = relationship("User", back_populates="intents")
        repository = relationship("Repository", back_populates="intents")
        story = relationship("Story", back_populates="intent", uselist=False)
    ```
    
    Update `src/codestory/models/__init__.py`:
    ```python
    """Database models for Code Story."""
    from .database import Base, init_db, get_session, close_db
    from .user import User, APIKey
    from .story import Repository, Story, StoryChapter
    from .intent import StoryIntent
    
    __all__ = [
        "Base", "init_db", "get_session", "close_db",
        "User", "APIKey",
        "Repository", "Story", "StoryChapter",
        "StoryIntent",
    ]
    ```
    
    Avoid: Do NOT use deprecated SQLAlchemy patterns, do NOT skip relationship definitions.
  </action>
  <verify>All model files created, imports work, relationships properly defined</verify>
  <done>Complete SQLAlchemy models: User, APIKey, Repository, Story, StoryChapter, StoryIntent</done>
</task>

<task type="auto">
  <n>Task 3: Initialize Alembic and create initial migration</n>
  <files>alembic.ini, alembic/env.py, alembic/versions/001_initial_schema.py</files>
  <action>
    Initialize Alembic for database migrations:
    
    1. Run `uv run alembic init alembic` to create structure
    
    2. Configure alembic.ini:
       - Set `sqlalchemy.url = %(DATABASE_URL)s`
       - Configure naming conventions for constraints
    
    3. Update alembic/env.py for async support:
       ```python
       import asyncio
       from logging.config import fileConfig
       from sqlalchemy.ext.asyncio import create_async_engine
       from alembic import context
       import os
       
       from codestory.models import Base
       
       config = context.config
       if config.config_file_name is not None:
           fileConfig(config.config_file_name)
       
       target_metadata = Base.metadata
       
       def get_url():
           return os.environ.get("DATABASE_URL", "postgresql+asyncpg://localhost/codestory")
       
       def run_migrations_offline():
           url = get_url()
           context.configure(
               url=url,
               target_metadata=target_metadata,
               literal_binds=True,
               dialect_opts={"paramstyle": "named"},
           )
           with context.begin_transaction():
               context.run_migrations()
       
       def do_run_migrations(connection):
           context.configure(connection=connection, target_metadata=target_metadata)
           with context.begin_transaction():
               context.run_migrations()
       
       async def run_async_migrations():
           connectable = create_async_engine(get_url())
           async with connectable.connect() as connection:
               await connection.run_sync(do_run_migrations)
           await connectable.dispose()
       
       def run_migrations_online():
           asyncio.run(run_async_migrations())
       
       if context.is_offline_mode():
           run_migrations_offline()
       else:
           run_migrations_online()
       ```
    
    4. Generate initial migration:
       `uv run alembic revision --autogenerate -m "Initial schema"`
    
    Avoid: Do NOT use sync migrations with async engine, do NOT skip autogenerate.
  </action>
  <verify>Alembic configured, `alembic revision --autogenerate` generates migration file</verify>
  <done>Alembic migrations configured with async support and initial schema migration</done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] All model files import without errors
- [ ] `uv run python -c "from codestory.models import User, Story, StoryIntent"` succeeds
- [ ] Alembic configuration complete
- [ ] Initial migration file generated
- [ ] All relationships properly defined (no circular import issues)
</verification>

<success_criteria>
- All database models match schema design
- Async SQLAlchemy properly configured
- Alembic migrations ready for deployment
- Models can be imported from main package
</success_criteria>

<o>
After completion, create `plans/01-foundation/01-02-SUMMARY.md`
</o>
