---
phase: 01-foundation
type: execute
domain: python-agent-sdk
---

<objective>
Implement the core agent framework with Skill, Agent, and Orchestrator base classes using Claude Agent SDK.

Purpose: Create the reusable infrastructure that all 4 agents (Intent, Analyzer, Architect, Voice) will extend.
Output: Working base classes with Opus 4.5 configuration, tool registration, and orchestration patterns.
</objective>


<context>
@BRIEF.md
@ROADMAP.md
@plans/01-foundation/01-01-SUMMARY.md
@plans/01-foundation/01-02-SUMMARY.md
</context>

<reasoning_guidance>
Thoroughly analyze the agent orchestration architecture before implementing.
Consider multiple approaches for skill composition:
- Decorator-based registration vs explicit registration
- Sync vs async handler patterns
- Tool parameter extraction from type hints vs manual schema

Deeply consider the trade-offs between:
- Flexibility (easy to add new skills) vs type safety
- Claude SDK conventions vs custom abstractions
- Single agent execution vs pipeline coordination

The Orchestrator pattern is critical - explore how agent handoffs should work,
what state needs to persist between stages, and how errors propagate through the pipeline.
</reasoning_guidance>

<tasks>

<task type="auto">
  <n>Task 1: Create Skill base class with tool registration</n>
  <files>src/codestory/agents/base.py</files>
  <action>
    Implement the Skill base class that wraps Python functions as Claude tools:
    
    ```python
    # src/codestory/agents/base.py
    """Base classes for the Code Story agent framework."""
    
    from abc import ABC, abstractmethod
    from dataclasses import dataclass, field
    from typing import Any, Callable, TypeVar, Generic
    from functools import wraps
    import json
    import inspect
    
    
    @dataclass
    class ToolDefinition:
        """Definition of a tool that can be used by Claude."""
        name: str
        description: str
        parameters: dict[str, Any]
        handler: Callable[..., Any]
    
    
    @dataclass
    class ToolResult:
        """Result from executing a tool."""
        success: bool
        data: Any = None
        error: str | None = None
    
    
    def skill(
        name: str | None = None,
        description: str | None = None,
    ) -> Callable:
        """Decorator to register a method as a skill/tool.
        
        Usage:
            @skill(description="Fetch repository structure from GitHub")
            async def fetch_repo_tree(self, repo_url: str) -> dict:
                ...
        """
        def decorator(func: Callable) -> Callable:
            # Extract parameter schema from type hints
            hints = func.__annotations__
            sig = inspect.signature(func)
            
            parameters = {
                "type": "object",
                "properties": {},
                "required": []
            }
            
            for param_name, param in sig.parameters.items():
                if param_name in ("self", "return"):
                    continue
                    
                param_type = hints.get(param_name, str)
                json_type = _python_type_to_json(param_type)
                
                parameters["properties"][param_name] = {
                    "type": json_type,
                    "description": f"Parameter: {param_name}"
                }
                
                if param.default is inspect.Parameter.empty:
                    parameters["required"].append(param_name)
            
            # Store metadata on function
            func._skill_meta = {
                "name": name or func.__name__,
                "description": description or func.__doc__ or "",
                "parameters": parameters,
            }
            
            @wraps(func)
            async def wrapper(*args, **kwargs):
                return await func(*args, **kwargs)
            
            wrapper._skill_meta = func._skill_meta
            return wrapper
        
        return decorator
    
    
    def _python_type_to_json(py_type: type) -> str:
        """Convert Python type hint to JSON schema type."""
        type_map = {
            str: "string",
            int: "integer",
            float: "number",
            bool: "boolean",
            list: "array",
            dict: "object",
        }
        # Handle Optional, Union, etc. by getting origin
        origin = getattr(py_type, "__origin__", None)
        if origin is not None:
            py_type = origin
        return type_map.get(py_type, "string")
    
    
    class Skill(ABC):
        """Base class for skill collections.
        
        Skills are groups of related tools that an agent can use.
        Each method decorated with @skill becomes a tool available to Claude.
        """
        
        def __init__(self):
            self._tools: dict[str, ToolDefinition] = {}
            self._register_tools()
        
        def _register_tools(self) -> None:
            """Automatically register all @skill decorated methods."""
            for name in dir(self):
                if name.startswith("_"):
                    continue
                method = getattr(self, name)
                if hasattr(method, "_skill_meta"):
                    meta = method._skill_meta
                    self._tools[meta["name"]] = ToolDefinition(
                        name=meta["name"],
                        description=meta["description"],
                        parameters=meta["parameters"],
                        handler=method,
                    )
        
        def get_tools(self) -> list[ToolDefinition]:
            """Return all registered tools."""
            return list(self._tools.values())
        
        async def execute(self, tool_name: str, **kwargs) -> ToolResult:
            """Execute a tool by name."""
            if tool_name not in self._tools:
                return ToolResult(success=False, error=f"Unknown tool: {tool_name}")
            
            try:
                tool = self._tools[tool_name]
                result = await tool.handler(**kwargs)
                return ToolResult(success=True, data=result)
            except Exception as e:
                return ToolResult(success=False, error=str(e))
    ```
    
    Avoid: Do NOT use synchronous handlers, do NOT skip parameter validation.
  </action>
  <verify>Skill class importable, @skill decorator works, tool registration succeeds</verify>
  <done>Skill base class with @skill decorator and automatic tool registration</done>
</task>

<task type="auto">
  <n>Task 2: Create Agent base class with Opus 4.5 configuration</n>
  <files>src/codestory/agents/base.py (continued)</files>
  <action>
    Add Agent base class to base.py:
    
    ```python
    # Continue in src/codestory/agents/base.py
    
    from anthropic import Anthropic
    import anthropic
    
    
    @dataclass
    class AgentConfig:
        """Configuration for an agent."""
        name: str
        description: str
        system_prompt: str
        model: str = "claude-opus-4-5-20251101"
        max_tokens: int = 8192
        temperature: float = 0.7
        effort: str = "high"  # Opus 4.5 effort parameter
    
    
    @dataclass
    class AgentMessage:
        """A message in an agent conversation."""
        role: str  # "user", "assistant", "system"
        content: str
        tool_calls: list[dict] | None = None
        tool_results: list[dict] | None = None
    
    
    @dataclass  
    class AgentResponse:
        """Response from an agent."""
        content: str
        tool_calls: list[dict] = field(default_factory=list)
        stop_reason: str | None = None
        usage: dict[str, int] = field(default_factory=dict)
    
    
    class Agent(ABC):
        """Base class for Claude-powered agents.
        
        Each agent has:
        - A system prompt defining its role
        - A set of skills (tools) it can use
        - Configuration for the Claude model
        """
        
        def __init__(
            self,
            config: AgentConfig,
            skills: list[Skill] | None = None,
            client: Anthropic | None = None,
        ):
            self.config = config
            self.skills = skills or []
            self.client = client or Anthropic()
            self.conversation: list[AgentMessage] = []
            
            # Collect all tools from skills
            self._all_tools: dict[str, ToolDefinition] = {}
            for skill in self.skills:
                for tool in skill.get_tools():
                    self._all_tools[tool.name] = tool
        
        def _format_tools_for_api(self) -> list[dict]:
            """Format tools for the Anthropic API."""
            return [
                {
                    "name": tool.name,
                    "description": tool.description,
                    "input_schema": tool.parameters,
                }
                for tool in self._all_tools.values()
            ]
        
        async def run(self, user_message: str) -> AgentResponse:
            """Run the agent with a user message.
            
            Handles the full conversation loop including tool calls.
            """
            self.conversation.append(AgentMessage(role="user", content=user_message))
            
            messages = [{"role": m.role, "content": m.content} for m in self.conversation]
            tools = self._format_tools_for_api() if self._all_tools else None
            
            # Create API request with Opus 4.5 configuration
            request_params = {
                "model": self.config.model,
                "max_tokens": self.config.max_tokens,
                "system": self.config.system_prompt,
                "messages": messages,
            }
            
            if tools:
                request_params["tools"] = tools
            
            # Add Opus 4.5 effort parameter via betas
            response = self.client.beta.messages.create(
                **request_params,
                betas=["effort-2025-11-24"],
                extra_body={"effort": self.config.effort},
            )
            
            # Process response
            content_text = ""
            tool_calls = []
            
            for block in response.content:
                if block.type == "text":
                    content_text += block.text
                elif block.type == "tool_use":
                    tool_calls.append({
                        "id": block.id,
                        "name": block.name,
                        "input": block.input,
                    })
            
            # If there are tool calls, execute them
            if tool_calls:
                tool_results = await self._execute_tools(tool_calls)
                
                # Add assistant response with tool calls
                self.conversation.append(AgentMessage(
                    role="assistant",
                    content=content_text,
                    tool_calls=tool_calls,
                ))
                
                # Continue conversation with tool results
                return await self._continue_with_tools(tool_results)
            
            # No tool calls - return final response
            self.conversation.append(AgentMessage(role="assistant", content=content_text))
            
            return AgentResponse(
                content=content_text,
                tool_calls=tool_calls,
                stop_reason=response.stop_reason,
                usage={
                    "input_tokens": response.usage.input_tokens,
                    "output_tokens": response.usage.output_tokens,
                },
            )
        
        async def _execute_tools(self, tool_calls: list[dict]) -> list[dict]:
            """Execute tool calls and return results."""
            results = []
            for call in tool_calls:
                tool_name = call["name"]
                tool_input = call["input"]
                
                if tool_name in self._all_tools:
                    tool = self._all_tools[tool_name]
                    try:
                        result = await tool.handler(**tool_input)
                        results.append({
                            "type": "tool_result",
                            "tool_use_id": call["id"],
                            "content": json.dumps(result) if not isinstance(result, str) else result,
                        })
                    except Exception as e:
                        results.append({
                            "type": "tool_result",
                            "tool_use_id": call["id"],
                            "content": f"Error: {str(e)}",
                            "is_error": True,
                        })
                else:
                    results.append({
                        "type": "tool_result",
                        "tool_use_id": call["id"],
                        "content": f"Unknown tool: {tool_name}",
                        "is_error": True,
                    })
            
            return results
        
        async def _continue_with_tools(self, tool_results: list[dict]) -> AgentResponse:
            """Continue conversation after tool execution."""
            # Build messages including tool results
            messages = []
            for m in self.conversation:
                if m.tool_calls:
                    # Message with tool use
                    content = []
                    if m.content:
                        content.append({"type": "text", "text": m.content})
                    for tc in m.tool_calls:
                        content.append({
                            "type": "tool_use",
                            "id": tc["id"],
                            "name": tc["name"],
                            "input": tc["input"],
                        })
                    messages.append({"role": m.role, "content": content})
                else:
                    messages.append({"role": m.role, "content": m.content})
            
            # Add tool results as user message
            messages.append({"role": "user", "content": tool_results})
            
            # Make follow-up request
            response = self.client.beta.messages.create(
                model=self.config.model,
                max_tokens=self.config.max_tokens,
                system=self.config.system_prompt,
                messages=messages,
                tools=self._format_tools_for_api() if self._all_tools else None,
                betas=["effort-2025-11-24"],
                extra_body={"effort": self.config.effort},
            )
            
            # Process response (may have more tool calls)
            content_text = ""
            new_tool_calls = []
            
            for block in response.content:
                if block.type == "text":
                    content_text += block.text
                elif block.type == "tool_use":
                    new_tool_calls.append({
                        "id": block.id,
                        "name": block.name,
                        "input": block.input,
                    })
            
            if new_tool_calls:
                # Recursive tool execution
                self.conversation.append(AgentMessage(
                    role="assistant",
                    content=content_text,
                    tool_calls=new_tool_calls,
                ))
                new_results = await self._execute_tools(new_tool_calls)
                return await self._continue_with_tools(new_results)
            
            # Final response
            self.conversation.append(AgentMessage(role="assistant", content=content_text))
            
            return AgentResponse(
                content=content_text,
                stop_reason=response.stop_reason,
                usage={
                    "input_tokens": response.usage.input_tokens,
                    "output_tokens": response.usage.output_tokens,
                },
            )
        
        def clear_conversation(self) -> None:
            """Clear the conversation history."""
            self.conversation = []
    ```
    
    Avoid: Do NOT use deprecated API patterns, do NOT skip error handling for tool calls.
  </action>
  <verify>Agent class creates successfully, API integration patterns correct</verify>
  <done>Agent base class with Opus 4.5 configuration, tool execution, and conversation management</done>
</task>

<task type="auto">
  <n>Task 3: Create Orchestrator for multi-agent coordination</n>
  <files>src/codestory/agents/base.py (continued), src/codestory/agents/__init__.py</files>
  <action>
    Add Orchestrator class and update exports:
    
    ```python
    # Continue in src/codestory/agents/base.py
    
    from enum import Enum
    
    
    class PipelineStage(str, Enum):
        """Stages in the story generation pipeline."""
        INTENT = "intent"
        ANALYSIS = "analysis"
        NARRATIVE = "narrative"
        SYNTHESIS = "synthesis"
        COMPLETE = "complete"
        FAILED = "failed"
    
    
    @dataclass
    class PipelineState:
        """State of the story generation pipeline."""
        stage: PipelineStage
        intent_result: dict | None = None
        analysis_result: dict | None = None
        narrative_result: dict | None = None
        synthesis_result: dict | None = None
        error: str | None = None
    
    
    class Orchestrator:
        """Orchestrates the 4-agent pipeline for story generation.
        
        Pipeline flow:
        1. Intent Agent - Understand user's learning goals
        2. Repo Analyzer - Analyze the codebase
        3. Story Architect - Generate narrative script
        4. Voice Director - Synthesize audio
        """
        
        def __init__(
            self,
            intent_agent: Agent | None = None,
            analyzer_agent: Agent | None = None,
            architect_agent: Agent | None = None,
            voice_agent: Agent | None = None,
        ):
            self.intent_agent = intent_agent
            self.analyzer_agent = analyzer_agent
            self.architect_agent = architect_agent
            self.voice_agent = voice_agent
            self.state = PipelineState(stage=PipelineStage.INTENT)
        
        async def run_pipeline(
            self,
            repo_url: str,
            user_intent: str,
            narrative_style: str = "documentary",
            on_progress: Callable[[PipelineStage, str], None] | None = None,
        ) -> PipelineState:
            """Run the full story generation pipeline.
            
            Args:
                repo_url: GitHub repository URL
                user_intent: User's learning goals/intent
                narrative_style: Style of narrative (fiction, documentary, etc.)
                on_progress: Optional callback for progress updates
            
            Returns:
                Final pipeline state with all results
            """
            try:
                # Stage 1: Intent Analysis
                self.state.stage = PipelineStage.INTENT
                if on_progress:
                    on_progress(PipelineStage.INTENT, "Understanding your learning goals...")
                
                if self.intent_agent:
                    intent_response = await self.intent_agent.run(
                        f"Repository: {repo_url}\nUser's learning goals: {user_intent}"
                    )
                    self.state.intent_result = {
                        "content": intent_response.content,
                        "usage": intent_response.usage,
                    }
                
                # Stage 2: Repository Analysis
                self.state.stage = PipelineStage.ANALYSIS
                if on_progress:
                    on_progress(PipelineStage.ANALYSIS, "Analyzing the codebase...")
                
                if self.analyzer_agent:
                    analysis_prompt = f"Analyze repository: {repo_url}"
                    if self.state.intent_result:
                        analysis_prompt += f"\nFocus areas from intent: {self.state.intent_result['content']}"
                    
                    analysis_response = await self.analyzer_agent.run(analysis_prompt)
                    self.state.analysis_result = {
                        "content": analysis_response.content,
                        "usage": analysis_response.usage,
                    }
                
                # Stage 3: Narrative Generation
                self.state.stage = PipelineStage.NARRATIVE
                if on_progress:
                    on_progress(PipelineStage.NARRATIVE, "Crafting your story...")
                
                if self.architect_agent:
                    narrative_prompt = f"Generate {narrative_style} narrative for repository analysis."
                    if self.state.analysis_result:
                        narrative_prompt += f"\nAnalysis: {self.state.analysis_result['content']}"
                    if self.state.intent_result:
                        narrative_prompt += f"\nIntent: {self.state.intent_result['content']}"
                    
                    narrative_response = await self.architect_agent.run(narrative_prompt)
                    self.state.narrative_result = {
                        "content": narrative_response.content,
                        "usage": narrative_response.usage,
                    }
                
                # Stage 4: Voice Synthesis
                self.state.stage = PipelineStage.SYNTHESIS
                if on_progress:
                    on_progress(PipelineStage.SYNTHESIS, "Generating audio...")
                
                if self.voice_agent and self.state.narrative_result:
                    synthesis_response = await self.voice_agent.run(
                        f"Synthesize audio for script: {self.state.narrative_result['content']}"
                    )
                    self.state.synthesis_result = {
                        "content": synthesis_response.content,
                        "usage": synthesis_response.usage,
                    }
                
                # Complete
                self.state.stage = PipelineStage.COMPLETE
                if on_progress:
                    on_progress(PipelineStage.COMPLETE, "Story complete!")
                
            except Exception as e:
                self.state.stage = PipelineStage.FAILED
                self.state.error = str(e)
                if on_progress:
                    on_progress(PipelineStage.FAILED, f"Error: {str(e)}")
            
            return self.state
        
        def get_state(self) -> PipelineState:
            """Get current pipeline state."""
            return self.state
        
        def reset(self) -> None:
            """Reset pipeline state."""
            self.state = PipelineState(stage=PipelineStage.INTENT)
    ```
    
    Update `src/codestory/agents/__init__.py`:
    ```python
    """Agent framework for Code Story."""
    from .base import (
        Skill,
        skill,
        ToolDefinition,
        ToolResult,
        Agent,
        AgentConfig,
        AgentMessage,
        AgentResponse,
        Orchestrator,
        PipelineStage,
        PipelineState,
    )
    
    __all__ = [
        "Skill",
        "skill",
        "ToolDefinition",
        "ToolResult",
        "Agent",
        "AgentConfig",
        "AgentMessage",
        "AgentResponse",
        "Orchestrator",
        "PipelineStage",
        "PipelineState",
    ]
    ```
    
    Avoid: Do NOT skip progress callbacks, do NOT ignore pipeline state transitions.
  </action>
  <verify>All classes import correctly, pipeline stages defined, orchestrator instantiates</verify>
  <done>Orchestrator class for 4-agent pipeline coordination with progress callbacks</done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] `uv run python -c "from codestory.agents import Agent, Skill, Orchestrator"` succeeds
- [ ] @skill decorator registers tools correctly
- [ ] Agent class configures Opus 4.5 with effort parameter
- [ ] Orchestrator handles all 4 pipeline stages
- [ ] All type hints and dataclasses work correctly
</verification>

<success_criteria>
- Skill base class with @skill decorator working
- Agent base class with Opus 4.5 integration
- Orchestrator managing multi-agent pipeline
- All classes properly typed and documented
</success_criteria>

<o>
After completion, create `plans/01-foundation/01-03-SUMMARY.md`
</o>
