---
phase: 05-voice-director
plan: 03
type: execute
domain: python-api
---

<objective>
Implement script preparation utilities that handle text chunking, voice marker processing, and API limit management for ElevenLabs synthesis.
</objective>

<context>
@BRIEF.md
@codestory/backend/voice/elevenlabs.py
@codestory/backend/skills/voice/synthesis.py
</context>

<tasks>

<task type="auto">
  <n>Task 1: Create script preparation utilities</n>
  <files>codestory/backend/skills/voice/preparation.py</files>
  <action>
Create script preparation module:

```python
"""Script preparation for voice synthesis."""

import re
from dataclasses import dataclass
from typing import Any

from backend.skills.decorators import skill, handle_skill_errors


# ElevenLabs limits
MAX_CHARS_PER_REQUEST = 5000  # ElevenLabs limit
OPTIMAL_CHUNK_SIZE = 2500     # Optimal for quality
MIN_CHUNK_SIZE = 100          # Minimum viable chunk


@dataclass
class TextChunk:
    """A chunk of text for synthesis."""
    
    text: str
    chunk_index: int
    original_segment_index: int
    is_continuation: bool
    pause_before_seconds: float = 0


@dataclass
class PreparedSegment:
    """A segment prepared for synthesis."""
    
    original_index: int
    segment_type: str
    chapter_number: int | None
    chunks: list[TextChunk]
    total_characters: int
    voice_settings: dict[str, Any]


# Voice direction marker patterns
PAUSE_PATTERN = re.compile(r'\[PAUSE\s+(\d+(?:\.\d+)?)\s*s?\]', re.IGNORECASE)
EMPHASIS_PATTERN = re.compile(r'\[EMPHASIS\s+([^\]]+)\]', re.IGNORECASE)
SLOW_PATTERN = re.compile(r'\[SLOW\](.*?)\[/SLOW\]', re.IGNORECASE | re.DOTALL)
CODE_PATTERN = re.compile(r'\[CODE\](.*?)\[/CODE\]', re.IGNORECASE | re.DOTALL)


def _extract_pauses(text: str) -> tuple[str, list[tuple[int, float]]]:
    """
    Extract pause markers and their positions.
    
    Returns:
        Tuple of (cleaned text, list of (position, duration) tuples)
    """
    pauses = []
    offset = 0
    
    for match in PAUSE_PATTERN.finditer(text):
        duration = float(match.group(1))
        position = match.start() - offset
        pauses.append((position, duration))
        offset += len(match.group(0))
    
    cleaned = PAUSE_PATTERN.sub('', text)
    return cleaned, pauses


def _process_emphasis(text: str) -> str:
    """Process emphasis markers for natural speech."""
    # Convert [EMPHASIS word] to *word* (SSML-like, ElevenLabs interprets naturally)
    return EMPHASIS_PATTERN.sub(r'\1', text)


def _process_code_blocks(text: str) -> str:
    """Process code blocks for pronunciation."""
    def format_code(match):
        code = match.group(1).strip()
        # Add spaces around operators and punctuation for clearer reading
        code = re.sub(r'([._\-])', r' \1 ', code)
        # Spell out common programming terms
        replacements = {
            '==': ' equals equals ',
            '!=': ' not equals ',
            '>=': ' greater than or equal ',
            '<=': ' less than or equal ',
            '->': ' arrow ',
            '=>': ' fat arrow ',
            '::': ' colon colon ',
            '()': ' parentheses ',
            '[]': ' brackets ',
            '{}': ' braces ',
        }
        for old, new in replacements.items():
            code = code.replace(old, new)
        return code
    
    return CODE_PATTERN.sub(format_code, text)


def _process_slow_sections(text: str) -> str:
    """Process slow sections (markers kept for voice settings adjustment)."""
    # Remove markers but note sections for potential settings adjustment
    return SLOW_PATTERN.sub(r'\1', text)


def _find_sentence_boundary(text: str, max_pos: int) -> int:
    """Find the best sentence boundary before max_pos."""
    # Look for sentence endings
    sentence_endings = ['. ', '! ', '? ', '.\n', '!\n', '?\n']
    best_pos = -1
    
    search_text = text[:max_pos]
    for ending in sentence_endings:
        pos = search_text.rfind(ending)
        if pos > best_pos:
            best_pos = pos + len(ending)
    
    # If no sentence boundary, look for clause boundaries
    if best_pos < MIN_CHUNK_SIZE:
        clause_endings = [', ', '; ', ': ', ' - ', '\n']
        for ending in clause_endings:
            pos = search_text.rfind(ending)
            if pos > best_pos:
                best_pos = pos + len(ending)
    
    # Last resort: find word boundary
    if best_pos < MIN_CHUNK_SIZE:
        pos = search_text.rfind(' ')
        if pos > 0:
            best_pos = pos + 1
    
    return best_pos if best_pos > 0 else max_pos


def _chunk_text(
    text: str,
    max_size: int = OPTIMAL_CHUNK_SIZE,
) -> list[str]:
    """
    Split text into chunks at natural boundaries.
    
    Args:
        text: Text to chunk
        max_size: Maximum characters per chunk
    
    Returns:
        List of text chunks
    """
    if len(text) <= max_size:
        return [text]
    
    chunks = []
    remaining = text
    
    while remaining:
        if len(remaining) <= max_size:
            chunks.append(remaining)
            break
        
        # Find best split point
        split_pos = _find_sentence_boundary(remaining, max_size)
        
        chunk = remaining[:split_pos].strip()
        if chunk:
            chunks.append(chunk)
        
        remaining = remaining[split_pos:].strip()
    
    return chunks


@skill(
    name="prepare_segment",
    description="Prepare a script segment for synthesis",
)
@handle_skill_errors
async def prepare_segment(
    text: str,
    segment_type: str = "chapter",
    segment_index: int = 0,
    chapter_number: int | None = None,
    voice_settings: dict[str, Any] | None = None,
) -> dict[str, Any]:
    """
    Prepare a script segment for synthesis.
    
    Processes voice markers and chunks text for API limits.
    
    Args:
        text: Raw segment text with markers
        segment_type: Type of segment
        segment_index: Index in the script
        chapter_number: Chapter number if applicable
        voice_settings: Voice synthesis settings
    
    Returns:
        Prepared segment with chunks
    """
    # Process voice markers
    processed = _process_emphasis(text)
    processed = _process_code_blocks(processed)
    processed = _process_slow_sections(processed)
    
    # Extract pauses (stored separately)
    cleaned, pauses = _extract_pauses(processed)
    
    # Chunk the text
    text_chunks = _chunk_text(cleaned)
    
    # Create chunk objects
    chunks = []
    for i, chunk_text in enumerate(text_chunks):
        # Check if any pause falls at the start of this chunk
        pause_before = 0
        if pauses:
            char_pos = sum(len(c) for c in text_chunks[:i])
            for pos, duration in pauses:
                if abs(pos - char_pos) < 10:  # Near chunk boundary
                    pause_before = duration
                    break
        
        chunks.append({
            "text": chunk_text,
            "chunk_index": i,
            "original_segment_index": segment_index,
            "is_continuation": i > 0,
            "pause_before_seconds": pause_before,
        })
    
    return {
        "original_index": segment_index,
        "segment_type": segment_type,
        "chapter_number": chapter_number,
        "chunks": chunks,
        "total_characters": len(cleaned),
        "chunk_count": len(chunks),
        "voice_settings": voice_settings or {},
        "pauses": [{"position": p, "duration": d} for p, d in pauses],
    }


@skill(
    name="prepare_script",
    description="Prepare an entire script for synthesis",
)
@handle_skill_errors
async def prepare_script(
    segments: list[dict[str, Any]],
) -> dict[str, Any]:
    """
    Prepare all segments of a script for synthesis.
    
    Args:
        segments: List of script segments
    
    Returns:
        Fully prepared script with all chunks
    """
    prepared_segments = []
    total_chunks = 0
    total_characters = 0
    
    for i, segment in enumerate(segments):
        prepared = await prepare_segment(
            text=segment.get("content", segment.get("text", "")),
            segment_type=segment.get("segment_type", "chapter"),
            segment_index=i,
            chapter_number=segment.get("chapter_number"),
            voice_settings=segment.get("voice_direction", segment.get("voice_settings", {})),
        )
        
        prepared_segments.append(prepared)
        total_chunks += prepared["chunk_count"]
        total_characters += prepared["total_characters"]
    
    return {
        "segments": prepared_segments,
        "total_segments": len(prepared_segments),
        "total_chunks": total_chunks,
        "total_characters": total_characters,
        "estimated_api_calls": total_chunks,
    }


@skill(
    name="validate_for_synthesis",
    description="Validate script is ready for synthesis",
)
@handle_skill_errors
async def validate_for_synthesis(
    prepared_script: dict[str, Any],
) -> dict[str, Any]:
    """
    Validate a prepared script before synthesis.
    
    Args:
        prepared_script: Output from prepare_script
    
    Returns:
        Validation results with any issues
    """
    issues = []
    warnings = []
    
    segments = prepared_script.get("segments", [])
    
    for seg in segments:
        for chunk in seg.get("chunks", []):
            text = chunk.get("text", "")
            
            # Check chunk size
            if len(text) > MAX_CHARS_PER_REQUEST:
                issues.append(f"Chunk {chunk['chunk_index']} in segment {seg['original_index']} exceeds API limit")
            
            # Check for empty chunks
            if len(text.strip()) < 10:
                warnings.append(f"Very short chunk in segment {seg['original_index']}")
            
            # Check for unprocessed markers
            if re.search(r'\[(?:PAUSE|EMPHASIS|SLOW|CODE)', text):
                warnings.append(f"Unprocessed marker in segment {seg['original_index']}")
    
    return {
        "valid": len(issues) == 0,
        "issues": issues,
        "warnings": warnings,
        "total_chunks": prepared_script.get("total_chunks", 0),
        "total_characters": prepared_script.get("total_characters", 0),
    }
```
  </action>
  <verify>python -c "from codestory.backend.skills.voice.preparation import prepare_script; print('Preparation OK')"</verify>
  <done>Script preparation skill created</done>
</task>

</tasks>

<playwright_validation_gate>
```
# Script preparation validation
script_text = "[PAUSE 2s] Welcome to Code Story. [EMPHASIS important] Let's begin."
prepared = await prepare_segment(script_text, "intro", 0)

Assert: prepared["chunk_count"] >= 1
Assert: len(prepared["pauses"]) == 1
Assert: prepared["total_characters"] > 0
```
</playwright_validation_gate>
