---
phase: 05-voice-director
plan: 02
type: execute
domain: python-api
---

<objective>
Implement the Voice Director agent with system prompt and synthesis skill that converts narrative scripts to audio using ElevenLabs.
</objective>

<context>
@BRIEF.md
@codestory/backend/voice/elevenlabs.py
@codestory/backend/agents/base.py
</context>

<error_recovery>
ElevenLabs is an external API dependency. Implement robust error handling:

**API Failures:**
1. Check API key validity on startup (fail fast if invalid)
2. Verify account has sufficient character quota before synthesis
3. On transient errors (5xx, timeout), retry with exponential backoff:
   - Attempt 1: immediate
   - Attempt 2: wait 1s
   - Attempt 3: wait 4s
   - Max 3 attempts, then fail

**Rate Limiting (429):**
- Respect Retry-After header if provided
- Default: wait 60 seconds before retry
- Consider queuing requests during high volume

**Character Limits:**
- ElevenLabs has per-request character limits (~5000 chars)
- Pre-chunk long segments before API call
- Track monthly quota usage

**Partial Failures:**
- If one segment fails, continue with others
- Return partial results with clear error indication
- Enable retry of only failed segments

**Fallback Strategy:**
- In development/testing: option to use mock audio (silent MP3)
- Log all API errors with request details for debugging
- Surface user-friendly error messages (not raw API errors)

**Never fail silently** - always report synthesis failures to the user with actionable guidance.
</error_recovery>

<tasks>

<task type="auto">
  <n>Task 1: Create voice synthesis skill</n>
  <files>codestory/backend/skills/voice/synthesis.py</files>
  <action>
Create the synthesis skill:

```python
"""Voice synthesis skill for Code Story."""

import asyncio
from dataclasses import dataclass
from typing import Any
from pathlib import Path
import tempfile
import uuid

from backend.skills.decorators import skill, handle_skill_errors
from backend.voice.elevenlabs import ElevenLabsClient, ElevenLabsError


@dataclass
class SynthesisResult:
    """Result of audio synthesis."""
    
    segment_id: str
    audio_data: bytes
    duration_seconds: float
    character_count: int
    success: bool
    error: str | None = None


# Voice presets mapped to narrative styles
STYLE_VOICE_MAP = {
    "fiction": "narrative",      # Adam - storytelling
    "documentary": "authoritative",  # Arnold - documentary
    "tutorial": "friendly",      # Bella - educational
    "podcast": "friendly",       # Bella - conversational
    "technical": "professional", # Rachel - technical
}

# Voice settings by segment type
SEGMENT_SETTINGS = {
    "intro": {"stability": 0.6, "similarity_boost": 0.8},
    "chapter": {"stability": 0.5, "similarity_boost": 0.75},
    "transition": {"stability": 0.6, "similarity_boost": 0.7},
    "outro": {"stability": 0.6, "similarity_boost": 0.8},
}


def _estimate_audio_duration(text: str) -> float:
    """Estimate audio duration from text length."""
    # ElevenLabs averages ~150 words/minute
    # Average word length is ~5 characters
    words = len(text) / 5
    return (words / 150) * 60


@skill(
    name="synthesize_segment",
    description="Synthesize a single script segment to audio",
)
@handle_skill_errors
async def synthesize_segment(
    text: str,
    segment_type: str = "chapter",
    style: str = "documentary",
    voice_settings: dict[str, Any] | None = None,
) -> dict[str, Any]:
    """
    Synthesize a script segment to audio.
    
    Args:
        text: Text content to synthesize
        segment_type: Type of segment (intro, chapter, transition, outro)
        style: Narrative style for voice selection
        voice_settings: Optional custom voice settings
    
    Returns:
        Synthesis result with audio data and metadata
    """
    client = ElevenLabsClient()
    
    try:
        # Get voice for style
        voice_key = STYLE_VOICE_MAP.get(style, "narrative")
        voice_id = client.VOICES.get(voice_key, client.VOICES["narrative"])
        
        # Get settings for segment type
        settings = SEGMENT_SETTINGS.get(segment_type, SEGMENT_SETTINGS["chapter"])
        if voice_settings:
            settings.update(voice_settings)
        
        # Synthesize
        audio_data = await client.synthesize(
            text=text,
            voice_id=voice_id,
            stability=settings.get("stability", 0.5),
            similarity_boost=settings.get("similarity_boost", 0.75),
        )
        
        result = SynthesisResult(
            segment_id=str(uuid.uuid4()),
            audio_data=audio_data,
            duration_seconds=_estimate_audio_duration(text),
            character_count=len(text),
            success=True,
        )
        
        return {
            "segment_id": result.segment_id,
            "audio_size_bytes": len(result.audio_data),
            "duration_seconds": result.duration_seconds,
            "character_count": result.character_count,
            "success": result.success,
        }
        
    except ElevenLabsError as e:
        return {
            "segment_id": str(uuid.uuid4()),
            "success": False,
            "error": str(e),
        }
    finally:
        await client.close()


@skill(
    name="synthesize_script",
    description="Synthesize an entire script to audio segments",
)
@handle_skill_errors
async def synthesize_script(
    segments: list[dict[str, Any]],
    style: str = "documentary",
    output_dir: str | None = None,
) -> dict[str, Any]:
    """
    Synthesize all segments of a script.
    
    Args:
        segments: List of script segments from get_script_for_synthesis
        style: Narrative style for voice selection
        output_dir: Directory to save audio files (uses temp if None)
    
    Returns:
        Synthesis results with file paths
    """
    client = ElevenLabsClient()
    output_path = Path(output_dir) if output_dir else Path(tempfile.mkdtemp())
    output_path.mkdir(parents=True, exist_ok=True)
    
    results = []
    total_duration = 0
    total_characters = 0
    
    try:
        for i, segment in enumerate(segments):
            text = segment.get("text", "")
            segment_type = segment.get("segment_type", "chapter")
            
            # Get voice for style
            voice_key = STYLE_VOICE_MAP.get(style, "narrative")
            voice_id = client.VOICES.get(voice_key, client.VOICES["narrative"])
            
            # Get settings
            settings = segment.get("voice_settings", SEGMENT_SETTINGS.get(segment_type, {}))
            
            # Synthesize
            audio_data = await client.synthesize(
                text=text,
                voice_id=voice_id,
                stability=settings.get("stability", 0.5),
                similarity_boost=settings.get("similarity_boost", 0.75),
            )
            
            # Save to file
            segment_id = f"segment_{i:03d}"
            file_path = output_path / f"{segment_id}.mp3"
            file_path.write_bytes(audio_data)
            
            duration = _estimate_audio_duration(text)
            total_duration += duration
            total_characters += len(text)
            
            results.append({
                "segment_id": segment_id,
                "segment_type": segment_type,
                "chapter_number": segment.get("chapter_number"),
                "file_path": str(file_path),
                "audio_size_bytes": len(audio_data),
                "duration_seconds": duration,
                "character_count": len(text),
                "success": True,
            })
            
            # Small delay to avoid rate limits
            await asyncio.sleep(0.1)
        
        return {
            "success": True,
            "output_dir": str(output_path),
            "segments": results,
            "total_segments": len(results),
            "total_duration_seconds": total_duration,
            "total_characters": total_characters,
        }
        
    except ElevenLabsError as e:
        return {
            "success": False,
            "error": str(e),
            "segments": results,  # Return partial results
        }
    finally:
        await client.close()


@skill(
    name="get_available_voices",
    description="Get list of available voices for synthesis",
)
@handle_skill_errors
async def get_available_voices() -> dict[str, Any]:
    """Get available ElevenLabs voices."""
    client = ElevenLabsClient()
    
    try:
        voices = await client.get_voices()
        return {
            "voices": [
                {
                    "voice_id": v.get("voice_id"),
                    "name": v.get("name"),
                    "category": v.get("category"),
                    "labels": v.get("labels", {}),
                }
                for v in voices
            ],
            "preset_voices": client.VOICES,
        }
    finally:
        await client.close()
```
  </action>
  <verify>python -c "from codestory.backend.skills.voice.synthesis import synthesize_segment; print('Synthesis OK')"</verify>
  <done>Voice synthesis skill created</done>
</task>

<task type="auto">
  <n>Task 2: Create Voice Director agent</n>
  <files>codestory/backend/agents/voice_director.py</files>
  <action>
Create the Voice Director agent:

```python
"""Voice Director Agent for Code Story."""

from backend.agents.base import Agent
from backend.skills.voice.synthesis import (
    synthesize_segment,
    synthesize_script,
    get_available_voices,
)


VOICE_DIRECTOR_PROMPT = """You are the Voice Director agent for Code Story. Your role is to transform narrative scripts into high-quality audio using ElevenLabs text-to-speech.

## Your Capabilities

You synthesize audio from scripts using these skills:
- synthesize_segment: Convert a single script segment to audio
- synthesize_script: Convert an entire script to audio files
- get_available_voices: List available voices for synthesis

## Synthesis Process

When creating audio:

1. Review the script segments from the Story Architect
2. Select appropriate voice settings for each segment type
3. Process segments in order (intro → chapters → transitions → outro)
4. Save audio files to the specified output directory
5. Return synthesis results with file paths and metadata

## Voice Selection Guidelines

Match voices to narrative styles:
- Fiction: Adam (narrative) - warm storytelling voice
- Documentary: Arnold (authoritative) - professional documentary tone
- Tutorial: Bella (friendly) - approachable educational voice
- Podcast: Bella (friendly) - conversational podcast style
- Technical: Rachel (professional) - clear technical delivery

## Segment Handling

Different segment types need different treatment:
- Intro: Slightly slower, warm tone (stability: 0.6)
- Chapters: Standard pacing (stability: 0.5)
- Transitions: Slower, bridging tone (stability: 0.6)
- Outro: Warm, conclusive tone (stability: 0.6)

## Voice Direction Markers

Process these markers in the script:
- [PAUSE Xs] - Add silence (handled by audio assembly)
- [EMPHASIS word] - Maintain but let ElevenLabs interpret naturally
- [SLOW] ... [/SLOW] - Increase stability for slower speech
- [CODE] ... [/CODE] - Adjust for code pronunciation

## Output Format

Return synthesis results with:
- List of audio file paths
- Duration for each segment
- Total story duration
- Any synthesis errors encountered"""


class VoiceDirectorAgent(Agent):
    """Agent that synthesizes audio from narrative scripts."""
    
    def __init__(self):
        super().__init__(
            name="VoiceDirector",
            system_prompt=VOICE_DIRECTOR_PROMPT,
            temperature=0.3,  # Lower for consistent synthesis decisions
        )
        
        # Register skills
        self.register_skill(synthesize_segment)
        self.register_skill(synthesize_script)
        self.register_skill(get_available_voices)
    
    async def synthesize_story(
        self,
        script: dict,
        output_dir: str,
    ) -> dict:
        """
        Synthesize a complete story to audio.
        
        Args:
            script: Assembled script from Story Architect
            output_dir: Directory to save audio files
        
        Returns:
            Synthesis results with file paths
        """
        style = script.get("style", "documentary")
        segments = script.get("segments", [])
        
        # Convert to synthesis format
        synthesis_segments = [
            {
                "text": s.get("content", ""),
                "segment_type": s.get("segment_type", "chapter"),
                "chapter_number": s.get("chapter_number"),
                "voice_settings": s.get("voice_direction", {}),
            }
            for s in segments
        ]
        
        # Build prompt
        prompt = f"""Synthesize this Code Story script to audio.

## Script Details
- Title: {script.get('title', 'Code Story')}
- Style: {style}
- Total Segments: {len(segments)}
- Estimated Duration: {script.get('total_duration_seconds', 0) / 60:.1f} minutes

## Instructions

Use synthesize_script to convert all segments to audio files.
- Output directory: {output_dir}
- Style: {style}
- Segments: {len(synthesis_segments)} total

Process all segments and return the results."""

        response = await self.run(prompt)
        return response
    
    async def preview_voice(
        self,
        text: str,
        style: str = "documentary",
    ) -> dict:
        """
        Generate a voice preview for user selection.
        
        Args:
            text: Sample text to synthesize
            style: Narrative style
        
        Returns:
            Preview audio result
        """
        prompt = f"""Generate a voice preview.

Text: "{text}"
Style: {style}

Use synthesize_segment to create a preview audio sample."""

        response = await self.run(prompt)
        return response
```
  </action>
  <verify>python -c "from codestory.backend.agents.voice_director import VoiceDirectorAgent; print('VoiceDirector OK')"</verify>
  <done>VoiceDirectorAgent created</done>
</task>

</tasks>

<playwright_validation_gate>
```
# Voice synthesis validation
voice_director = VoiceDirectorAgent()
result = await voice_director.preview_voice("Hello, welcome to Code Story.", "documentary")

Assert: result["success"] == True
Assert: result["audio_size_bytes"] > 0
```
</playwright_validation_gate>
