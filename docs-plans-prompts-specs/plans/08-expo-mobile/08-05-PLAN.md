---
phase: 08-expo-mobile
plan: 05
type: execute
domain: react-native
---

<objective>
Implement audio player with background playback, chapter navigation, and playback controls using expo-av.
</objective>

<context>
@BRIEF.md
@plans/08-expo-mobile/08-04-PLAN.md
</context>

<reasoning_guidance>
Mobile audio playback is significantly more complex than web. Thoroughly analyze platform differences:

**iOS vs Android Differences:**
- Background audio: iOS requires specific plist entries, Android needs foreground service
- Lock screen controls: Different APIs and capabilities
- Audio focus: Android's AudioFocus system vs iOS interruption handling
- Notification controls: Android notification channels vs iOS Now Playing

**expo-av Considerations:**
- Audio mode configuration (playsInSilentModeIOS, staysActiveInBackground)
- Interruption handling (phone calls, other apps)
- Audio session categories (playback, ambient, etc.)
- Rate limiting on status updates (avoid excessive re-renders)

**Background Playback Challenges:**
- App lifecycle: what happens when app is backgrounded?
- Memory management: sound objects need proper cleanup
- Network interruptions during streaming
- Resumption after interruption

**State Management Complexity:**
- Current position syncing without excessive updates
- Chapter transitions during background playback
- Seek precision across chapter boundaries
- Handling rapid seek requests

**Offline Considerations:**
- Downloaded audio storage and retrieval
- Partial downloads and resumption
- Cache management and cleanup

Consider using expo-av's Audio.setAudioModeAsync carefully - incorrect configuration is the #1 cause of background playback issues.
</reasoning_guidance>

<error_recovery>
Mobile audio has many failure modes. Implement comprehensive handling:

**Audio Loading Failures:**
1. Check network connectivity before loading
2. Retry with exponential backoff (3 attempts)
3. Show clear error state with retry button
4. Support offline playback if audio was cached

**Playback Interruptions:**
- Phone call: pause, resume when call ends
- Other app audio: respect audio focus rules
- Bluetooth disconnect: pause playback
- Headphone removal: pause (iOS default, Android needs handling)

**Background Playback Issues:**
- If background playback stops unexpectedly, log diagnostics
- Provide troubleshooting guidance to user
- Test on real devices (simulators don't fully support background audio)

**Memory Pressure:**
- Unload audio when navigating away
- Release sound objects properly in cleanup
- Handle low memory warnings gracefully

**Network Errors During Streaming:**
- Buffer status monitoring
- Automatic retry on recoverable errors
- Clear "buffering" state to user
- Fallback to lower quality if available

**Recovery Actions:**
- Store playback position for resume after crash
- Sync position to backend for cross-device continuity
- Handle corrupted/incomplete audio files gracefully
</error_recovery>

<sub_agent_hint>
Mobile background audio is complex enough to warrant a dedicated sub-agent:
- Platform-specific code requires focused attention
- Testing requires real device verification
- Can iterate on audio configuration independently
- Parallel development while other mobile screens continue

Sub-agent should focus on:
1. expo-av configuration for background playback
2. Lock screen / notification controls
3. Interruption handling
4. Chapter transition logic
</sub_agent_hint>

<tasks>

<task type="auto">
  <n>Task 1: Create audio player hook with expo-av</n>
  <files>codestory/mobile/hooks/useAudioPlayer.ts</files>
  <action>
Create hooks/useAudioPlayer.ts:

```typescript
import { useState, useEffect, useRef, useCallback } from 'react'
import { Audio, AVPlaybackStatus } from 'expo-av'

interface Chapter {
  id: string
  title: string
  audio_url: string
  duration_seconds: number
  order: number
}

interface UseAudioPlayerOptions {
  chapters: Chapter[]
  onChapterChange?: (index: number) => void
}

export function useAudioPlayer({ chapters, onChapterChange }: UseAudioPlayerOptions) {
  const soundRef = useRef<Audio.Sound | null>(null)
  const [isPlaying, setIsPlaying] = useState(false)
  const [isLoading, setIsLoading] = useState(false)
  const [currentChapterIndex, setCurrentChapterIndex] = useState(0)
  const [position, setPosition] = useState(0)
  const [duration, setDuration] = useState(0)
  const [playbackRate, setPlaybackRate] = useState(1.0)

  // Configure audio mode for background playback
  useEffect(() => {
    async function configureAudio() {
      await Audio.setAudioModeAsync({
        allowsRecordingIOS: false,
        staysActiveInBackground: true,
        playsInSilentModeIOS: true,
        shouldDuckAndroid: true,
        playThroughEarpieceAndroid: false,
      })
    }
    configureAudio()

    return () => {
      if (soundRef.current) {
        soundRef.current.unloadAsync()
      }
    }
  }, [])

  // Load chapter audio
  const loadChapter = useCallback(async (index: number) => {
    if (index < 0 || index >= chapters.length) return

    setIsLoading(true)

    try {
      // Unload previous sound
      if (soundRef.current) {
        await soundRef.current.unloadAsync()
      }

      const chapter = chapters[index]
      const { sound } = await Audio.Sound.createAsync(
        { uri: chapter.audio_url },
        { shouldPlay: false, rate: playbackRate },
        onPlaybackStatusUpdate
      )

      soundRef.current = sound
      setCurrentChapterIndex(index)
      setPosition(0)
      setDuration(chapter.duration_seconds * 1000)
      onChapterChange?.(index)
    } catch (error) {
      console.error('Failed to load audio:', error)
    } finally {
      setIsLoading(false)
    }
  }, [chapters, playbackRate, onChapterChange])

  // Playback status callback
  function onPlaybackStatusUpdate(status: AVPlaybackStatus) {
    if (!status.isLoaded) return

    setPosition(status.positionMillis)
    setDuration(status.durationMillis || 0)
    setIsPlaying(status.isPlaying)

    // Auto-advance to next chapter
    if (status.didJustFinish && !status.isLooping) {
      if (currentChapterIndex < chapters.length - 1) {
        playNextChapter()
      } else {
        setIsPlaying(false)
      }
    }
  }

  // Playback controls
  async function play() {
    if (!soundRef.current) {
      await loadChapter(currentChapterIndex)
    }
    await soundRef.current?.playAsync()
  }

  async function pause() {
    await soundRef.current?.pauseAsync()
  }

  async function togglePlay() {
    if (isPlaying) {
      await pause()
    } else {
      await play()
    }
  }

  async function seekTo(positionMs: number) {
    await soundRef.current?.setPositionAsync(positionMs)
    setPosition(positionMs)
  }

  async function skipForward(seconds = 15) {
    const newPosition = Math.min(position + seconds * 1000, duration)
    await seekTo(newPosition)
  }

  async function skipBackward(seconds = 15) {
    const newPosition = Math.max(position - seconds * 1000, 0)
    await seekTo(newPosition)
  }

  async function playNextChapter() {
    if (currentChapterIndex < chapters.length - 1) {
      const wasPlaying = isPlaying
      await loadChapter(currentChapterIndex + 1)
      if (wasPlaying) {
        await play()
      }
    }
  }

  async function playPreviousChapter() {
    // If more than 3 seconds in, restart current chapter
    if (position > 3000) {
      await seekTo(0)
    } else if (currentChapterIndex > 0) {
      const wasPlaying = isPlaying
      await loadChapter(currentChapterIndex - 1)
      if (wasPlaying) {
        await play()
      }
    }
  }

  async function goToChapter(index: number) {
    const wasPlaying = isPlaying
    await loadChapter(index)
    if (wasPlaying) {
      await play()
    }
  }

  async function setRate(rate: number) {
    setPlaybackRate(rate)
    await soundRef.current?.setRateAsync(rate, true)
  }

  // Initialize first chapter
  useEffect(() => {
    if (chapters.length > 0 && !soundRef.current) {
      loadChapter(0)
    }
  }, [chapters, loadChapter])

  return {
    isPlaying,
    isLoading,
    currentChapterIndex,
    currentChapter: chapters[currentChapterIndex],
    position,
    duration,
    playbackRate,
    progress: duration > 0 ? position / duration : 0,
    play,
    pause,
    togglePlay,
    seekTo,
    skipForward,
    skipBackward,
    playNextChapter,
    playPreviousChapter,
    goToChapter,
    setRate,
  }
}
```
  </action>
  <verify>cd codestory/mobile && npx tsc --noEmit</verify>
  <done>Audio player hook created</done>
</task>

<task type="auto">
  <n>Task 2: Create player screen with controls and chapter list</n>
  <files>codestory/mobile/app/story/[id]/play.tsx, codestory/mobile/components/PlayerControls.tsx</files>
  <action>
Create components/PlayerControls.tsx:

```typescript
import { View, Text, TouchableOpacity } from 'react-native'
import { Ionicons } from '@expo/vector-icons'
import Slider from '@react-native-community/slider'

interface PlayerControlsProps {
  isPlaying: boolean
  isLoading: boolean
  position: number
  duration: number
  playbackRate: number
  onTogglePlay: () => void
  onSeek: (position: number) => void
  onSkipForward: () => void
  onSkipBackward: () => void
  onRateChange: (rate: number) => void
}

function formatTime(ms: number): string {
  const totalSeconds = Math.floor(ms / 1000)
  const mins = Math.floor(totalSeconds / 60)
  const secs = totalSeconds % 60
  return `${mins}:${secs.toString().padStart(2, '0')}`
}

const PLAYBACK_RATES = [0.75, 1.0, 1.25, 1.5, 2.0]

export function PlayerControls({
  isPlaying,
  isLoading,
  position,
  duration,
  playbackRate,
  onTogglePlay,
  onSeek,
  onSkipForward,
  onSkipBackward,
  onRateChange,
}: PlayerControlsProps) {
  function cycleRate() {
    const currentIndex = PLAYBACK_RATES.indexOf(playbackRate)
    const nextIndex = (currentIndex + 1) % PLAYBACK_RATES.length
    onRateChange(PLAYBACK_RATES[nextIndex])
  }

  return (
    <View className="px-6">
      <Slider
        style={{ width: '100%', height: 40 }}
        minimumValue={0}
        maximumValue={duration}
        value={position}
        onSlidingComplete={onSeek}
        minimumTrackTintColor="#3b82f6"
        maximumTrackTintColor="#334155"
        thumbTintColor="#3b82f6"
      />

      <View className="flex-row justify-between px-2 -mt-2">
        <Text className="text-dark-muted text-sm">{formatTime(position)}</Text>
        <Text className="text-dark-muted text-sm">{formatTime(duration)}</Text>
      </View>

      <View className="flex-row items-center justify-center mt-6">
        <TouchableOpacity
          className="w-12 h-12 items-center justify-center"
          onPress={cycleRate}
        >
          <Text className="text-dark-muted font-semibold">{playbackRate}x</Text>
        </TouchableOpacity>

        <TouchableOpacity
          className="w-16 h-16 items-center justify-center"
          onPress={onSkipBackward}
        >
          <Ionicons name="play-back" size={32} color="#f8fafc" />
        </TouchableOpacity>

        <TouchableOpacity
          className="w-20 h-20 rounded-full bg-primary-600 items-center justify-center mx-4"
          onPress={onTogglePlay}
          disabled={isLoading}
        >
          {isLoading ? (
            <Ionicons name="hourglass" size={36} color="white" />
          ) : (
            <Ionicons
              name={isPlaying ? 'pause' : 'play'}
              size={36}
              color="white"
              style={{ marginLeft: isPlaying ? 0 : 4 }}
            />
          )}
        </TouchableOpacity>

        <TouchableOpacity
          className="w-16 h-16 items-center justify-center"
          onPress={onSkipForward}
        >
          <Ionicons name="play-forward" size={32} color="#f8fafc" />
        </TouchableOpacity>

        <View className="w-12 h-12" />
      </View>
    </View>
  )
}
```

Create app/story/[id]/play.tsx:

```typescript
import { useState, useEffect } from 'react'
import { View, Text, ScrollView, TouchableOpacity, Image, ActivityIndicator } from 'react-native'
import { useLocalSearchParams, router } from 'expo-router'
import { SafeAreaView } from 'react-native-safe-area-context'
import { Ionicons } from '@expo/vector-icons'
import { api } from '@/lib/api'
import { useAudioPlayer } from '@/hooks/useAudioPlayer'
import { PlayerControls } from '@/components/PlayerControls'

interface Chapter {
  id: string
  title: string
  audio_url: string
  duration_seconds: number
  order: number
}

interface Story {
  id: string
  title: string
  repository_url: string
  cover_image_url?: string
  chapters: Chapter[]
}

export default function PlayerScreen() {
  const { id: storyId } = useLocalSearchParams<{ id: string }>()
  const [story, setStory] = useState<Story | null>(null)
  const [isLoadingStory, setIsLoadingStory] = useState(true)
  const [showChapters, setShowChapters] = useState(false)

  const sortedChapters = story?.chapters.sort((a, b) => a.order - b.order) || []

  const {
    isPlaying,
    isLoading,
    currentChapterIndex,
    currentChapter,
    position,
    duration,
    playbackRate,
    togglePlay,
    seekTo,
    skipForward,
    skipBackward,
    goToChapter,
    setRate,
  } = useAudioPlayer({ chapters: sortedChapters })

  useEffect(() => {
    fetchStory()
  }, [storyId])

  async function fetchStory() {
    try {
      const response = await api.get(`/stories/${storyId}`)
      setStory(response.data.story)
    } catch (error) {
      console.error('Failed to fetch story:', error)
    } finally {
      setIsLoadingStory(false)
    }
  }

  if (isLoadingStory) {
    return (
      <SafeAreaView className="flex-1 bg-dark-bg items-center justify-center">
        <ActivityIndicator size="large" color="#3b82f6" />
      </SafeAreaView>
    )
  }

  if (!story) {
    return (
      <SafeAreaView className="flex-1 bg-dark-bg items-center justify-center">
        <Text className="text-dark-text">Story not found</Text>
      </SafeAreaView>
    )
  }

  return (
    <SafeAreaView className="flex-1 bg-dark-bg">
      <View className="flex-row items-center justify-between px-4 py-3">
        <TouchableOpacity onPress={() => router.back()}>
          <Ionicons name="chevron-down" size={28} color="#f8fafc" />
        </TouchableOpacity>
        <Text className="text-dark-muted">Now Playing</Text>
        <TouchableOpacity onPress={() => setShowChapters(!showChapters)}>
          <Ionicons name="list" size={24} color="#f8fafc" />
        </TouchableOpacity>
      </View>

      {showChapters ? (
        <ScrollView className="flex-1 px-4">
          <Text className="text-dark-text font-semibold text-lg mb-4">Chapters</Text>
          {sortedChapters.map((chapter, index) => (
            <TouchableOpacity
              key={chapter.id}
              className={`flex-row items-center p-4 rounded-xl mb-2 ${
                index === currentChapterIndex
                  ? 'bg-primary-600/20 border border-primary-600/50'
                  : 'bg-dark-card border border-dark-border'
              }`}
              onPress={() => goToChapter(index)}
            >
              <View className="w-8 h-8 rounded-full bg-dark-border items-center justify-center mr-3">
                {index === currentChapterIndex && isPlaying ? (
                  <Ionicons name="volume-high" size={16} color="#3b82f6" />
                ) : (
                  <Text className="text-dark-muted font-semibold">{index + 1}</Text>
                )}
              </View>
              <View className="flex-1">
                <Text
                  className={`font-medium ${
                    index === currentChapterIndex ? 'text-primary-400' : 'text-dark-text'
                  }`}
                >
                  {chapter.title}
                </Text>
              </View>
            </TouchableOpacity>
          ))}
        </ScrollView>
      ) : (
        <View className="flex-1 items-center justify-center px-8">
          <View className="w-64 h-64 rounded-2xl bg-gradient-to-br from-primary-600 to-primary-800 items-center justify-center mb-8">
            <Ionicons name="headset" size={80} color="white" />
          </View>

          <Text className="text-dark-text text-2xl font-bold text-center" numberOfLines={2}>
            {story.title}
          </Text>

          {currentChapter && (
            <Text className="text-dark-muted text-center mt-2">
              Chapter {currentChapterIndex + 1}: {currentChapter.title}
            </Text>
          )}
        </View>
      )}

      <PlayerControls
        isPlaying={isPlaying}
        isLoading={isLoading}
        position={position}
        duration={duration}
        playbackRate={playbackRate}
        onTogglePlay={togglePlay}
        onSeek={seekTo}
        onSkipForward={skipForward}
        onSkipBackward={skipBackward}
        onRateChange={setRate}
      />

      <View className="h-8" />
    </SafeAreaView>
  )
}
```

Install slider dependency:

```bash
cd codestory/mobile
npx expo install @react-native-community/slider
```
  </action>
  <verify>cd codestory/mobile && npx tsc --noEmit</verify>
  <done>Audio player screen implemented</done>
</task>

</tasks>

<playwright_validation_gate>
```
Playwright Action: Navigate to player screen with completed story
Expected: Player UI renders with controls

Playwright Action: Tap play button
Expected: Audio playback starts (verify via state change)

Playwright Action: Tap chapter list toggle
Expected: Chapter list displayed with current highlighted

Playwright Action: Seek via slider
Expected: Position updates correspondingly
```
</playwright_validation_gate>
