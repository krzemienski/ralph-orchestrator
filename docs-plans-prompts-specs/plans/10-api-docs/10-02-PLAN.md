# Plan 10-02: Rate Limiting and Quota Enforcement

## Overview
Implement tiered rate limiting and usage quota enforcement for Code Story API. This protects the system from abuse, ensures fair resource allocation, and enables usage-based billing for different subscription tiers.

## Dependencies
- Plan 10-01 complete (API key management)
- Redis operational for rate limit tracking
- User subscription tier model

## Error Recovery

Rate limiting depends on Redis. Implement resilience:

**Redis Unavailable:**
1. **Fail-open vs Fail-closed decision**: 
   - For public API: fail-open (allow requests) to avoid blocking legitimate users
   - For abuse-prone endpoints: fail-closed (deny) to prevent flood
   - Make this configurable per endpoint
2. Log all Redis failures for monitoring
3. Use local in-memory fallback for short outages (< 5 min)
4. Alert operations team on persistent Redis issues

**Rate Limit Edge Cases:**
- Clock skew between servers: use Redis TIME command
- Race conditions on increment: use MULTI/EXEC or Lua scripts
- Counter reset timing: use sliding window, not fixed windows

**Quota Synchronization:**
- Monthly reset: handle timezone correctly
- Mid-month tier upgrades: prorate or reset?
- Overage handling: hard stop vs soft warning

**Client Communication:**
- Include `X-RateLimit-Remaining` and `X-RateLimit-Reset` headers
- Return `429 Too Many Requests` with `Retry-After` header
- Provide clear error message with upgrade path

**Recovery from Abuse:**
- Automatic blocking of clearly abusive patterns
- Manual review queue for edge cases
- Graceful degradation under load (prioritize paid users)

## Implementation

### 1. Rate Limit Configuration

**config/rate_limits.py:**
```python
"""Rate limit configuration by tier."""
from dataclasses import dataclass
from enum import Enum
from typing import Optional


class SubscriptionTier(str, Enum):
    """User subscription tiers."""
    FREE = "free"
    PRO = "pro"
    TEAM = "team"
    ENTERPRISE = "enterprise"


@dataclass
class RateLimitConfig:
    """Rate limit configuration for a tier."""
    # Request rate limits
    requests_per_minute: int
    requests_per_hour: int
    requests_per_day: int
    
    # Story generation limits
    stories_per_day: int
    stories_per_month: int
    
    # Audio generation limits
    audio_minutes_per_month: int
    
    # Concurrent limits
    max_concurrent_generations: int
    
    # Cost limits (in credits)
    monthly_credit_limit: Optional[int] = None


# Tier configurations
RATE_LIMITS: dict[SubscriptionTier, RateLimitConfig] = {
    SubscriptionTier.FREE: RateLimitConfig(
        requests_per_minute=20,
        requests_per_hour=100,
        requests_per_day=500,
        stories_per_day=2,
        stories_per_month=10,
        audio_minutes_per_month=30,
        max_concurrent_generations=1,
        monthly_credit_limit=1000
    ),
    SubscriptionTier.PRO: RateLimitConfig(
        requests_per_minute=60,
        requests_per_hour=500,
        requests_per_day=5000,
        stories_per_day=10,
        stories_per_month=100,
        audio_minutes_per_month=300,
        max_concurrent_generations=3,
        monthly_credit_limit=10000
    ),
    SubscriptionTier.TEAM: RateLimitConfig(
        requests_per_minute=200,
        requests_per_hour=2000,
        requests_per_day=20000,
        stories_per_day=50,
        stories_per_month=500,
        audio_minutes_per_month=1000,
        max_concurrent_generations=10,
        monthly_credit_limit=50000
    ),
    SubscriptionTier.ENTERPRISE: RateLimitConfig(
        requests_per_minute=1000,
        requests_per_hour=10000,
        requests_per_day=100000,
        stories_per_day=500,
        stories_per_month=5000,
        audio_minutes_per_month=10000,
        max_concurrent_generations=50,
        monthly_credit_limit=None  # Unlimited
    )
}


def get_rate_limit_config(tier: SubscriptionTier) -> RateLimitConfig:
    """Get rate limit config for a tier."""
    return RATE_LIMITS.get(tier, RATE_LIMITS[SubscriptionTier.FREE])
```

### 2. Rate Limiter Service

**services/rate_limiter.py:**
```python
"""Redis-based rate limiter using sliding window algorithm."""
import time
from typing import Optional
from redis import Redis
from dataclasses import dataclass

from config.rate_limits import SubscriptionTier, RateLimitConfig, get_rate_limit_config


@dataclass
class RateLimitResult:
    """Result of rate limit check."""
    allowed: bool
    limit: int
    remaining: int
    reset_at: int  # Unix timestamp
    retry_after: Optional[int] = None  # Seconds until retry


class RateLimiter:
    """Sliding window rate limiter using Redis."""
    
    def __init__(self, redis: Redis):
        self.redis = redis
    
    def check_rate_limit(
        self,
        identifier: str,
        limit: int,
        window_seconds: int,
        key_prefix: str = "ratelimit"
    ) -> RateLimitResult:
        """Check if request is within rate limit.
        
        Uses sliding window log algorithm for accurate limiting.
        
        Args:
            identifier: User ID or API key ID
            limit: Maximum requests allowed in window
            window_seconds: Time window in seconds
            key_prefix: Redis key prefix
            
        Returns:
            RateLimitResult with allowed status and metadata
        """
        now = time.time()
        window_start = now - window_seconds
        key = f"{key_prefix}:{identifier}:{window_seconds}"
        
        pipe = self.redis.pipeline()
        
        # Remove old entries outside window
        pipe.zremrangebyscore(key, 0, window_start)
        
        # Count current entries
        pipe.zcard(key)
        
        # Add new entry
        pipe.zadd(key, {str(now): now})
        
        # Set expiry
        pipe.expire(key, window_seconds)
        
        results = pipe.execute()
        current_count = results[1]
        
        if current_count >= limit:
            # Get oldest entry to calculate retry time
            oldest = self.redis.zrange(key, 0, 0, withscores=True)
            if oldest:
                retry_after = int(oldest[0][1] + window_seconds - now) + 1
            else:
                retry_after = window_seconds
            
            return RateLimitResult(
                allowed=False,
                limit=limit,
                remaining=0,
                reset_at=int(now + retry_after),
                retry_after=retry_after
            )
        
        return RateLimitResult(
            allowed=True,
            limit=limit,
            remaining=limit - current_count - 1,
            reset_at=int(now + window_seconds)
        )
    
    def check_all_limits(
        self,
        identifier: str,
        tier: SubscriptionTier
    ) -> tuple[bool, Optional[RateLimitResult]]:
        """Check all rate limits for a tier.
        
        Returns:
            Tuple of (allowed, failed_result) - failed_result is set if denied
        """
        config = get_rate_limit_config(tier)
        
        # Check in order of smallest window first
        checks = [
            (config.requests_per_minute, 60, "rpm"),
            (config.requests_per_hour, 3600, "rph"),
            (config.requests_per_day, 86400, "rpd"),
        ]
        
        for limit, window, prefix in checks:
            result = self.check_rate_limit(
                identifier, limit, window, f"ratelimit:{prefix}"
            )
            if not result.allowed:
                return False, result
        
        return True, None
    
    def get_usage_stats(
        self,
        identifier: str,
        tier: SubscriptionTier
    ) -> dict:
        """Get current usage statistics."""
        config = get_rate_limit_config(tier)
        now = time.time()
        
        stats = {}
        windows = [
            ("minute", 60, config.requests_per_minute),
            ("hour", 3600, config.requests_per_hour),
            ("day", 86400, config.requests_per_day),
        ]
        
        for name, window, limit in windows:
            key = f"ratelimit:rp{name[0]}:{identifier}:{window}"
            count = self.redis.zcount(key, now - window, now)
            stats[name] = {
                "used": count,
                "limit": limit,
                "remaining": max(0, limit - count)
            }
        
        return stats
```

### 3. Quota Tracking Service

**services/quota_service.py:**
```python
"""Usage quota tracking and enforcement."""
import uuid
from datetime import datetime, timedelta
from typing import Optional
from sqlalchemy.orm import Session
from sqlalchemy import func

from models.usage import UsageRecord, UsageType
from models.user import User
from config.rate_limits import SubscriptionTier, get_rate_limit_config


class QuotaService:
    """Service for tracking and enforcing usage quotas."""
    
    def __init__(self, db: Session):
        self.db = db
    
    def record_usage(
        self,
        user_id: str,
        usage_type: UsageType,
        quantity: float,
        metadata: Optional[dict] = None
    ) -> UsageRecord:
        """Record usage event."""
        record = UsageRecord(
            id=str(uuid.uuid4()),
            user_id=user_id,
            usage_type=usage_type,
            quantity=quantity,
            metadata=metadata or {},
            recorded_at=datetime.utcnow()
        )
        
        self.db.add(record)
        self.db.commit()
        
        return record
    
    def check_quota(
        self,
        user_id: str,
        usage_type: UsageType,
        requested_quantity: float = 1
    ) -> tuple[bool, dict]:
        """Check if user has quota available.
        
        Returns:
            Tuple of (allowed, quota_info)
        """
        user = self.db.query(User).filter(User.id == user_id).first()
        if not user:
            return False, {"error": "User not found"}
        
        tier = SubscriptionTier(user.subscription_tier)
        config = get_rate_limit_config(tier)
        
        # Get period boundaries
        now = datetime.utcnow()
        month_start = now.replace(day=1, hour=0, minute=0, second=0, microsecond=0)
        day_start = now.replace(hour=0, minute=0, second=0, microsecond=0)
        
        # Check based on usage type
        if usage_type == UsageType.STORY_GENERATION:
            return self._check_story_quota(
                user_id, config, month_start, day_start, requested_quantity
            )
        elif usage_type == UsageType.AUDIO_MINUTES:
            return self._check_audio_quota(
                user_id, config, month_start, requested_quantity
            )
        elif usage_type == UsageType.CREDITS:
            return self._check_credit_quota(
                user_id, config, month_start, requested_quantity
            )
        
        return True, {}
    
    def _check_story_quota(
        self,
        user_id: str,
        config,
        month_start: datetime,
        day_start: datetime,
        requested: float
    ) -> tuple[bool, dict]:
        """Check story generation quota."""
        # Daily count
        daily_count = self.db.query(func.count(UsageRecord.id)).filter(
            UsageRecord.user_id == user_id,
            UsageRecord.usage_type == UsageType.STORY_GENERATION,
            UsageRecord.recorded_at >= day_start
        ).scalar() or 0
        
        # Monthly count
        monthly_count = self.db.query(func.count(UsageRecord.id)).filter(
            UsageRecord.user_id == user_id,
            UsageRecord.usage_type == UsageType.STORY_GENERATION,
            UsageRecord.recorded_at >= month_start
        ).scalar() or 0
        
        quota_info = {
            "daily": {
                "used": daily_count,
                "limit": config.stories_per_day,
                "remaining": max(0, config.stories_per_day - daily_count)
            },
            "monthly": {
                "used": monthly_count,
                "limit": config.stories_per_month,
                "remaining": max(0, config.stories_per_month - monthly_count)
            }
        }
        
        if daily_count + requested > config.stories_per_day:
            return False, {**quota_info, "exceeded": "daily"}
        
        if monthly_count + requested > config.stories_per_month:
            return False, {**quota_info, "exceeded": "monthly"}
        
        return True, quota_info
    
    def _check_audio_quota(
        self,
        user_id: str,
        config,
        month_start: datetime,
        requested: float
    ) -> tuple[bool, dict]:
        """Check audio generation quota."""
        monthly_minutes = self.db.query(func.sum(UsageRecord.quantity)).filter(
            UsageRecord.user_id == user_id,
            UsageRecord.usage_type == UsageType.AUDIO_MINUTES,
            UsageRecord.recorded_at >= month_start
        ).scalar() or 0
        
        quota_info = {
            "monthly": {
                "used": monthly_minutes,
                "limit": config.audio_minutes_per_month,
                "remaining": max(0, config.audio_minutes_per_month - monthly_minutes)
            }
        }
        
        if monthly_minutes + requested > config.audio_minutes_per_month:
            return False, {**quota_info, "exceeded": "monthly"}
        
        return True, quota_info
    
    def _check_credit_quota(
        self,
        user_id: str,
        config,
        month_start: datetime,
        requested: float
    ) -> tuple[bool, dict]:
        """Check credit usage quota."""
        if config.monthly_credit_limit is None:
            return True, {"unlimited": True}
        
        monthly_credits = self.db.query(func.sum(UsageRecord.quantity)).filter(
            UsageRecord.user_id == user_id,
            UsageRecord.usage_type == UsageType.CREDITS,
            UsageRecord.recorded_at >= month_start
        ).scalar() or 0
        
        quota_info = {
            "monthly": {
                "used": monthly_credits,
                "limit": config.monthly_credit_limit,
                "remaining": max(0, config.monthly_credit_limit - monthly_credits)
            }
        }
        
        if monthly_credits + requested > config.monthly_credit_limit:
            return False, {**quota_info, "exceeded": "monthly"}
        
        return True, quota_info
    
    def get_usage_summary(self, user_id: str) -> dict:
        """Get complete usage summary for user."""
        user = self.db.query(User).filter(User.id == user_id).first()
        if not user:
            return {}
        
        tier = SubscriptionTier(user.subscription_tier)
        config = get_rate_limit_config(tier)
        
        now = datetime.utcnow()
        month_start = now.replace(day=1, hour=0, minute=0, second=0, microsecond=0)
        day_start = now.replace(hour=0, minute=0, second=0, microsecond=0)
        
        return {
            "tier": tier.value,
            "stories": {
                "daily": self._get_usage_count(
                    user_id, UsageType.STORY_GENERATION, day_start,
                    config.stories_per_day
                ),
                "monthly": self._get_usage_count(
                    user_id, UsageType.STORY_GENERATION, month_start,
                    config.stories_per_month
                )
            },
            "audio_minutes": self._get_usage_sum(
                user_id, UsageType.AUDIO_MINUTES, month_start,
                config.audio_minutes_per_month
            ),
            "credits": self._get_usage_sum(
                user_id, UsageType.CREDITS, month_start,
                config.monthly_credit_limit
            ),
            "period_reset": (month_start + timedelta(days=32)).replace(day=1).isoformat()
        }
    
    def _get_usage_count(
        self,
        user_id: str,
        usage_type: UsageType,
        since: datetime,
        limit: int
    ) -> dict:
        """Get usage count for period."""
        count = self.db.query(func.count(UsageRecord.id)).filter(
            UsageRecord.user_id == user_id,
            UsageRecord.usage_type == usage_type,
            UsageRecord.recorded_at >= since
        ).scalar() or 0
        
        return {
            "used": count,
            "limit": limit,
            "remaining": max(0, limit - count)
        }
    
    def _get_usage_sum(
        self,
        user_id: str,
        usage_type: UsageType,
        since: datetime,
        limit: Optional[int]
    ) -> dict:
        """Get usage sum for period."""
        total = self.db.query(func.sum(UsageRecord.quantity)).filter(
            UsageRecord.user_id == user_id,
            UsageRecord.usage_type == usage_type,
            UsageRecord.recorded_at >= since
        ).scalar() or 0
        
        if limit is None:
            return {"used": total, "limit": None, "unlimited": True}
        
        return {
            "used": total,
            "limit": limit,
            "remaining": max(0, limit - total)
        }
```

### 4. Usage Model

**models/usage.py:**
```python
"""Usage tracking models."""
from datetime import datetime
from enum import Enum
from sqlalchemy import Column, String, DateTime, Float, JSON, ForeignKey, Enum as SQLEnum
from sqlalchemy.orm import relationship

from database import Base


class UsageType(str, Enum):
    """Types of usage to track."""
    STORY_GENERATION = "story_generation"
    AUDIO_MINUTES = "audio_minutes"
    CREDITS = "credits"
    API_REQUESTS = "api_requests"


class UsageRecord(Base):
    """Individual usage record."""
    __tablename__ = "usage_records"
    
    id = Column(String(36), primary_key=True)
    user_id = Column(String(36), ForeignKey("users.id"), nullable=False)
    usage_type = Column(SQLEnum(UsageType), nullable=False)
    quantity = Column(Float, nullable=False)
    metadata = Column(JSON, default={})
    recorded_at = Column(DateTime, default=datetime.utcnow, index=True)
    
    # Relationships
    user = relationship("User", back_populates="usage_records")
```

### 5. Rate Limit Middleware

**middleware/rate_limit.py:**
```python
"""Rate limiting middleware."""
from fastapi import Request, HTTPException, status
from fastapi.responses import JSONResponse
from starlette.middleware.base import BaseHTTPMiddleware
from redis import Redis

from services.rate_limiter import RateLimiter, RateLimitResult
from config.rate_limits import SubscriptionTier
from database import SessionLocal


class RateLimitMiddleware(BaseHTTPMiddleware):
    """Middleware to enforce rate limits."""
    
    def __init__(self, app, redis: Redis):
        super().__init__(app)
        self.limiter = RateLimiter(redis)
    
    async def dispatch(self, request: Request, call_next):
        # Skip rate limiting for certain paths
        if self._should_skip(request.url.path):
            return await call_next(request)
        
        # Get identifier and tier
        identifier, tier = await self._get_identifier_and_tier(request)
        
        if identifier:
            allowed, result = self.limiter.check_all_limits(identifier, tier)
            
            if not allowed:
                return self._rate_limit_response(result)
        
        response = await call_next(request)
        
        # Add rate limit headers
        if identifier:
            stats = self.limiter.get_usage_stats(identifier, tier)
            response.headers["X-RateLimit-Limit"] = str(stats["minute"]["limit"])
            response.headers["X-RateLimit-Remaining"] = str(stats["minute"]["remaining"])
        
        return response
    
    def _should_skip(self, path: str) -> bool:
        """Check if path should skip rate limiting."""
        skip_paths = ["/health", "/docs", "/openapi.json", "/redoc"]
        return any(path.startswith(p) for p in skip_paths)
    
    async def _get_identifier_and_tier(
        self,
        request: Request
    ) -> tuple[str, SubscriptionTier]:
        """Extract user identifier and tier from request."""
        # Check for API key
        api_key = request.headers.get("X-API-Key")
        if api_key:
            # API key authentication path
            from services.api_key_service import APIKeyService
            db = SessionLocal()
            try:
                service = APIKeyService(db)
                key_record = service.validate_key(api_key)
                if key_record:
                    user = db.query(User).filter(User.id == key_record.user_id).first()
                    tier = SubscriptionTier(user.subscription_tier) if user else SubscriptionTier.FREE
                    return key_record.user_id, tier
            finally:
                db.close()
        
        # Check for JWT
        auth_header = request.headers.get("Authorization")
        if auth_header and auth_header.startswith("Bearer "):
            # JWT authentication path - extract user from token
            # Simplified - actual implementation would decode JWT
            pass
        
        # Fall back to IP-based limiting for unauthenticated requests
        client_ip = request.client.host
        return f"ip:{client_ip}", SubscriptionTier.FREE
    
    def _rate_limit_response(self, result: RateLimitResult) -> JSONResponse:
        """Create rate limit exceeded response."""
        return JSONResponse(
            status_code=status.HTTP_429_TOO_MANY_REQUESTS,
            content={
                "error": "Rate limit exceeded",
                "limit": result.limit,
                "retry_after": result.retry_after
            },
            headers={
                "Retry-After": str(result.retry_after),
                "X-RateLimit-Limit": str(result.limit),
                "X-RateLimit-Remaining": "0",
                "X-RateLimit-Reset": str(result.reset_at)
            }
        )
```

### 6. Quota Middleware

**middleware/quota.py:**
```python
"""Quota enforcement middleware for specific endpoints."""
from functools import wraps
from fastapi import Request, HTTPException, status, Depends
from sqlalchemy.orm import Session

from database import get_db
from models.usage import UsageType
from services.quota_service import QuotaService


def require_quota(usage_type: UsageType, quantity: float = 1):
    """Decorator to require quota before endpoint execution."""
    
    def decorator(func):
        @wraps(func)
        async def wrapper(*args, **kwargs):
            # Extract dependencies from kwargs
            request: Request = kwargs.get("request")
            db: Session = kwargs.get("db")
            current_user = kwargs.get("current_user")
            
            if not current_user:
                raise HTTPException(
                    status_code=status.HTTP_401_UNAUTHORIZED,
                    detail="Authentication required"
                )
            
            # Check quota
            quota_service = QuotaService(db)
            allowed, quota_info = quota_service.check_quota(
                current_user.id, usage_type, quantity
            )
            
            if not allowed:
                exceeded = quota_info.get("exceeded", "quota")
                raise HTTPException(
                    status_code=status.HTTP_402_PAYMENT_REQUIRED,
                    detail={
                        "error": f"{exceeded.capitalize()} quota exceeded",
                        "quota_info": quota_info,
                        "upgrade_url": "/settings/billing"
                    }
                )
            
            # Store quota info for later recording
            request.state.quota_info = quota_info
            request.state.usage_type = usage_type
            request.state.usage_quantity = quantity
            
            return await func(*args, **kwargs)
        
        return wrapper
    return decorator


async def record_usage_after(
    request: Request,
    db: Session = Depends(get_db)
):
    """Record usage after successful request."""
    if hasattr(request.state, "usage_type"):
        quota_service = QuotaService(db)
        quota_service.record_usage(
            user_id=request.state.user_id,
            usage_type=request.state.usage_type,
            quantity=request.state.usage_quantity
        )
```

### 7. Usage Endpoints

**routers/usage.py:**
```python
"""Usage and quota endpoints."""
from fastapi import APIRouter, Depends
from sqlalchemy.orm import Session

from database import get_db
from auth import get_current_user
from models.user import User
from services.quota_service import QuotaService
from services.rate_limiter import RateLimiter
from config.rate_limits import SubscriptionTier
from dependencies import get_redis

router = APIRouter(prefix="/usage", tags=["Usage"])


@router.get("/summary")
async def get_usage_summary(
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Get current usage summary for authenticated user."""
    quota_service = QuotaService(db)
    return quota_service.get_usage_summary(current_user.id)


@router.get("/rate-limits")
async def get_rate_limit_status(
    current_user: User = Depends(get_current_user),
    redis = Depends(get_redis)
):
    """Get current rate limit status."""
    limiter = RateLimiter(redis)
    tier = SubscriptionTier(current_user.subscription_tier)
    
    return limiter.get_usage_stats(current_user.id, tier)


@router.get("/history")
async def get_usage_history(
    days: int = 30,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Get usage history for the specified period."""
    from datetime import datetime, timedelta
    from sqlalchemy import func
    from models.usage import UsageRecord, UsageType
    
    since = datetime.utcnow() - timedelta(days=days)
    
    # Aggregate by day and type
    records = db.query(
        func.date(UsageRecord.recorded_at).label("date"),
        UsageRecord.usage_type,
        func.sum(UsageRecord.quantity).label("total")
    ).filter(
        UsageRecord.user_id == current_user.id,
        UsageRecord.recorded_at >= since
    ).group_by(
        func.date(UsageRecord.recorded_at),
        UsageRecord.usage_type
    ).all()
    
    # Format response
    history = {}
    for record in records:
        date_str = str(record.date)
        if date_str not in history:
            history[date_str] = {}
        history[date_str][record.usage_type.value] = record.total
    
    return {"history": history, "period_days": days}
```

## File Structure
```
backend/
├── config/
│   └── rate_limits.py
├── models/
│   └── usage.py
├── services/
│   ├── rate_limiter.py
│   └── quota_service.py
├── middleware/
│   ├── rate_limit.py
│   └── quota.py
└── routers/
    └── usage.py
```

## Validation Gates

### Gate 1: Rate Limiting
```python
def test_rate_limiting():
    """Verify rate limits are enforced."""
    # Make requests up to limit
    for i in range(20):
        response = client.get("/api/v1/stories", headers=auth_headers)
        assert response.status_code == 200
    
    # Next request should be rate limited
    response = client.get("/api/v1/stories", headers=auth_headers)
    assert response.status_code == 429
    assert "Retry-After" in response.headers
```

### Gate 2: Quota Enforcement
```python
def test_quota_enforcement():
    """Verify quota limits are enforced."""
    # Create stories up to daily limit (2 for free tier)
    for i in range(2):
        response = client.post("/api/v1/stories", json={
            "repo_url": f"https://github.com/test/repo{i}"
        }, headers=auth_headers)
        assert response.status_code == 201
    
    # Third story should fail quota
    response = client.post("/api/v1/stories", json={
        "repo_url": "https://github.com/test/repo3"
    }, headers=auth_headers)
    assert response.status_code == 402
    assert "quota exceeded" in response.json()["detail"]["error"]
```

### Gate 3: Usage Tracking
```python
def test_usage_tracking():
    """Verify usage is recorded correctly."""
    # Create a story
    client.post("/api/v1/stories", json={
        "repo_url": "https://github.com/test/repo"
    }, headers=auth_headers)
    
    # Check usage summary
    response = client.get("/api/v1/usage/summary", headers=auth_headers)
    data = response.json()
    
    assert data["stories"]["daily"]["used"] == 1
    assert data["stories"]["monthly"]["used"] == 1
```

### Gate 4: Tier Differentiation
```python
def test_tier_limits():
    """Verify different tiers have different limits."""
    # Pro user should have higher limits
    pro_headers = get_auth_headers(pro_user)
    
    # Pro can make 60 requests per minute (vs 20 for free)
    for i in range(60):
        response = client.get("/api/v1/stories", headers=pro_headers)
        assert response.status_code == 200
```

## Definition of Done
- [ ] Rate limit configuration by tier
- [ ] Sliding window rate limiter with Redis
- [ ] Quota tracking for stories, audio, credits
- [ ] Rate limit middleware with proper headers
- [ ] Quota enforcement on generation endpoints
- [ ] Usage recording after successful requests
- [ ] Usage summary and history endpoints
- [ ] All validation gates passing
