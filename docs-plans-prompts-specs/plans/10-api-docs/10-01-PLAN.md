# Plan 10-01: API Key Generation and Management

## Overview
Implement secure API key generation, storage, and management for programmatic access to Code Story. This enables developers to integrate story generation into their CI/CD pipelines, documentation systems, and custom applications.

## Dependencies
- Phase 6 complete (FastAPI backend with authentication)
- Database models operational
- Redis available for key caching

## Implementation

### 1. API Key Models

**models/api_key.py:**
```python
"""API key data models."""
import secrets
import hashlib
from datetime import datetime, timedelta
from enum import Enum
from sqlalchemy import Column, String, DateTime, Boolean, Integer, ForeignKey, Enum as SQLEnum
from sqlalchemy.orm import relationship

from database import Base


class APIKeyScope(str, Enum):
    """Permission scopes for API keys."""
    READ = "read"           # View stories, chapters
    WRITE = "write"         # Create stories, generate
    ADMIN = "admin"         # Full access including settings


class APIKey(Base):
    """API key for programmatic access."""
    __tablename__ = "api_keys"
    
    id = Column(String(36), primary_key=True)
    user_id = Column(String(36), ForeignKey("users.id"), nullable=False)
    
    # Key storage - only store hash, prefix for identification
    key_prefix = Column(String(8), nullable=False, index=True)  # e.g., "cs_live_"
    key_hash = Column(String(64), nullable=False, unique=True)
    
    # Metadata
    name = Column(String(100), nullable=False)  # User-friendly name
    description = Column(String(500), nullable=True)
    scopes = Column(String(100), nullable=False)  # Comma-separated scopes
    
    # Lifecycle
    created_at = Column(DateTime, default=datetime.utcnow)
    expires_at = Column(DateTime, nullable=True)  # None = never expires
    last_used_at = Column(DateTime, nullable=True)
    revoked_at = Column(DateTime, nullable=True)
    
    # Usage tracking
    request_count = Column(Integer, default=0)
    is_active = Column(Boolean, default=True)
    
    # Relationships
    user = relationship("User", back_populates="api_keys")
    
    @staticmethod
    def generate_key() -> tuple[str, str]:
        """Generate a new API key and its hash.
        
        Returns:
            Tuple of (plain_key, key_hash)
        """
        # Generate 32 bytes of randomness, encode as hex
        random_part = secrets.token_hex(32)
        plain_key = f"cs_live_{random_part}"
        
        # Hash for storage
        key_hash = hashlib.sha256(plain_key.encode()).hexdigest()
        
        return plain_key, key_hash
    
    @staticmethod
    def hash_key(plain_key: str) -> str:
        """Hash a plain API key for lookup."""
        return hashlib.sha256(plain_key.encode()).hexdigest()
    
    def has_scope(self, required_scope: APIKeyScope) -> bool:
        """Check if key has required scope."""
        key_scopes = self.scopes.split(",")
        
        # Admin has all permissions
        if APIKeyScope.ADMIN.value in key_scopes:
            return True
        
        # Write includes read
        if required_scope == APIKeyScope.READ and APIKeyScope.WRITE.value in key_scopes:
            return True
        
        return required_scope.value in key_scopes
    
    def is_valid(self) -> bool:
        """Check if key is valid (active, not expired, not revoked)."""
        if not self.is_active or self.revoked_at:
            return False
        
        if self.expires_at and datetime.utcnow() > self.expires_at:
            return False
        
        return True
```

### 2. API Key Service

**services/api_key_service.py:**
```python
"""API key management service."""
import uuid
from datetime import datetime, timedelta
from typing import Optional
from sqlalchemy.orm import Session
from redis import Redis

from models.api_key import APIKey, APIKeyScope
from schemas.api_key import APIKeyCreate, APIKeyResponse


class APIKeyService:
    """Service for API key operations."""
    
    def __init__(self, db: Session, redis: Optional[Redis] = None):
        self.db = db
        self.redis = redis
        self.cache_ttl = 300  # 5 minutes
    
    def create_key(
        self,
        user_id: str,
        name: str,
        scopes: list[APIKeyScope],
        description: Optional[str] = None,
        expires_in_days: Optional[int] = None
    ) -> tuple[APIKey, str]:
        """Create a new API key.
        
        Returns:
            Tuple of (APIKey model, plain_key) - plain_key only shown once
        """
        # Generate key
        plain_key, key_hash = APIKey.generate_key()
        
        # Calculate expiration
        expires_at = None
        if expires_in_days:
            expires_at = datetime.utcnow() + timedelta(days=expires_in_days)
        
        # Create record
        api_key = APIKey(
            id=str(uuid.uuid4()),
            user_id=user_id,
            key_prefix=plain_key[:12],  # "cs_live_xxxx"
            key_hash=key_hash,
            name=name,
            description=description,
            scopes=",".join(s.value for s in scopes),
            expires_at=expires_at
        )
        
        self.db.add(api_key)
        self.db.commit()
        self.db.refresh(api_key)
        
        return api_key, plain_key
    
    def validate_key(self, plain_key: str) -> Optional[APIKey]:
        """Validate an API key and return the key record if valid."""
        # Check cache first
        if self.redis:
            cached = self._get_cached_key(plain_key)
            if cached:
                return cached
            
            # Check if key is in deny list (revoked)
            if self._is_denied(plain_key):
                return None
        
        # Look up by hash
        key_hash = APIKey.hash_key(plain_key)
        api_key = self.db.query(APIKey).filter(
            APIKey.key_hash == key_hash
        ).first()
        
        if not api_key or not api_key.is_valid():
            return None
        
        # Update last used
        api_key.last_used_at = datetime.utcnow()
        api_key.request_count += 1
        self.db.commit()
        
        # Cache valid key
        if self.redis:
            self._cache_key(plain_key, api_key)
        
        return api_key
    
    def list_keys(self, user_id: str, include_revoked: bool = False) -> list[APIKey]:
        """List all API keys for a user."""
        query = self.db.query(APIKey).filter(APIKey.user_id == user_id)
        
        if not include_revoked:
            query = query.filter(APIKey.revoked_at.is_(None))
        
        return query.order_by(APIKey.created_at.desc()).all()
    
    def revoke_key(self, key_id: str, user_id: str) -> bool:
        """Revoke an API key."""
        api_key = self.db.query(APIKey).filter(
            APIKey.id == key_id,
            APIKey.user_id == user_id
        ).first()
        
        if not api_key:
            return False
        
        api_key.revoked_at = datetime.utcnow()
        api_key.is_active = False
        self.db.commit()
        
        # Add to deny list in cache
        if self.redis:
            self._deny_key(api_key.key_prefix)
        
        return True
    
    def update_key(
        self,
        key_id: str,
        user_id: str,
        name: Optional[str] = None,
        description: Optional[str] = None,
        scopes: Optional[list[APIKeyScope]] = None
    ) -> Optional[APIKey]:
        """Update API key metadata."""
        api_key = self.db.query(APIKey).filter(
            APIKey.id == key_id,
            APIKey.user_id == user_id,
            APIKey.revoked_at.is_(None)
        ).first()
        
        if not api_key:
            return None
        
        if name:
            api_key.name = name
        if description is not None:
            api_key.description = description
        if scopes:
            api_key.scopes = ",".join(s.value for s in scopes)
        
        self.db.commit()
        self.db.refresh(api_key)
        
        # Invalidate cache
        if self.redis:
            self._invalidate_cache(api_key.key_prefix)
        
        return api_key
    
    # Cache methods
    def _cache_key(self, plain_key: str, api_key: APIKey) -> None:
        """Cache validated key."""
        cache_data = {
            "id": api_key.id,
            "user_id": api_key.user_id,
            "scopes": api_key.scopes,
            "expires_at": api_key.expires_at.isoformat() if api_key.expires_at else None
        }
        self.redis.setex(
            f"apikey:{APIKey.hash_key(plain_key)}",
            self.cache_ttl,
            str(cache_data)
        )
    
    def _get_cached_key(self, plain_key: str) -> Optional[dict]:
        """Get key from cache."""
        cached = self.redis.get(f"apikey:{APIKey.hash_key(plain_key)}")
        if cached:
            return eval(cached)  # Safe since we control the data
        return None
    
    def _deny_key(self, key_prefix: str) -> None:
        """Add key to deny list."""
        self.redis.setex(f"apikey:denied:{key_prefix}", 86400, "1")  # 24h
    
    def _is_denied(self, plain_key: str) -> bool:
        """Check if key is in deny list."""
        prefix = plain_key[:12]
        return bool(self.redis.get(f"apikey:denied:{prefix}"))
    
    def _invalidate_cache(self, key_prefix: str) -> None:
        """Invalidate cached key data."""
        # We don't have the full key, so we rely on TTL
        pass
```

### 3. API Key Schemas

**schemas/api_key.py:**
```python
"""Pydantic schemas for API keys."""
from datetime import datetime
from typing import Optional
from pydantic import BaseModel, Field

from models.api_key import APIKeyScope


class APIKeyCreate(BaseModel):
    """Request to create an API key."""
    name: str = Field(..., min_length=1, max_length=100)
    description: Optional[str] = Field(None, max_length=500)
    scopes: list[APIKeyScope] = Field(default=[APIKeyScope.READ])
    expires_in_days: Optional[int] = Field(None, ge=1, le=365)


class APIKeyResponse(BaseModel):
    """API key response (without sensitive data)."""
    id: str
    name: str
    description: Optional[str]
    key_prefix: str
    scopes: list[str]
    created_at: datetime
    expires_at: Optional[datetime]
    last_used_at: Optional[datetime]
    request_count: int
    is_active: bool
    
    class Config:
        from_attributes = True


class APIKeyCreated(APIKeyResponse):
    """Response when key is created - includes full key (shown once)."""
    key: str = Field(..., description="Full API key - save this, it won't be shown again")


class APIKeyUpdate(BaseModel):
    """Request to update API key."""
    name: Optional[str] = Field(None, min_length=1, max_length=100)
    description: Optional[str] = Field(None, max_length=500)
    scopes: Optional[list[APIKeyScope]] = None
```

### 4. API Key Router

**routers/api_keys.py:**
```python
"""API key management endpoints."""
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session

from database import get_db
from auth import get_current_user
from models.user import User
from models.api_key import APIKeyScope
from schemas.api_key import APIKeyCreate, APIKeyResponse, APIKeyCreated, APIKeyUpdate
from services.api_key_service import APIKeyService

router = APIRouter(prefix="/api-keys", tags=["API Keys"])


@router.post("", response_model=APIKeyCreated, status_code=status.HTTP_201_CREATED)
async def create_api_key(
    request: APIKeyCreate,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Create a new API key.
    
    The full key is only returned once - save it securely.
    """
    service = APIKeyService(db)
    
    # Limit number of keys per user
    existing_keys = service.list_keys(current_user.id)
    if len(existing_keys) >= 10:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Maximum 10 API keys allowed per user"
        )
    
    api_key, plain_key = service.create_key(
        user_id=current_user.id,
        name=request.name,
        scopes=request.scopes,
        description=request.description,
        expires_in_days=request.expires_in_days
    )
    
    return APIKeyCreated(
        id=api_key.id,
        name=api_key.name,
        description=api_key.description,
        key_prefix=api_key.key_prefix,
        key=plain_key,  # Only time this is returned
        scopes=api_key.scopes.split(","),
        created_at=api_key.created_at,
        expires_at=api_key.expires_at,
        last_used_at=api_key.last_used_at,
        request_count=api_key.request_count,
        is_active=api_key.is_active
    )


@router.get("", response_model=list[APIKeyResponse])
async def list_api_keys(
    include_revoked: bool = False,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """List all API keys for the current user."""
    service = APIKeyService(db)
    keys = service.list_keys(current_user.id, include_revoked)
    
    return [
        APIKeyResponse(
            id=k.id,
            name=k.name,
            description=k.description,
            key_prefix=k.key_prefix,
            scopes=k.scopes.split(","),
            created_at=k.created_at,
            expires_at=k.expires_at,
            last_used_at=k.last_used_at,
            request_count=k.request_count,
            is_active=k.is_active
        )
        for k in keys
    ]


@router.get("/{key_id}", response_model=APIKeyResponse)
async def get_api_key(
    key_id: str,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Get details of a specific API key."""
    service = APIKeyService(db)
    keys = service.list_keys(current_user.id, include_revoked=True)
    
    key = next((k for k in keys if k.id == key_id), None)
    if not key:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="API key not found"
        )
    
    return APIKeyResponse(
        id=key.id,
        name=key.name,
        description=key.description,
        key_prefix=key.key_prefix,
        scopes=key.scopes.split(","),
        created_at=key.created_at,
        expires_at=key.expires_at,
        last_used_at=key.last_used_at,
        request_count=key.request_count,
        is_active=key.is_active
    )


@router.patch("/{key_id}", response_model=APIKeyResponse)
async def update_api_key(
    key_id: str,
    request: APIKeyUpdate,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Update an API key's metadata."""
    service = APIKeyService(db)
    
    updated = service.update_key(
        key_id=key_id,
        user_id=current_user.id,
        name=request.name,
        description=request.description,
        scopes=request.scopes
    )
    
    if not updated:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="API key not found or already revoked"
        )
    
    return APIKeyResponse(
        id=updated.id,
        name=updated.name,
        description=updated.description,
        key_prefix=updated.key_prefix,
        scopes=updated.scopes.split(","),
        created_at=updated.created_at,
        expires_at=updated.expires_at,
        last_used_at=updated.last_used_at,
        request_count=updated.request_count,
        is_active=updated.is_active
    )


@router.delete("/{key_id}", status_code=status.HTTP_204_NO_CONTENT)
async def revoke_api_key(
    key_id: str,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Revoke an API key."""
    service = APIKeyService(db)
    
    if not service.revoke_key(key_id, current_user.id):
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="API key not found"
        )
```

### 5. API Key Authentication Middleware

**auth/api_key_auth.py:**
```python
"""API key authentication for programmatic access."""
from fastapi import Request, HTTPException, status, Depends
from fastapi.security import APIKeyHeader
from sqlalchemy.orm import Session

from database import get_db
from models.api_key import APIKey, APIKeyScope
from services.api_key_service import APIKeyService

api_key_header = APIKeyHeader(name="X-API-Key", auto_error=False)


async def get_api_key_user(
    api_key: str = Depends(api_key_header),
    db: Session = Depends(get_db)
) -> tuple[str, APIKey]:
    """Validate API key and return user_id and key record.
    
    Raises:
        HTTPException: If key is invalid or missing
    """
    if not api_key:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="API key required",
            headers={"WWW-Authenticate": "ApiKey"}
        )
    
    service = APIKeyService(db)
    key_record = service.validate_key(api_key)
    
    if not key_record:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid or expired API key",
            headers={"WWW-Authenticate": "ApiKey"}
        )
    
    return key_record.user_id, key_record


def require_scope(required_scope: APIKeyScope):
    """Dependency factory for scope checking."""
    
    async def check_scope(
        auth: tuple[str, APIKey] = Depends(get_api_key_user)
    ) -> str:
        user_id, api_key = auth
        
        if not api_key.has_scope(required_scope):
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail=f"API key missing required scope: {required_scope.value}"
            )
        
        return user_id
    
    return check_scope


# Convenience dependencies
require_read = require_scope(APIKeyScope.READ)
require_write = require_scope(APIKeyScope.WRITE)
require_admin = require_scope(APIKeyScope.ADMIN)
```

### 6. Hybrid Authentication (JWT or API Key)

**auth/hybrid_auth.py:**
```python
"""Support both JWT and API key authentication."""
from fastapi import Request, Depends, HTTPException, status
from fastapi.security import HTTPBearer, APIKeyHeader
from sqlalchemy.orm import Session

from database import get_db
from auth import get_current_user_optional
from auth.api_key_auth import get_api_key_user
from models.user import User
from models.api_key import APIKeyScope

http_bearer = HTTPBearer(auto_error=False)
api_key_header = APIKeyHeader(name="X-API-Key", auto_error=False)


async def get_current_user_or_api_key(
    request: Request,
    bearer_token: str = Depends(http_bearer),
    api_key: str = Depends(api_key_header),
    db: Session = Depends(get_db)
) -> tuple[str, str]:
    """Get user from either JWT or API key.
    
    Returns:
        Tuple of (user_id, auth_type) where auth_type is "jwt" or "api_key"
    """
    # Try JWT first
    if bearer_token:
        user = await get_current_user_optional(bearer_token.credentials, db)
        if user:
            return user.id, "jwt"
    
    # Try API key
    if api_key:
        user_id, _ = await get_api_key_user(api_key, db)
        return user_id, "api_key"
    
    raise HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Authentication required (JWT or API key)",
        headers={"WWW-Authenticate": "Bearer, ApiKey"}
    )
```

## File Structure
```
backend/
├── models/
│   └── api_key.py
├── schemas/
│   └── api_key.py
├── services/
│   └── api_key_service.py
├── routers/
│   └── api_keys.py
└── auth/
    ├── api_key_auth.py
    └── hybrid_auth.py
```

## Validation Gates

### Gate 1: Key Generation
```python
def test_api_key_generation():
    """Verify key generation and one-time display."""
    # Create key
    response = client.post("/api/v1/api-keys", json={
        "name": "Test Key",
        "scopes": ["read", "write"]
    }, headers=auth_headers)
    
    assert response.status_code == 201
    data = response.json()
    
    # Full key returned on creation
    assert data["key"].startswith("cs_live_")
    assert len(data["key"]) == 76  # cs_live_ + 64 hex chars
    
    # Subsequent GET doesn't show full key
    get_response = client.get(f"/api/v1/api-keys/{data['id']}", headers=auth_headers)
    assert "key" not in get_response.json()
```

### Gate 2: Key Authentication
```python
def test_api_key_authentication():
    """Verify API key can be used for authentication."""
    # Create key with write scope
    create_resp = client.post("/api/v1/api-keys", json={
        "name": "Write Key",
        "scopes": ["write"]
    }, headers=auth_headers)
    api_key = create_resp.json()["key"]
    
    # Use key to create story
    story_resp = client.post("/api/v1/stories", json={
        "repo_url": "https://github.com/test/repo"
    }, headers={"X-API-Key": api_key})
    
    assert story_resp.status_code == 201
```

### Gate 3: Scope Enforcement
```python
def test_scope_enforcement():
    """Verify scope restrictions are enforced."""
    # Create read-only key
    create_resp = client.post("/api/v1/api-keys", json={
        "name": "Read Key",
        "scopes": ["read"]
    }, headers=auth_headers)
    api_key = create_resp.json()["key"]
    
    # Try to create story (requires write)
    story_resp = client.post("/api/v1/stories", json={
        "repo_url": "https://github.com/test/repo"
    }, headers={"X-API-Key": api_key})
    
    assert story_resp.status_code == 403
    assert "missing required scope" in story_resp.json()["detail"]
```

### Gate 4: Key Revocation
```python
def test_key_revocation():
    """Verify revoked keys are rejected."""
    # Create and revoke key
    create_resp = client.post("/api/v1/api-keys", json={
        "name": "Temp Key",
        "scopes": ["read"]
    }, headers=auth_headers)
    key_id = create_resp.json()["id"]
    api_key = create_resp.json()["key"]
    
    # Revoke
    client.delete(f"/api/v1/api-keys/{key_id}", headers=auth_headers)
    
    # Try to use revoked key
    response = client.get("/api/v1/stories", headers={"X-API-Key": api_key})
    assert response.status_code == 401
```

## Security Considerations

1. **Key Storage**: Only SHA-256 hash stored, never plain key
2. **One-Time Display**: Full key only shown on creation
3. **Prefix for Identification**: Key prefix allows identification without full key
4. **Scope Limitation**: Principle of least privilege
5. **Expiration Support**: Optional automatic expiration
6. **Rate Limiting**: Per-key rate limits (see Plan 10-02)
7. **Audit Trail**: Request count and last used tracking

## Definition of Done
- [ ] API key model with secure hash storage
- [ ] Key generation returns key only once
- [ ] CRUD operations for key management
- [ ] Scope-based authorization working
- [ ] API key authentication middleware
- [ ] Hybrid JWT/API key authentication
- [ ] Key revocation with cache invalidation
- [ ] All validation gates passing
