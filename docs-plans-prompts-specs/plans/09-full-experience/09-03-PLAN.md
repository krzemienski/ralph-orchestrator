---
phase: 09-full-experience
plan: 03
type: execute
domain: voice-synthesis
---

<objective>
Implement voice selection interface with audio preview functionality using ElevenLabs voice library.
</objective>

<context>
@BRIEF.md
@plans/05-voice-director/05-02-PLAN.md
</context>

<tasks>

<task type="auto">
  <n>Task 1: Create voice catalog API with preview support</n>
  <files>codestory/backend/routers/voices.py, codestory/backend/services/voice_service.py</files>
  <action>
Create services/voice_service.py:

```python
"""
Voice service for ElevenLabs integration and voice catalog management.
"""

import httpx
from typing import Optional
from functools import lru_cache
from pydantic import BaseModel

from config import settings


class VoiceInfo(BaseModel):
    """Voice metadata from ElevenLabs."""
    voice_id: str
    name: str
    category: str  # premade, cloned, professional
    description: Optional[str] = None
    preview_url: Optional[str] = None
    labels: dict = {}
    
    @property
    def accent(self) -> Optional[str]:
        return self.labels.get("accent")
    
    @property
    def age(self) -> Optional[str]:
        return self.labels.get("age")
    
    @property
    def gender(self) -> Optional[str]:
        return self.labels.get("gender")
    
    @property
    def use_case(self) -> Optional[str]:
        return self.labels.get("use_case")


# Curated voices for code narratives
RECOMMENDED_VOICES = {
    "documentary": ["Antoni", "Josh", "Rachel"],
    "tutorial": ["Bella", "Elli", "Josh"],
    "fiction": ["Adam", "Nicole", "Sam"],
    "podcast": ["Josh", "Rachel", "Domi"],
    "technical": ["Antoni", "Arnold", "Daniel"],
}


class VoiceService:
    """Service for voice catalog and preview management."""
    
    def __init__(self):
        self.api_key = settings.ELEVENLABS_API_KEY
        self.base_url = "https://api.elevenlabs.io/v1"
        self._voices_cache: Optional[list[VoiceInfo]] = None
    
    async def get_voices(self, refresh: bool = False) -> list[VoiceInfo]:
        """Fetch available voices from ElevenLabs."""
        if self._voices_cache and not refresh:
            return self._voices_cache
            
        async with httpx.AsyncClient() as client:
            response = await client.get(
                f"{self.base_url}/voices",
                headers={"xi-api-key": self.api_key}
            )
            response.raise_for_status()
            data = response.json()
        
        voices = []
        for voice_data in data.get("voices", []):
            voices.append(VoiceInfo(
                voice_id=voice_data["voice_id"],
                name=voice_data["name"],
                category=voice_data.get("category", "premade"),
                description=voice_data.get("description"),
                preview_url=voice_data.get("preview_url"),
                labels=voice_data.get("labels", {}),
            ))
        
        self._voices_cache = voices
        return voices
    
    async def get_voice(self, voice_id: str) -> Optional[VoiceInfo]:
        """Get a specific voice by ID."""
        voices = await self.get_voices()
        return next((v for v in voices if v.voice_id == voice_id), None)
    
    async def generate_preview(
        self, 
        voice_id: str, 
        text: Optional[str] = None
    ) -> bytes:
        """Generate a short audio preview with the selected voice."""
        preview_text = text or (
            "Welcome to Code Story. I'll be your guide through this "
            "repository's architecture and design patterns."
        )
        
        async with httpx.AsyncClient() as client:
            response = await client.post(
                f"{self.base_url}/text-to-speech/{voice_id}",
                headers={
                    "xi-api-key": self.api_key,
                    "Content-Type": "application/json",
                },
                json={
                    "text": preview_text,
                    "model_id": "eleven_multilingual_v2",
                    "voice_settings": {
                        "stability": 0.5,
                        "similarity_boost": 0.75,
                    }
                },
                timeout=30.0
            )
            response.raise_for_status()
            return response.content
    
    def get_recommended_voices(self, style: str) -> list[str]:
        """Get recommended voice names for a narrative style."""
        return RECOMMENDED_VOICES.get(style, RECOMMENDED_VOICES["documentary"])
    
    async def get_voices_for_style(self, style: str) -> list[VoiceInfo]:
        """Get full voice info for recommended voices."""
        recommended_names = self.get_recommended_voices(style)
        all_voices = await self.get_voices()
        return [v for v in all_voices if v.name in recommended_names]


# Singleton instance
voice_service = VoiceService()
```

Create routers/voices.py:

```python
"""
Voice catalog and preview API endpoints.
"""

from fastapi import APIRouter, HTTPException, Query
from fastapi.responses import StreamingResponse
from typing import Optional
import io

from services.voice_service import voice_service


router = APIRouter(prefix="/voices", tags=["voices"])


@router.get("")
async def list_voices(
    style: Optional[str] = Query(None, description="Filter by narrative style"),
    category: Optional[str] = Query(None, description="Filter by voice category"),
):
    """List available voices with optional filtering."""
    voices = await voice_service.get_voices()
    
    if style:
        recommended = voice_service.get_recommended_voices(style)
        # Put recommended voices first, then others
        voices = sorted(
            voices,
            key=lambda v: (v.name not in recommended, v.name)
        )
    
    if category:
        voices = [v for v in voices if v.category == category]
    
    return {
        "voices": [
            {
                "voice_id": v.voice_id,
                "name": v.name,
                "category": v.category,
                "description": v.description,
                "preview_url": v.preview_url,
                "accent": v.accent,
                "age": v.age,
                "gender": v.gender,
                "use_case": v.use_case,
                "recommended_for": [
                    style for style, names in voice_service.RECOMMENDED_VOICES.items()
                    if v.name in names
                ]
            }
            for v in voices
        ]
    }


@router.get("/recommended")
async def get_recommended_voices(
    style: str = Query(..., description="Narrative style"),
):
    """Get recommended voices for a specific narrative style."""
    voices = await voice_service.get_voices_for_style(style)
    
    return {
        "style": style,
        "voices": [
            {
                "voice_id": v.voice_id,
                "name": v.name,
                "description": v.description,
                "preview_url": v.preview_url,
                "accent": v.accent,
                "gender": v.gender,
            }
            for v in voices
        ]
    }


@router.get("/{voice_id}")
async def get_voice(voice_id: str):
    """Get details for a specific voice."""
    voice = await voice_service.get_voice(voice_id)
    if not voice:
        raise HTTPException(status_code=404, detail="Voice not found")
    
    return {
        "voice": {
            "voice_id": voice.voice_id,
            "name": voice.name,
            "category": voice.category,
            "description": voice.description,
            "preview_url": voice.preview_url,
            "labels": voice.labels,
        }
    }


@router.post("/{voice_id}/preview")
async def generate_preview(
    voice_id: str,
    text: Optional[str] = Query(None, max_length=500),
):
    """Generate a custom audio preview for a voice."""
    try:
        audio_data = await voice_service.generate_preview(voice_id, text)
        return StreamingResponse(
            io.BytesIO(audio_data),
            media_type="audio/mpeg",
            headers={"Content-Disposition": f"inline; filename=preview_{voice_id}.mp3"}
        )
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Preview generation failed: {str(e)}")
```
  </action>
  <verify>cd codestory/backend && python -c "from routers.voices import router; print('OK')"</verify>
  <done>Voice catalog API created</done>
</task>

<task type="auto">
  <n>Task 2: Create voice selector UI component</n>
  <files>codestory/frontend/src/components/stories/VoiceSelector.tsx</files>
  <action>
Create src/components/stories/VoiceSelector.tsx:

```typescript
import { useState, useEffect, useRef } from 'react'
import { Play, Pause, Volume2, Check, Star } from 'lucide-react'
import { Button } from '@/components/ui/button'
import { Card } from '@/components/ui/card'
import { Badge } from '@/components/ui/badge'
import { ScrollArea } from '@/components/ui/scroll-area'
import { api } from '@/lib/api'

interface Voice {
  voice_id: string
  name: string
  category: string
  description?: string
  preview_url?: string
  accent?: string
  gender?: string
  recommended_for: string[]
}

interface VoiceSelectorProps {
  selectedVoiceId?: string
  narrativeStyle?: string
  onSelect: (voiceId: string) => void
}

export function VoiceSelector({ 
  selectedVoiceId, 
  narrativeStyle,
  onSelect 
}: VoiceSelectorProps) {
  const [voices, setVoices] = useState<Voice[]>([])
  const [loading, setLoading] = useState(true)
  const [playingId, setPlayingId] = useState<string | null>(null)
  const [generatingPreview, setGeneratingPreview] = useState<string | null>(null)
  const audioRef = useRef<HTMLAudioElement | null>(null)

  useEffect(() => {
    fetchVoices()
  }, [narrativeStyle])

  async function fetchVoices() {
    setLoading(true)
    try {
      const params = narrativeStyle ? `?style=${narrativeStyle}` : ''
      const response = await api.get(`/voices${params}`)
      setVoices(response.data.voices)
    } catch (error) {
      console.error('Failed to fetch voices:', error)
    } finally {
      setLoading(false)
    }
  }

  async function playPreview(voice: Voice) {
    // Stop any currently playing audio
    if (audioRef.current) {
      audioRef.current.pause()
      audioRef.current = null
    }

    if (playingId === voice.voice_id) {
      setPlayingId(null)
      return
    }

    let audioUrl = voice.preview_url

    // Generate custom preview if no URL available
    if (!audioUrl) {
      setGeneratingPreview(voice.voice_id)
      try {
        const response = await api.post(
          `/voices/${voice.voice_id}/preview`,
          null,
          { responseType: 'blob' }
        )
        audioUrl = URL.createObjectURL(response.data)
      } catch (error) {
        console.error('Failed to generate preview:', error)
        setGeneratingPreview(null)
        return
      }
      setGeneratingPreview(null)
    }

    const audio = new Audio(audioUrl)
    audioRef.current = audio
    
    audio.onended = () => {
      setPlayingId(null)
    }
    
    audio.onerror = () => {
      setPlayingId(null)
    }

    setPlayingId(voice.voice_id)
    audio.play()
  }

  // Cleanup on unmount
  useEffect(() => {
    return () => {
      if (audioRef.current) {
        audioRef.current.pause()
      }
    }
  }, [])

  if (loading) {
    return (
      <div className="flex items-center justify-center py-8">
        <div className="animate-spin w-6 h-6 border-2 border-primary border-t-transparent rounded-full" />
      </div>
    )
  }

  const recommendedVoices = voices.filter(v => 
    narrativeStyle && v.recommended_for.includes(narrativeStyle)
  )
  const otherVoices = voices.filter(v => 
    !narrativeStyle || !v.recommended_for.includes(narrativeStyle)
  )

  return (
    <div className="space-y-6">
      {recommendedVoices.length > 0 && (
        <div>
          <div className="flex items-center gap-2 mb-3">
            <Star className="w-4 h-4 text-yellow-500" />
            <h4 className="font-medium">Recommended for {narrativeStyle}</h4>
          </div>
          <div className="grid grid-cols-1 md:grid-cols-2 gap-3">
            {recommendedVoices.map(voice => (
              <VoiceCard
                key={voice.voice_id}
                voice={voice}
                isSelected={selectedVoiceId === voice.voice_id}
                isPlaying={playingId === voice.voice_id}
                isGenerating={generatingPreview === voice.voice_id}
                onSelect={() => onSelect(voice.voice_id)}
                onPlay={() => playPreview(voice)}
              />
            ))}
          </div>
        </div>
      )}

      <div>
        <h4 className="font-medium mb-3">All Voices</h4>
        <ScrollArea className="h-[400px]">
          <div className="grid grid-cols-1 md:grid-cols-2 gap-3 pr-4">
            {otherVoices.map(voice => (
              <VoiceCard
                key={voice.voice_id}
                voice={voice}
                isSelected={selectedVoiceId === voice.voice_id}
                isPlaying={playingId === voice.voice_id}
                isGenerating={generatingPreview === voice.voice_id}
                onSelect={() => onSelect(voice.voice_id)}
                onPlay={() => playPreview(voice)}
              />
            ))}
          </div>
        </ScrollArea>
      </div>
    </div>
  )
}

function VoiceCard({
  voice,
  isSelected,
  isPlaying,
  isGenerating,
  onSelect,
  onPlay,
}: {
  voice: Voice
  isSelected: boolean
  isPlaying: boolean
  isGenerating: boolean
  onSelect: () => void
  onPlay: () => void
}) {
  return (
    <Card 
      className={`p-4 cursor-pointer transition-all ${
        isSelected 
          ? 'ring-2 ring-primary bg-primary/5' 
          : 'hover:bg-muted/50'
      }`}
      onClick={onSelect}
    >
      <div className="flex items-start justify-between">
        <div className="flex-1">
          <div className="flex items-center gap-2">
            <span className="font-medium">{voice.name}</span>
            {isSelected && (
              <Check className="w-4 h-4 text-primary" />
            )}
          </div>
          <div className="flex items-center gap-2 mt-1">
            {voice.gender && (
              <Badge variant="secondary" className="text-xs">
                {voice.gender}
              </Badge>
            )}
            {voice.accent && (
              <Badge variant="outline" className="text-xs">
                {voice.accent}
              </Badge>
            )}
          </div>
          {voice.description && (
            <p className="text-sm text-muted-foreground mt-2 line-clamp-2">
              {voice.description}
            </p>
          )}
        </div>

        <Button
          variant="ghost"
          size="icon"
          onClick={(e) => {
            e.stopPropagation()
            onPlay()
          }}
          disabled={isGenerating}
        >
          {isGenerating ? (
            <div className="animate-spin w-4 h-4 border-2 border-primary border-t-transparent rounded-full" />
          ) : isPlaying ? (
            <Pause className="w-4 h-4" />
          ) : (
            <Play className="w-4 h-4" />
          )}
        </Button>
      </div>
    </Card>
  )
}
```
  </action>
  <verify>cd codestory/frontend && npm run build</verify>
  <done>Voice selector UI created</done>
</task>

</tasks>

<playwright_validation_gate>
```
Playwright Action: Navigate to voice selection step in story creation
Expected: Voice list loads with recommendations highlighted

Playwright Action: Click play on voice preview
Expected: Audio preview plays

Playwright Action: Select a voice
Expected: Voice highlighted as selected, stored in story config

Playwright Action: Filter by narrative style
Expected: Recommended voices shown first
```
</playwright_validation_gate>
