---
phase: 09-full-experience
plan: 04
type: execute
domain: sharing
---

<objective>
Implement story sharing with public links, social sharing, and audio download functionality.
</objective>

<context>
@BRIEF.md
@plans/06-fastapi-backend/06-06-PLAN.md
</context>

<tasks>

<task type="auto">
  <n>Task 1: Create sharing API endpoints</n>
  <files>codestory/backend/routers/sharing.py</files>
  <action>
Create routers/sharing.py:

```python
"""
Story sharing and public access endpoints.
"""

import secrets
from datetime import datetime, timedelta
from fastapi import APIRouter, Depends, HTTPException, Query
from fastapi.responses import StreamingResponse, RedirectResponse
from pydantic import BaseModel
from typing import Optional
from uuid import UUID

from db.database import get_db
from db.models import Story, StoryShare
from auth.dependencies import get_current_user, get_optional_user
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from services.storage import storage_service


router = APIRouter(prefix="/stories/{story_id}/share", tags=["sharing"])


class ShareSettings(BaseModel):
    """Settings for creating a share link."""
    is_public: bool = True
    expires_in_days: Optional[int] = None  # None = never expires
    allow_download: bool = True
    password: Optional[str] = None


class ShareResponse(BaseModel):
    """Response with share link details."""
    share_id: str
    share_url: str
    is_public: bool
    allow_download: bool
    has_password: bool
    expires_at: Optional[datetime]


@router.post("")
async def create_share_link(
    story_id: UUID,
    settings: ShareSettings,
    db: AsyncSession = Depends(get_db),
    user = Depends(get_current_user),
) -> ShareResponse:
    """Create a shareable link for a story."""
    story = await db.get(Story, story_id)
    if not story or story.user_id != user.id:
        raise HTTPException(status_code=404, detail="Story not found")
    
    if story.status != "completed":
        raise HTTPException(
            status_code=400, 
            detail="Can only share completed stories"
        )
    
    # Generate unique share ID
    share_id = secrets.token_urlsafe(12)
    
    expires_at = None
    if settings.expires_in_days:
        expires_at = datetime.utcnow() + timedelta(days=settings.expires_in_days)
    
    share = StoryShare(
        story_id=story_id,
        share_id=share_id,
        is_public=settings.is_public,
        allow_download=settings.allow_download,
        password_hash=_hash_password(settings.password) if settings.password else None,
        expires_at=expires_at,
    )
    db.add(share)
    await db.commit()
    
    base_url = "https://codestory.app"  # From config
    share_url = f"{base_url}/s/{share_id}"
    
    return ShareResponse(
        share_id=share_id,
        share_url=share_url,
        is_public=settings.is_public,
        allow_download=settings.allow_download,
        has_password=settings.password is not None,
        expires_at=expires_at,
    )


@router.get("")
async def list_share_links(
    story_id: UUID,
    db: AsyncSession = Depends(get_db),
    user = Depends(get_current_user),
):
    """List all share links for a story."""
    story = await db.get(Story, story_id)
    if not story or story.user_id != user.id:
        raise HTTPException(status_code=404, detail="Story not found")
    
    result = await db.execute(
        select(StoryShare)
        .where(StoryShare.story_id == story_id)
        .order_by(StoryShare.created_at.desc())
    )
    shares = result.scalars().all()
    
    base_url = "https://codestory.app"
    return {
        "shares": [
            {
                "share_id": s.share_id,
                "share_url": f"{base_url}/s/{s.share_id}",
                "is_public": s.is_public,
                "allow_download": s.allow_download,
                "has_password": s.password_hash is not None,
                "expires_at": s.expires_at,
                "view_count": s.view_count,
                "created_at": s.created_at,
            }
            for s in shares
        ]
    }


@router.delete("/{share_id}")
async def revoke_share_link(
    story_id: UUID,
    share_id: str,
    db: AsyncSession = Depends(get_db),
    user = Depends(get_current_user),
):
    """Revoke a share link."""
    story = await db.get(Story, story_id)
    if not story or story.user_id != user.id:
        raise HTTPException(status_code=404, detail="Story not found")
    
    result = await db.execute(
        select(StoryShare)
        .where(StoryShare.share_id == share_id)
        .where(StoryShare.story_id == story_id)
    )
    share = result.scalar_one_or_none()
    
    if not share:
        raise HTTPException(status_code=404, detail="Share link not found")
    
    await db.delete(share)
    await db.commit()
    return {"success": True}


# Public share access router
public_router = APIRouter(prefix="/s", tags=["public"])


@public_router.get("/{share_id}")
async def get_shared_story(
    share_id: str,
    password: Optional[str] = Query(None),
    db: AsyncSession = Depends(get_db),
):
    """Access a shared story via public link."""
    result = await db.execute(
        select(StoryShare).where(StoryShare.share_id == share_id)
    )
    share = result.scalar_one_or_none()
    
    if not share:
        raise HTTPException(status_code=404, detail="Share link not found")
    
    # Check expiration
    if share.expires_at and share.expires_at < datetime.utcnow():
        raise HTTPException(status_code=410, detail="Share link has expired")
    
    # Check password
    if share.password_hash:
        if not password or not _verify_password(password, share.password_hash):
            raise HTTPException(status_code=401, detail="Password required")
    
    # Increment view count
    share.view_count += 1
    
    # Fetch story details
    story = await db.get(Story, share.story_id)
    await db.commit()
    
    return {
        "story": {
            "id": str(story.id),
            "title": story.title,
            "repository_url": story.repository_url,
            "total_duration_seconds": story.total_duration_seconds,
            "narrative_style": story.narrative_style,
        },
        "chapters": [
            {
                "id": str(ch.id),
                "title": ch.title,
                "order": ch.order,
                "duration_seconds": ch.duration_seconds,
                "audio_url": ch.audio_url if share.is_public else None,
            }
            for ch in sorted(story.chapters, key=lambda c: c.order)
        ],
        "allow_download": share.allow_download,
    }


@public_router.get("/{share_id}/download")
async def download_shared_story(
    share_id: str,
    password: Optional[str] = Query(None),
    db: AsyncSession = Depends(get_db),
):
    """Download combined audio for a shared story."""
    result = await db.execute(
        select(StoryShare).where(StoryShare.share_id == share_id)
    )
    share = result.scalar_one_or_none()
    
    if not share:
        raise HTTPException(status_code=404, detail="Share link not found")
    
    if not share.allow_download:
        raise HTTPException(status_code=403, detail="Download not allowed")
    
    if share.expires_at and share.expires_at < datetime.utcnow():
        raise HTTPException(status_code=410, detail="Share link has expired")
    
    if share.password_hash:
        if not password or not _verify_password(password, share.password_hash):
            raise HTTPException(status_code=401, detail="Password required")
    
    story = await db.get(Story, share.story_id)
    
    # Get combined audio file
    if story.combined_audio_url:
        return RedirectResponse(url=story.combined_audio_url)
    
    # Generate combined audio on-demand
    audio_stream = await storage_service.get_combined_audio(story.id)
    return StreamingResponse(
        audio_stream,
        media_type="audio/mpeg",
        headers={
            "Content-Disposition": f'attachment; filename="{story.title}.mp3"'
        }
    )


def _hash_password(password: str) -> str:
    """Hash a share password."""
    import bcrypt
    return bcrypt.hashpw(password.encode(), bcrypt.gensalt()).decode()


def _verify_password(password: str, hashed: str) -> bool:
    """Verify a share password."""
    import bcrypt
    return bcrypt.checkpw(password.encode(), hashed.encode())
```
  </action>
  <verify>cd codestory/backend && python -c "from routers.sharing import router; print('OK')"</verify>
  <done>Sharing API created</done>
</task>

<task type="auto">
  <n>Task 2: Create sharing UI components</n>
  <files>codestory/frontend/src/components/stories/ShareDialog.tsx</files>
  <action>
Create src/components/stories/ShareDialog.tsx:

```typescript
import { useState, useEffect } from 'react'
import { Copy, Link, Twitter, Linkedin, Download, Lock, Calendar, Eye } from 'lucide-react'
import { Button } from '@/components/ui/button'
import { Input } from '@/components/ui/input'
import { Switch } from '@/components/ui/switch'
import { Label } from '@/components/ui/label'
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
} from '@/components/ui/dialog'
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select'
import { useToast } from '@/hooks/use-toast'
import { api } from '@/lib/api'

interface ShareLink {
  share_id: string
  share_url: string
  is_public: boolean
  allow_download: boolean
  has_password: boolean
  expires_at?: string
  view_count: number
  created_at: string
}

interface ShareDialogProps {
  storyId: string
  storyTitle: string
  open: boolean
  onClose: () => void
}

export function ShareDialog({ storyId, storyTitle, open, onClose }: ShareDialogProps) {
  const { toast } = useToast()
  const [shares, setShares] = useState<ShareLink[]>([])
  const [loading, setLoading] = useState(false)
  const [creating, setCreating] = useState(false)
  
  // New share settings
  const [allowDownload, setAllowDownload] = useState(true)
  const [expiresIn, setExpiresIn] = useState<string>('never')
  const [password, setPassword] = useState('')
  const [usePassword, setUsePassword] = useState(false)

  useEffect(() => {
    if (open) {
      fetchShares()
    }
  }, [open, storyId])

  async function fetchShares() {
    setLoading(true)
    try {
      const response = await api.get(`/stories/${storyId}/share`)
      setShares(response.data.shares)
    } catch (error) {
      console.error('Failed to fetch shares:', error)
    } finally {
      setLoading(false)
    }
  }

  async function createShare() {
    setCreating(true)
    try {
      const response = await api.post(`/stories/${storyId}/share`, {
        is_public: true,
        allow_download: allowDownload,
        expires_in_days: expiresIn === 'never' ? null : parseInt(expiresIn),
        password: usePassword ? password : null,
      })
      
      setShares([response.data, ...shares])
      copyToClipboard(response.data.share_url)
      
      // Reset form
      setAllowDownload(true)
      setExpiresIn('never')
      setPassword('')
      setUsePassword(false)
    } catch (error) {
      toast({
        title: 'Failed to create share link',
        variant: 'destructive',
      })
    } finally {
      setCreating(false)
    }
  }

  async function revokeShare(shareId: string) {
    try {
      await api.delete(`/stories/${storyId}/share/${shareId}`)
      setShares(shares.filter(s => s.share_id !== shareId))
      toast({ title: 'Share link revoked' })
    } catch (error) {
      toast({
        title: 'Failed to revoke link',
        variant: 'destructive',
      })
    }
  }

  function copyToClipboard(url: string) {
    navigator.clipboard.writeText(url)
    toast({ title: 'Link copied to clipboard!' })
  }

  function shareToTwitter(url: string) {
    const text = `Check out this Code Story about ${storyTitle}!`
    window.open(
      `https://twitter.com/intent/tweet?text=${encodeURIComponent(text)}&url=${encodeURIComponent(url)}`,
      '_blank'
    )
  }

  function shareToLinkedIn(url: string) {
    window.open(
      `https://www.linkedin.com/sharing/share-offsite/?url=${encodeURIComponent(url)}`,
      '_blank'
    )
  }

  return (
    <Dialog open={open} onOpenChange={(o) => !o && onClose()}>
      <DialogContent className="max-w-lg">
        <DialogHeader>
          <DialogTitle>Share Story</DialogTitle>
        </DialogHeader>

        <div className="space-y-6 py-4">
          {/* Create new share */}
          <div className="space-y-4 p-4 bg-muted/50 rounded-lg">
            <h4 className="font-medium">Create Share Link</h4>
            
            <div className="flex items-center justify-between">
              <Label htmlFor="download" className="flex items-center gap-2">
                <Download className="w-4 h-4" />
                Allow download
              </Label>
              <Switch
                id="download"
                checked={allowDownload}
                onCheckedChange={setAllowDownload}
              />
            </div>

            <div className="flex items-center justify-between">
              <Label className="flex items-center gap-2">
                <Calendar className="w-4 h-4" />
                Expires
              </Label>
              <Select value={expiresIn} onValueChange={setExpiresIn}>
                <SelectTrigger className="w-32">
                  <SelectValue />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="never">Never</SelectItem>
                  <SelectItem value="1">1 day</SelectItem>
                  <SelectItem value="7">7 days</SelectItem>
                  <SelectItem value="30">30 days</SelectItem>
                </SelectContent>
              </Select>
            </div>

            <div className="flex items-center justify-between">
              <Label htmlFor="password" className="flex items-center gap-2">
                <Lock className="w-4 h-4" />
                Password protect
              </Label>
              <Switch
                id="password"
                checked={usePassword}
                onCheckedChange={setUsePassword}
              />
            </div>

            {usePassword && (
              <Input
                type="password"
                placeholder="Enter password"
                value={password}
                onChange={(e) => setPassword(e.target.value)}
              />
            )}

            <Button 
              className="w-full" 
              onClick={createShare}
              disabled={creating || (usePassword && !password)}
            >
              <Link className="w-4 h-4 mr-2" />
              {creating ? 'Creating...' : 'Create Link'}
            </Button>
          </div>

          {/* Existing shares */}
          {shares.length > 0 && (
            <div className="space-y-3">
              <h4 className="font-medium">Active Links</h4>
              {shares.map(share => (
                <div 
                  key={share.share_id}
                  className="flex items-center gap-2 p-3 border rounded-lg"
                >
                  <div className="flex-1 min-w-0">
                    <div className="flex items-center gap-2">
                      <code className="text-sm truncate">{share.share_url}</code>
                      {share.has_password && <Lock className="w-3 h-3 text-muted-foreground" />}
                    </div>
                    <div className="flex items-center gap-3 mt-1 text-xs text-muted-foreground">
                      <span className="flex items-center gap-1">
                        <Eye className="w-3 h-3" />
                        {share.view_count} views
                      </span>
                      {share.expires_at && (
                        <span>
                          Expires {new Date(share.expires_at).toLocaleDateString()}
                        </span>
                      )}
                    </div>
                  </div>
                  
                  <div className="flex items-center gap-1">
                    <Button
                      variant="ghost"
                      size="icon"
                      onClick={() => copyToClipboard(share.share_url)}
                    >
                      <Copy className="w-4 h-4" />
                    </Button>
                    <Button
                      variant="ghost"
                      size="icon"
                      onClick={() => shareToTwitter(share.share_url)}
                    >
                      <Twitter className="w-4 h-4" />
                    </Button>
                    <Button
                      variant="ghost"
                      size="icon"
                      onClick={() => shareToLinkedIn(share.share_url)}
                    >
                      <Linkedin className="w-4 h-4" />
                    </Button>
                    <Button
                      variant="ghost"
                      size="sm"
                      onClick={() => revokeShare(share.share_id)}
                    >
                      Revoke
                    </Button>
                  </div>
                </div>
              ))}
            </div>
          )}
        </div>
      </DialogContent>
    </Dialog>
  )
}
```
  </action>
  <verify>cd codestory/frontend && npm run build</verify>
  <done>Sharing UI created</done>
</task>

</tasks>

<playwright_validation_gate>
```
Playwright Action: Open share dialog for completed story
Expected: Share creation form displayed

Playwright Action: Create share link with download enabled
Expected: Link created, copied to clipboard

Playwright Action: Access shared story via public URL
Expected: Story plays without authentication

Playwright Action: Create password-protected share
Expected: Password required to access
```
</playwright_validation_gate>
