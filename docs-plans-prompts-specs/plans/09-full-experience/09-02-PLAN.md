---
phase: 09-full-experience
plan: 02
type: execute
domain: user-experience
---

<objective>
Implement full conversational onboarding flow with chapter preview and editing capabilities for custom story mode.
</objective>

<context>
@BRIEF.md
@plans/02-intent-agent/02-04-PLAN.md
@plans/09-full-experience/09-01-PLAN.md
</context>

<tasks>

<task type="auto">
  <n>Task 1: Create chapter editing API endpoints</n>
  <files>codestory/backend/routers/chapters.py</files>
  <action>
Create routers/chapters.py:

```python
"""
Chapter management endpoints for story customization.
"""

from fastapi import APIRouter, Depends, HTTPException
from pydantic import BaseModel, Field
from typing import Optional
from uuid import UUID

from db.database import get_db
from db.models import Story, StoryChapter
from auth.dependencies import get_current_user
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select


router = APIRouter(prefix="/stories/{story_id}/chapters", tags=["chapters"])


class ChapterUpdate(BaseModel):
    """Request body for updating a chapter."""
    title: Optional[str] = Field(None, max_length=200)
    focus_description: Optional[str] = Field(None, max_length=1000)
    duration_minutes: Optional[int] = Field(None, ge=1, le=30)
    order: Optional[int] = Field(None, ge=0)
    include_code_samples: Optional[bool] = None
    depth_level: Optional[str] = Field(None, pattern="^(overview|moderate|deep)$")


class ChapterCreate(BaseModel):
    """Request body for creating a new chapter."""
    title: str = Field(..., max_length=200)
    focus_description: str = Field(..., max_length=1000)
    duration_minutes: int = Field(5, ge=1, le=30)
    order: int = Field(..., ge=0)
    include_code_samples: bool = True
    depth_level: str = Field("moderate", pattern="^(overview|moderate|deep)$")


class ChapterReorder(BaseModel):
    """Request body for reordering chapters."""
    chapter_ids: list[UUID]


@router.get("")
async def list_chapters(
    story_id: UUID,
    db: AsyncSession = Depends(get_db),
    user = Depends(get_current_user),
):
    """List all chapters for a story."""
    story = await db.get(Story, story_id)
    if not story or story.user_id != user.id:
        raise HTTPException(status_code=404, detail="Story not found")

    result = await db.execute(
        select(StoryChapter)
        .where(StoryChapter.story_id == story_id)
        .order_by(StoryChapter.order)
    )
    chapters = result.scalars().all()

    return {
        "chapters": [
            {
                "id": str(ch.id),
                "title": ch.title,
                "focus_description": ch.focus_description,
                "duration_minutes": ch.duration_seconds // 60 if ch.duration_seconds else 5,
                "order": ch.order,
                "include_code_samples": ch.metadata.get("include_code_samples", True),
                "depth_level": ch.metadata.get("depth_level", "moderate"),
                "status": ch.status,
            }
            for ch in chapters
        ]
    }


@router.post("")
async def create_chapter(
    story_id: UUID,
    chapter_data: ChapterCreate,
    db: AsyncSession = Depends(get_db),
    user = Depends(get_current_user),
):
    """Create a new chapter for a story."""
    story = await db.get(Story, story_id)
    if not story or story.user_id != user.id:
        raise HTTPException(status_code=404, detail="Story not found")

    if story.status not in ["draft", "planning"]:
        raise HTTPException(
            status_code=400,
            detail="Cannot add chapters after story generation has started"
        )

    # Shift existing chapters if needed
    result = await db.execute(
        select(StoryChapter)
        .where(StoryChapter.story_id == story_id)
        .where(StoryChapter.order >= chapter_data.order)
    )
    chapters_to_shift = result.scalars().all()
    for ch in chapters_to_shift:
        ch.order += 1

    chapter = StoryChapter(
        story_id=story_id,
        title=chapter_data.title,
        focus_description=chapter_data.focus_description,
        duration_seconds=chapter_data.duration_minutes * 60,
        order=chapter_data.order,
        metadata={
            "include_code_samples": chapter_data.include_code_samples,
            "depth_level": chapter_data.depth_level,
        },
        status="draft",
    )
    db.add(chapter)
    await db.commit()
    await db.refresh(chapter)

    return {"chapter": {"id": str(chapter.id), "title": chapter.title}}


@router.patch("/{chapter_id}")
async def update_chapter(
    story_id: UUID,
    chapter_id: UUID,
    update_data: ChapterUpdate,
    db: AsyncSession = Depends(get_db),
    user = Depends(get_current_user),
):
    """Update a chapter's details."""
    story = await db.get(Story, story_id)
    if not story or story.user_id != user.id:
        raise HTTPException(status_code=404, detail="Story not found")

    chapter = await db.get(StoryChapter, chapter_id)
    if not chapter or chapter.story_id != story_id:
        raise HTTPException(status_code=404, detail="Chapter not found")

    if story.status not in ["draft", "planning"]:
        raise HTTPException(
            status_code=400,
            detail="Cannot modify chapters after generation has started"
        )

    update_dict = update_data.model_dump(exclude_unset=True)
    
    for field, value in update_dict.items():
        if field == "duration_minutes":
            chapter.duration_seconds = value * 60
        elif field in ["include_code_samples", "depth_level"]:
            chapter.metadata[field] = value
        elif hasattr(chapter, field):
            setattr(chapter, field, value)

    await db.commit()
    return {"success": True}


@router.delete("/{chapter_id}")
async def delete_chapter(
    story_id: UUID,
    chapter_id: UUID,
    db: AsyncSession = Depends(get_db),
    user = Depends(get_current_user),
):
    """Delete a chapter."""
    story = await db.get(Story, story_id)
    if not story or story.user_id != user.id:
        raise HTTPException(status_code=404, detail="Story not found")

    chapter = await db.get(StoryChapter, chapter_id)
    if not chapter or chapter.story_id != story_id:
        raise HTTPException(status_code=404, detail="Chapter not found")

    if story.status not in ["draft", "planning"]:
        raise HTTPException(
            status_code=400,
            detail="Cannot delete chapters after generation has started"
        )

    deleted_order = chapter.order
    await db.delete(chapter)

    # Reorder remaining chapters
    result = await db.execute(
        select(StoryChapter)
        .where(StoryChapter.story_id == story_id)
        .where(StoryChapter.order > deleted_order)
    )
    for ch in result.scalars().all():
        ch.order -= 1

    await db.commit()
    return {"success": True}


@router.post("/reorder")
async def reorder_chapters(
    story_id: UUID,
    reorder_data: ChapterReorder,
    db: AsyncSession = Depends(get_db),
    user = Depends(get_current_user),
):
    """Reorder chapters by providing new order of IDs."""
    story = await db.get(Story, story_id)
    if not story or story.user_id != user.id:
        raise HTTPException(status_code=404, detail="Story not found")

    if story.status not in ["draft", "planning"]:
        raise HTTPException(
            status_code=400,
            detail="Cannot reorder chapters after generation has started"
        )

    for index, chapter_id in enumerate(reorder_data.chapter_ids):
        chapter = await db.get(StoryChapter, chapter_id)
        if chapter and chapter.story_id == story_id:
            chapter.order = index

    await db.commit()
    return {"success": True}
```
  </action>
  <verify>cd codestory/backend && python -c "from routers.chapters import router; print('OK')"</verify>
  <done>Chapter editing API created</done>
</task>

<task type="auto">
  <n>Task 2: Create chapter editor UI components</n>
  <files>codestory/frontend/src/components/stories/ChapterEditor.tsx</files>
  <action>
Create src/components/stories/ChapterEditor.tsx:

```typescript
import { useState } from 'react'
import { DragDropContext, Droppable, Draggable, DropResult } from '@hello-pangea/dnd'
import { 
  GripVertical, 
  Pencil, 
  Trash2, 
  Plus, 
  Clock, 
  ChevronDown,
  ChevronUp,
  Save 
} from 'lucide-react'
import { Button } from '@/components/ui/button'
import { Input } from '@/components/ui/input'
import { Textarea } from '@/components/ui/textarea'
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select'
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from '@/components/ui/dialog'
import { api } from '@/lib/api'

interface Chapter {
  id: string
  title: string
  focus_description: string
  duration_minutes: number
  order: number
  include_code_samples: boolean
  depth_level: 'overview' | 'moderate' | 'deep'
}

interface ChapterEditorProps {
  storyId: string
  chapters: Chapter[]
  onUpdate: () => void
  readonly?: boolean
}

export function ChapterEditor({ storyId, chapters, onUpdate, readonly }: ChapterEditorProps) {
  const [editingId, setEditingId] = useState<string | null>(null)
  const [isAddingNew, setIsAddingNew] = useState(false)
  const [expandedId, setExpandedId] = useState<string | null>(null)

  async function handleDragEnd(result: DropResult) {
    if (!result.destination || readonly) return

    const newOrder = Array.from(chapters)
    const [moved] = newOrder.splice(result.source.index, 1)
    newOrder.splice(result.destination.index, 0, moved)

    const orderedIds = newOrder.map(ch => ch.id)
    
    try {
      await api.post(`/stories/${storyId}/chapters/reorder`, {
        chapter_ids: orderedIds
      })
      onUpdate()
    } catch (error) {
      console.error('Failed to reorder chapters:', error)
    }
  }

  async function handleDelete(chapterId: string) {
    if (!confirm('Delete this chapter?')) return

    try {
      await api.delete(`/stories/${storyId}/chapters/${chapterId}`)
      onUpdate()
    } catch (error) {
      console.error('Failed to delete chapter:', error)
    }
  }

  async function handleSave(chapterId: string, data: Partial<Chapter>) {
    try {
      await api.patch(`/stories/${storyId}/chapters/${chapterId}`, data)
      setEditingId(null)
      onUpdate()
    } catch (error) {
      console.error('Failed to update chapter:', error)
    }
  }

  async function handleCreate(data: Omit<Chapter, 'id'>) {
    try {
      await api.post(`/stories/${storyId}/chapters`, {
        ...data,
        order: chapters.length
      })
      setIsAddingNew(false)
      onUpdate()
    } catch (error) {
      console.error('Failed to create chapter:', error)
    }
  }

  return (
    <div className="space-y-4">
      <div className="flex items-center justify-between">
        <h3 className="text-lg font-semibold">Chapters</h3>
        {!readonly && (
          <Button 
            variant="outline" 
            size="sm"
            onClick={() => setIsAddingNew(true)}
          >
            <Plus className="w-4 h-4 mr-1" />
            Add Chapter
          </Button>
        )}
      </div>

      <DragDropContext onDragEnd={handleDragEnd}>
        <Droppable droppableId="chapters" isDropDisabled={readonly}>
          {(provided) => (
            <div 
              {...provided.droppableProps} 
              ref={provided.innerRef}
              className="space-y-2"
            >
              {chapters.map((chapter, index) => (
                <Draggable 
                  key={chapter.id} 
                  draggableId={chapter.id} 
                  index={index}
                  isDragDisabled={readonly}
                >
                  {(provided, snapshot) => (
                    <div
                      ref={provided.innerRef}
                      {...provided.draggableProps}
                      className={`border rounded-lg bg-card ${
                        snapshot.isDragging ? 'shadow-lg' : ''
                      }`}
                    >
                      <div className="flex items-center p-3 gap-3">
                        {!readonly && (
                          <div {...provided.dragHandleProps}>
                            <GripVertical className="w-5 h-5 text-muted-foreground cursor-grab" />
                          </div>
                        )}
                        
                        <div className="flex-1 min-w-0">
                          <div className="flex items-center gap-2">
                            <span className="text-sm font-medium text-muted-foreground">
                              {index + 1}.
                            </span>
                            <span className="font-medium truncate">
                              {chapter.title}
                            </span>
                          </div>
                          <div className="flex items-center gap-2 mt-1 text-sm text-muted-foreground">
                            <Clock className="w-3 h-3" />
                            <span>{chapter.duration_minutes} min</span>
                            <span className="px-1.5 py-0.5 bg-secondary rounded text-xs">
                              {chapter.depth_level}
                            </span>
                          </div>
                        </div>

                        <div className="flex items-center gap-1">
                          <Button
                            variant="ghost"
                            size="icon"
                            onClick={() => setExpandedId(
                              expandedId === chapter.id ? null : chapter.id
                            )}
                          >
                            {expandedId === chapter.id ? (
                              <ChevronUp className="w-4 h-4" />
                            ) : (
                              <ChevronDown className="w-4 h-4" />
                            )}
                          </Button>
                          {!readonly && (
                            <>
                              <Button
                                variant="ghost"
                                size="icon"
                                onClick={() => setEditingId(chapter.id)}
                              >
                                <Pencil className="w-4 h-4" />
                              </Button>
                              <Button
                                variant="ghost"
                                size="icon"
                                onClick={() => handleDelete(chapter.id)}
                              >
                                <Trash2 className="w-4 h-4 text-destructive" />
                              </Button>
                            </>
                          )}
                        </div>
                      </div>

                      {expandedId === chapter.id && (
                        <div className="px-3 pb-3 pt-0">
                          <p className="text-sm text-muted-foreground pl-8">
                            {chapter.focus_description}
                          </p>
                        </div>
                      )}
                    </div>
                  )}
                </Draggable>
              ))}
              {provided.placeholder}
            </div>
          )}
        </Droppable>
      </DragDropContext>

      {/* Edit Dialog */}
      <ChapterEditDialog
        chapter={chapters.find(ch => ch.id === editingId)}
        open={!!editingId}
        onClose={() => setEditingId(null)}
        onSave={(data) => editingId && handleSave(editingId, data)}
      />

      {/* Add New Dialog */}
      <ChapterEditDialog
        open={isAddingNew}
        onClose={() => setIsAddingNew(false)}
        onSave={handleCreate}
        isNew
      />
    </div>
  )
}

function ChapterEditDialog({ 
  chapter, 
  open, 
  onClose, 
  onSave,
  isNew 
}: {
  chapter?: Chapter
  open: boolean
  onClose: () => void
  onSave: (data: any) => void
  isNew?: boolean
}) {
  const [formData, setFormData] = useState({
    title: chapter?.title || '',
    focus_description: chapter?.focus_description || '',
    duration_minutes: chapter?.duration_minutes || 5,
    depth_level: chapter?.depth_level || 'moderate',
    include_code_samples: chapter?.include_code_samples ?? true,
  })

  return (
    <Dialog open={open} onOpenChange={(o) => !o && onClose()}>
      <DialogContent>
        <DialogHeader>
          <DialogTitle>{isNew ? 'Add Chapter' : 'Edit Chapter'}</DialogTitle>
        </DialogHeader>
        <div className="space-y-4 py-4">
          <div>
            <label className="text-sm font-medium">Title</label>
            <Input
              value={formData.title}
              onChange={(e) => setFormData({ ...formData, title: e.target.value })}
              placeholder="Chapter title"
            />
          </div>
          <div>
            <label className="text-sm font-medium">Focus Description</label>
            <Textarea
              value={formData.focus_description}
              onChange={(e) => setFormData({ ...formData, focus_description: e.target.value })}
              placeholder="What should this chapter cover?"
              rows={3}
            />
          </div>
          <div className="grid grid-cols-2 gap-4">
            <div>
              <label className="text-sm font-medium">Duration (minutes)</label>
              <Input
                type="number"
                min={1}
                max={30}
                value={formData.duration_minutes}
                onChange={(e) => setFormData({ 
                  ...formData, 
                  duration_minutes: parseInt(e.target.value) 
                })}
              />
            </div>
            <div>
              <label className="text-sm font-medium">Depth Level</label>
              <Select
                value={formData.depth_level}
                onValueChange={(v) => setFormData({ ...formData, depth_level: v as any })}
              >
                <SelectTrigger>
                  <SelectValue />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="overview">Overview</SelectItem>
                  <SelectItem value="moderate">Moderate</SelectItem>
                  <SelectItem value="deep">Deep Dive</SelectItem>
                </SelectContent>
              </Select>
            </div>
          </div>
          <Button onClick={() => onSave(formData)} className="w-full">
            <Save className="w-4 h-4 mr-2" />
            {isNew ? 'Add Chapter' : 'Save Changes'}
          </Button>
        </div>
      </DialogContent>
    </Dialog>
  )
}
```
  </action>
  <verify>cd codestory/frontend && npm run build</verify>
  <done>Chapter editor UI created</done>
</task>

</tasks>

<playwright_validation_gate>
```
Playwright Action: Navigate to custom story onboarding
Expected: Chapter list appears after intent completion

Playwright Action: Drag chapter to reorder
Expected: Order updates, persists to backend

Playwright Action: Click edit on chapter
Expected: Edit dialog opens with prefilled data

Playwright Action: Add new chapter
Expected: Chapter added to list at end
```
</playwright_validation_gate>
