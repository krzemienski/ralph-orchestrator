# Plan 13-01: Team/Organization Data Model and Endpoints

## Overview
Implement the foundational data model for teams and organizations, enabling multi-tenant workspaces where multiple users can collaborate on code stories. This includes the database schema, SQLAlchemy models, and core CRUD endpoints for team management.

## Dependencies
- Phase 6 complete (FastAPI backend with authentication)
- Phase 11 complete (Admin dashboard)
- Database schema operational

## Implementation

### 1. Database Models

**models/team.py:**
```python
"""Team and organization data models."""
import uuid
from datetime import datetime
from enum import Enum
from sqlalchemy import Column, String, DateTime, Boolean, Integer, ForeignKey, Enum as SQLEnum, Text, UniqueConstraint
from sqlalchemy.orm import relationship

from database import Base


class TeamPlan(str, Enum):
    """Subscription plans for teams."""
    FREE = "free"
    STARTER = "starter"
    PROFESSIONAL = "professional"
    ENTERPRISE = "enterprise"


class MemberRole(str, Enum):
    """Roles within a team."""
    OWNER = "owner"         # Full control, billing, can delete team
    ADMIN = "admin"         # Manage members, settings, all stories
    MEMBER = "member"       # Create/edit own stories, view team stories
    VIEWER = "viewer"       # View-only access to team stories


class InviteStatus(str, Enum):
    """Status of team invitations."""
    PENDING = "pending"
    ACCEPTED = "accepted"
    DECLINED = "declined"
    EXPIRED = "expired"
    REVOKED = "revoked"


class Team(Base):
    """Organization/team workspace."""
    __tablename__ = "teams"
    
    id = Column(String(36), primary_key=True, default=lambda: str(uuid.uuid4()))
    
    # Identity
    name = Column(String(100), nullable=False)
    slug = Column(String(100), nullable=False, unique=True, index=True)
    description = Column(Text, nullable=True)
    
    # Branding
    logo_url = Column(String(500), nullable=True)
    primary_color = Column(String(7), nullable=True)  # Hex color
    
    # Subscription
    plan = Column(SQLEnum(TeamPlan), default=TeamPlan.FREE, nullable=False)
    plan_started_at = Column(DateTime, nullable=True)
    plan_expires_at = Column(DateTime, nullable=True)
    
    # Quotas (overridable per plan)
    max_members = Column(Integer, default=5)
    max_stories_per_month = Column(Integer, default=10)
    max_storage_gb = Column(Integer, default=5)
    
    # Usage tracking
    stories_this_month = Column(Integer, default=0)
    storage_used_bytes = Column(Integer, default=0)
    
    # Settings
    settings = Column(Text, nullable=True)  # JSON blob for team settings
    
    # SSO (Phase 13-03)
    sso_enabled = Column(Boolean, default=False)
    sso_provider = Column(String(50), nullable=True)  # saml, oidc
    sso_config = Column(Text, nullable=True)  # Encrypted JSON
    
    # Lifecycle
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    suspended_at = Column(DateTime, nullable=True)
    deleted_at = Column(DateTime, nullable=True)
    
    # Relationships
    members = relationship("TeamMember", back_populates="team", cascade="all, delete-orphan")
    invites = relationship("TeamInvite", back_populates="team", cascade="all, delete-orphan")
    stories = relationship("Story", back_populates="team")
    
    @property
    def is_active(self) -> bool:
        """Check if team is active (not suspended or deleted)."""
        return self.suspended_at is None and self.deleted_at is None
    
    @property
    def member_count(self) -> int:
        """Count active team members."""
        return len([m for m in self.members if m.is_active])
    
    def can_add_member(self) -> bool:
        """Check if team can add more members."""
        return self.member_count < self.max_members
    
    def can_create_story(self) -> bool:
        """Check if team can create more stories this month."""
        return self.stories_this_month < self.max_stories_per_month


class TeamMember(Base):
    """Team membership junction table."""
    __tablename__ = "team_members"
    __table_args__ = (
        UniqueConstraint('team_id', 'user_id', name='uq_team_member'),
    )
    
    id = Column(String(36), primary_key=True, default=lambda: str(uuid.uuid4()))
    team_id = Column(String(36), ForeignKey("teams.id", ondelete="CASCADE"), nullable=False)
    user_id = Column(String(36), ForeignKey("users.id", ondelete="CASCADE"), nullable=False)
    
    # Role
    role = Column(SQLEnum(MemberRole), default=MemberRole.MEMBER, nullable=False)
    
    # Metadata
    joined_at = Column(DateTime, default=datetime.utcnow)
    invited_by_id = Column(String(36), ForeignKey("users.id"), nullable=True)
    
    # Activity
    last_active_at = Column(DateTime, nullable=True)
    
    # Status
    is_active = Column(Boolean, default=True)
    deactivated_at = Column(DateTime, nullable=True)
    
    # Relationships
    team = relationship("Team", back_populates="members")
    user = relationship("User", foreign_keys=[user_id], back_populates="team_memberships")
    invited_by = relationship("User", foreign_keys=[invited_by_id])
    
    def has_permission(self, required_role: MemberRole) -> bool:
        """Check if member has required role or higher."""
        role_hierarchy = {
            MemberRole.VIEWER: 0,
            MemberRole.MEMBER: 1,
            MemberRole.ADMIN: 2,
            MemberRole.OWNER: 3
        }
        return role_hierarchy.get(self.role, 0) >= role_hierarchy.get(required_role, 0)


class TeamInvite(Base):
    """Pending team invitations."""
    __tablename__ = "team_invites"
    
    id = Column(String(36), primary_key=True, default=lambda: str(uuid.uuid4()))
    team_id = Column(String(36), ForeignKey("teams.id", ondelete="CASCADE"), nullable=False)
    
    # Invite details
    email = Column(String(255), nullable=False, index=True)
    role = Column(SQLEnum(MemberRole), default=MemberRole.MEMBER, nullable=False)
    token = Column(String(64), nullable=False, unique=True, index=True)
    
    # Tracking
    invited_by_id = Column(String(36), ForeignKey("users.id"), nullable=False)
    status = Column(SQLEnum(InviteStatus), default=InviteStatus.PENDING, nullable=False)
    
    # Lifecycle
    created_at = Column(DateTime, default=datetime.utcnow)
    expires_at = Column(DateTime, nullable=False)
    accepted_at = Column(DateTime, nullable=True)
    
    # Relationships
    team = relationship("Team", back_populates="invites")
    invited_by = relationship("User")
    
    def is_valid(self) -> bool:
        """Check if invite is still valid."""
        if self.status != InviteStatus.PENDING:
            return False
        if datetime.utcnow() > self.expires_at:
            return False
        return True
```

### 2. Update User Model

**models/user.py (additions):**
```python
# Add to existing User model

class User(Base):
    # ... existing fields ...
    
    # Team relationships
    team_memberships = relationship("TeamMember", foreign_keys="TeamMember.user_id", back_populates="user")
    
    # Default team preference
    default_team_id = Column(String(36), ForeignKey("teams.id"), nullable=True)
    default_team = relationship("Team", foreign_keys=[default_team_id])
    
    def get_teams(self) -> list["Team"]:
        """Get all teams user is a member of."""
        return [m.team for m in self.team_memberships if m.is_active and m.team.is_active]
    
    def get_role_in_team(self, team_id: str) -> Optional[MemberRole]:
        """Get user's role in a specific team."""
        for membership in self.team_memberships:
            if membership.team_id == team_id and membership.is_active:
                return membership.role
        return None
    
    def is_member_of(self, team_id: str) -> bool:
        """Check if user is a member of a team."""
        return self.get_role_in_team(team_id) is not None
```

### 3. Pydantic Schemas

**schemas/team.py:**
```python
"""Team-related Pydantic schemas."""
from datetime import datetime
from typing import Optional, List
from pydantic import BaseModel, Field, EmailStr, validator
import re

from models.team import TeamPlan, MemberRole, InviteStatus


# -----------------------------------------------------------------------------
# Team Schemas
# -----------------------------------------------------------------------------

class TeamCreate(BaseModel):
    """Schema for creating a new team."""
    name: str = Field(..., min_length=2, max_length=100)
    slug: Optional[str] = Field(None, min_length=2, max_length=100)
    description: Optional[str] = Field(None, max_length=500)
    
    @validator('slug', pre=True, always=True)
    def generate_slug(cls, v, values):
        if v:
            # Validate slug format
            if not re.match(r'^[a-z0-9-]+$', v):
                raise ValueError('Slug must contain only lowercase letters, numbers, and hyphens')
            return v
        # Auto-generate from name
        name = values.get('name', '')
        return re.sub(r'[^a-z0-9]+', '-', name.lower()).strip('-')


class TeamUpdate(BaseModel):
    """Schema for updating a team."""
    name: Optional[str] = Field(None, min_length=2, max_length=100)
    description: Optional[str] = Field(None, max_length=500)
    logo_url: Optional[str] = None
    primary_color: Optional[str] = Field(None, pattern=r'^#[0-9A-Fa-f]{6}$')


class TeamResponse(BaseModel):
    """Schema for team response."""
    id: str
    name: str
    slug: str
    description: Optional[str]
    logo_url: Optional[str]
    primary_color: Optional[str]
    plan: TeamPlan
    member_count: int
    max_members: int
    stories_this_month: int
    max_stories_per_month: int
    created_at: datetime
    
    class Config:
        from_attributes = True


class TeamDetailResponse(TeamResponse):
    """Detailed team response including user's role."""
    user_role: MemberRole
    can_manage_members: bool
    can_manage_settings: bool
    sso_enabled: bool


# -----------------------------------------------------------------------------
# Member Schemas
# -----------------------------------------------------------------------------

class TeamMemberResponse(BaseModel):
    """Schema for team member response."""
    id: str
    user_id: str
    user_email: str
    user_name: str
    role: MemberRole
    joined_at: datetime
    last_active_at: Optional[datetime]
    is_active: bool
    
    class Config:
        from_attributes = True


class TeamMemberUpdate(BaseModel):
    """Schema for updating a team member."""
    role: Optional[MemberRole] = None
    is_active: Optional[bool] = None


# -----------------------------------------------------------------------------
# Invite Schemas
# -----------------------------------------------------------------------------

class TeamInviteCreate(BaseModel):
    """Schema for creating team invites."""
    emails: List[EmailStr] = Field(..., min_items=1, max_items=50)
    role: MemberRole = MemberRole.MEMBER
    
    @validator('role')
    def validate_role(cls, v):
        if v == MemberRole.OWNER:
            raise ValueError('Cannot invite users as owner')
        return v


class TeamInviteResponse(BaseModel):
    """Schema for invite response."""
    id: str
    email: str
    role: MemberRole
    status: InviteStatus
    invited_by_name: str
    created_at: datetime
    expires_at: datetime
    
    class Config:
        from_attributes = True


class AcceptInviteRequest(BaseModel):
    """Schema for accepting an invite."""
    token: str = Field(..., min_length=32, max_length=64)
```

### 4. Team Service

**services/team_service.py:**
```python
"""Team management service."""
import secrets
import uuid
from datetime import datetime, timedelta
from typing import Optional, List, Tuple
from sqlalchemy.orm import Session
from sqlalchemy import or_

from models.team import Team, TeamMember, TeamInvite, TeamPlan, MemberRole, InviteStatus
from models.user import User
from schemas.team import TeamCreate, TeamUpdate, TeamInviteCreate


class TeamService:
    """Service for team operations."""
    
    def __init__(self, db: Session):
        self.db = db
        
    # -------------------------------------------------------------------------
    # Team CRUD
    # -------------------------------------------------------------------------
    
    def create_team(self, creator: User, data: TeamCreate) -> Team:
        """Create a new team with the creator as owner."""
        # Check slug uniqueness
        existing = self.db.query(Team).filter(Team.slug == data.slug).first()
        if existing:
            raise ValueError(f"Team slug '{data.slug}' is already taken")
        
        # Create team
        team = Team(
            id=str(uuid.uuid4()),
            name=data.name,
            slug=data.slug,
            description=data.description,
            plan=TeamPlan.FREE,
            max_members=5,
            max_stories_per_month=10,
            max_storage_gb=5
        )
        self.db.add(team)
        
        # Add creator as owner
        membership = TeamMember(
            id=str(uuid.uuid4()),
            team_id=team.id,
            user_id=creator.id,
            role=MemberRole.OWNER,
            invited_by_id=None
        )
        self.db.add(membership)
        
        # Set as user's default team if they don't have one
        if not creator.default_team_id:
            creator.default_team_id = team.id
        
        self.db.commit()
        self.db.refresh(team)
        
        return team
    
    def get_team(self, team_id: str) -> Optional[Team]:
        """Get a team by ID."""
        return self.db.query(Team).filter(
            Team.id == team_id,
            Team.deleted_at.is_(None)
        ).first()
    
    def get_team_by_slug(self, slug: str) -> Optional[Team]:
        """Get a team by slug."""
        return self.db.query(Team).filter(
            Team.slug == slug,
            Team.deleted_at.is_(None)
        ).first()
    
    def update_team(self, team: Team, data: TeamUpdate) -> Team:
        """Update team settings."""
        update_data = data.model_dump(exclude_unset=True)
        for field, value in update_data.items():
            setattr(team, field, value)
        
        self.db.commit()
        self.db.refresh(team)
        return team
    
    def delete_team(self, team: Team) -> None:
        """Soft delete a team."""
        team.deleted_at = datetime.utcnow()
        self.db.commit()
    
    def list_user_teams(self, user: User) -> List[Tuple[Team, MemberRole]]:
        """List all teams a user belongs to."""
        memberships = self.db.query(TeamMember).filter(
            TeamMember.user_id == user.id,
            TeamMember.is_active == True
        ).all()
        
        result = []
        for membership in memberships:
            if membership.team.is_active:
                result.append((membership.team, membership.role))
        
        return result
    
    # -------------------------------------------------------------------------
    # Member Management
    # -------------------------------------------------------------------------
    
    def get_membership(self, team_id: str, user_id: str) -> Optional[TeamMember]:
        """Get a specific team membership."""
        return self.db.query(TeamMember).filter(
            TeamMember.team_id == team_id,
            TeamMember.user_id == user_id,
            TeamMember.is_active == True
        ).first()
    
    def list_members(self, team: Team, include_inactive: bool = False) -> List[TeamMember]:
        """List all team members."""
        query = self.db.query(TeamMember).filter(TeamMember.team_id == team.id)
        
        if not include_inactive:
            query = query.filter(TeamMember.is_active == True)
        
        return query.order_by(TeamMember.joined_at).all()
    
    def update_member_role(
        self,
        team: Team,
        member: TeamMember,
        new_role: MemberRole,
        actor: TeamMember
    ) -> TeamMember:
        """Update a member's role."""
        # Validate permissions
        if not actor.has_permission(MemberRole.ADMIN):
            raise PermissionError("Only admins can change member roles")
        
        # Cannot change owner's role (must transfer ownership)
        if member.role == MemberRole.OWNER:
            raise ValueError("Cannot change owner's role. Transfer ownership first.")
        
        # Cannot promote to owner (must use transfer)
        if new_role == MemberRole.OWNER:
            raise ValueError("Cannot promote to owner. Use ownership transfer.")
        
        # Non-owners cannot promote to admin
        if new_role == MemberRole.ADMIN and actor.role != MemberRole.OWNER:
            raise PermissionError("Only owner can promote to admin")
        
        member.role = new_role
        self.db.commit()
        self.db.refresh(member)
        
        return member
    
    def remove_member(self, team: Team, member: TeamMember, actor: TeamMember) -> None:
        """Remove a member from the team."""
        # Cannot remove owner
        if member.role == MemberRole.OWNER:
            raise ValueError("Cannot remove team owner")
        
        # Check permissions
        if actor.user_id != member.user_id:  # Not self-removal
            if not actor.has_permission(MemberRole.ADMIN):
                raise PermissionError("Only admins can remove members")
        
        member.is_active = False
        member.deactivated_at = datetime.utcnow()
        self.db.commit()
    
    def transfer_ownership(
        self,
        team: Team,
        current_owner: TeamMember,
        new_owner: TeamMember
    ) -> None:
        """Transfer team ownership to another member."""
        if current_owner.role != MemberRole.OWNER:
            raise PermissionError("Only owner can transfer ownership")
        
        if not new_owner.is_active:
            raise ValueError("Cannot transfer to inactive member")
        
        # Demote current owner to admin
        current_owner.role = MemberRole.ADMIN
        
        # Promote new owner
        new_owner.role = MemberRole.OWNER
        
        self.db.commit()
    
    # -------------------------------------------------------------------------
    # Invitations
    # -------------------------------------------------------------------------
    
    def create_invites(
        self,
        team: Team,
        data: TeamInviteCreate,
        inviter: User
    ) -> List[TeamInvite]:
        """Create invitations for multiple emails."""
        # Check team capacity
        current_members = team.member_count
        pending_invites = self.db.query(TeamInvite).filter(
            TeamInvite.team_id == team.id,
            TeamInvite.status == InviteStatus.PENDING
        ).count()
        
        total_after = current_members + pending_invites + len(data.emails)
        if total_after > team.max_members:
            raise ValueError(
                f"Cannot invite {len(data.emails)} users. "
                f"Team limit is {team.max_members} members."
            )
        
        invites = []
        for email in data.emails:
            # Skip if already a member
            existing_member = self.db.query(TeamMember).join(User).filter(
                TeamMember.team_id == team.id,
                User.email == email,
                TeamMember.is_active == True
            ).first()
            if existing_member:
                continue
            
            # Skip if pending invite exists
            existing_invite = self.db.query(TeamInvite).filter(
                TeamInvite.team_id == team.id,
                TeamInvite.email == email,
                TeamInvite.status == InviteStatus.PENDING
            ).first()
            if existing_invite:
                continue
            
            invite = TeamInvite(
                id=str(uuid.uuid4()),
                team_id=team.id,
                email=email,
                role=data.role,
                token=secrets.token_urlsafe(32),
                invited_by_id=inviter.id,
                expires_at=datetime.utcnow() + timedelta(days=7)
            )
            self.db.add(invite)
            invites.append(invite)
        
        self.db.commit()
        return invites
    
    def accept_invite(self, token: str, user: User) -> TeamMember:
        """Accept a team invitation."""
        invite = self.db.query(TeamInvite).filter(
            TeamInvite.token == token
        ).first()
        
        if not invite:
            raise ValueError("Invalid invitation token")
        
        if not invite.is_valid():
            raise ValueError("Invitation has expired or is no longer valid")
        
        if invite.email.lower() != user.email.lower():
            raise ValueError("Invitation was sent to a different email address")
        
        # Check if already a member
        existing = self.get_membership(invite.team_id, user.id)
        if existing:
            raise ValueError("You are already a member of this team")
        
        # Create membership
        membership = TeamMember(
            id=str(uuid.uuid4()),
            team_id=invite.team_id,
            user_id=user.id,
            role=invite.role,
            invited_by_id=invite.invited_by_id
        )
        self.db.add(membership)
        
        # Update invite status
        invite.status = InviteStatus.ACCEPTED
        invite.accepted_at = datetime.utcnow()
        
        self.db.commit()
        self.db.refresh(membership)
        
        return membership
    
    def revoke_invite(self, invite: TeamInvite) -> None:
        """Revoke a pending invitation."""
        if invite.status != InviteStatus.PENDING:
            raise ValueError("Can only revoke pending invitations")
        
        invite.status = InviteStatus.REVOKED
        self.db.commit()
    
    def list_invites(self, team: Team, status: Optional[InviteStatus] = None) -> List[TeamInvite]:
        """List team invitations."""
        query = self.db.query(TeamInvite).filter(TeamInvite.team_id == team.id)
        
        if status:
            query = query.filter(TeamInvite.status == status)
        
        return query.order_by(TeamInvite.created_at.desc()).all()
```

### 5. API Endpoints

**routers/teams.py:**
```python
"""Team management API endpoints."""
from fastapi import APIRouter, Depends, HTTPException, status, Query
from sqlalchemy.orm import Session
from typing import List, Optional

from database import get_db
from auth import get_current_user
from models.user import User
from models.team import Team, TeamMember, MemberRole, InviteStatus
from schemas.team import (
    TeamCreate, TeamUpdate, TeamResponse, TeamDetailResponse,
    TeamMemberResponse, TeamMemberUpdate,
    TeamInviteCreate, TeamInviteResponse, AcceptInviteRequest
)
from services.team_service import TeamService

router = APIRouter(prefix="/api/v1/teams", tags=["teams"])


# -----------------------------------------------------------------------------
# Team Endpoints
# -----------------------------------------------------------------------------

@router.post("", response_model=TeamDetailResponse, status_code=status.HTTP_201_CREATED)
async def create_team(
    data: TeamCreate,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Create a new team."""
    service = TeamService(db)
    
    try:
        team = service.create_team(current_user, data)
        return TeamDetailResponse(
            **TeamResponse.model_validate(team).model_dump(),
            user_role=MemberRole.OWNER,
            can_manage_members=True,
            can_manage_settings=True,
            sso_enabled=team.sso_enabled
        )
    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))


@router.get("", response_model=List[TeamResponse])
async def list_teams(
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """List teams the current user belongs to."""
    service = TeamService(db)
    teams_with_roles = service.list_user_teams(current_user)
    
    return [
        TeamResponse.model_validate(team)
        for team, _ in teams_with_roles
    ]


@router.get("/{team_id}", response_model=TeamDetailResponse)
async def get_team(
    team_id: str,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Get team details."""
    service = TeamService(db)
    team = service.get_team(team_id)
    
    if not team:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Team not found")
    
    membership = service.get_membership(team_id, current_user.id)
    if not membership:
        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Not a team member")
    
    return TeamDetailResponse(
        **TeamResponse.model_validate(team).model_dump(),
        user_role=membership.role,
        can_manage_members=membership.has_permission(MemberRole.ADMIN),
        can_manage_settings=membership.has_permission(MemberRole.ADMIN),
        sso_enabled=team.sso_enabled
    )


@router.patch("/{team_id}", response_model=TeamResponse)
async def update_team(
    team_id: str,
    data: TeamUpdate,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Update team settings."""
    service = TeamService(db)
    team = service.get_team(team_id)
    
    if not team:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Team not found")
    
    membership = service.get_membership(team_id, current_user.id)
    if not membership or not membership.has_permission(MemberRole.ADMIN):
        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Admin access required")
    
    team = service.update_team(team, data)
    return TeamResponse.model_validate(team)


@router.delete("/{team_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_team(
    team_id: str,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Delete a team (owner only)."""
    service = TeamService(db)
    team = service.get_team(team_id)
    
    if not team:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Team not found")
    
    membership = service.get_membership(team_id, current_user.id)
    if not membership or membership.role != MemberRole.OWNER:
        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Owner access required")
    
    service.delete_team(team)


# -----------------------------------------------------------------------------
# Member Endpoints
# -----------------------------------------------------------------------------

@router.get("/{team_id}/members", response_model=List[TeamMemberResponse])
async def list_members(
    team_id: str,
    include_inactive: bool = Query(False),
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """List team members."""
    service = TeamService(db)
    team = service.get_team(team_id)
    
    if not team:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Team not found")
    
    membership = service.get_membership(team_id, current_user.id)
    if not membership:
        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Not a team member")
    
    members = service.list_members(team, include_inactive)
    
    return [
        TeamMemberResponse(
            id=m.id,
            user_id=m.user_id,
            user_email=m.user.email,
            user_name=m.user.name,
            role=m.role,
            joined_at=m.joined_at,
            last_active_at=m.last_active_at,
            is_active=m.is_active
        )
        for m in members
    ]


@router.patch("/{team_id}/members/{member_id}", response_model=TeamMemberResponse)
async def update_member(
    team_id: str,
    member_id: str,
    data: TeamMemberUpdate,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Update a team member's role or status."""
    service = TeamService(db)
    team = service.get_team(team_id)
    
    if not team:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Team not found")
    
    actor = service.get_membership(team_id, current_user.id)
    if not actor:
        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Not a team member")
    
    member = db.query(TeamMember).filter(
        TeamMember.id == member_id,
        TeamMember.team_id == team_id
    ).first()
    
    if not member:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Member not found")
    
    try:
        if data.role:
            member = service.update_member_role(team, member, data.role, actor)
        if data.is_active is False:
            service.remove_member(team, member, actor)
            member = db.query(TeamMember).filter(TeamMember.id == member_id).first()
    except (PermissionError, ValueError) as e:
        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail=str(e))
    
    return TeamMemberResponse(
        id=member.id,
        user_id=member.user_id,
        user_email=member.user.email,
        user_name=member.user.name,
        role=member.role,
        joined_at=member.joined_at,
        last_active_at=member.last_active_at,
        is_active=member.is_active
    )


@router.delete("/{team_id}/members/{member_id}", status_code=status.HTTP_204_NO_CONTENT)
async def remove_member(
    team_id: str,
    member_id: str,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Remove a member from the team."""
    service = TeamService(db)
    team = service.get_team(team_id)
    
    if not team:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Team not found")
    
    actor = service.get_membership(team_id, current_user.id)
    if not actor:
        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Not a team member")
    
    member = db.query(TeamMember).filter(
        TeamMember.id == member_id,
        TeamMember.team_id == team_id
    ).first()
    
    if not member:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Member not found")
    
    try:
        service.remove_member(team, member, actor)
    except (PermissionError, ValueError) as e:
        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail=str(e))


# -----------------------------------------------------------------------------
# Invite Endpoints
# -----------------------------------------------------------------------------

@router.post("/{team_id}/invites", response_model=List[TeamInviteResponse])
async def create_invites(
    team_id: str,
    data: TeamInviteCreate,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Invite users to the team."""
    service = TeamService(db)
    team = service.get_team(team_id)
    
    if not team:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Team not found")
    
    membership = service.get_membership(team_id, current_user.id)
    if not membership or not membership.has_permission(MemberRole.ADMIN):
        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Admin access required")
    
    try:
        invites = service.create_invites(team, data, current_user)
    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))
    
    return [
        TeamInviteResponse(
            id=i.id,
            email=i.email,
            role=i.role,
            status=i.status,
            invited_by_name=i.invited_by.name,
            created_at=i.created_at,
            expires_at=i.expires_at
        )
        for i in invites
    ]


@router.get("/{team_id}/invites", response_model=List[TeamInviteResponse])
async def list_invites(
    team_id: str,
    status: Optional[InviteStatus] = Query(None),
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """List team invitations."""
    service = TeamService(db)
    team = service.get_team(team_id)
    
    if not team:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Team not found")
    
    membership = service.get_membership(team_id, current_user.id)
    if not membership or not membership.has_permission(MemberRole.ADMIN):
        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Admin access required")
    
    invites = service.list_invites(team, status)
    
    return [
        TeamInviteResponse(
            id=i.id,
            email=i.email,
            role=i.role,
            status=i.status,
            invited_by_name=i.invited_by.name,
            created_at=i.created_at,
            expires_at=i.expires_at
        )
        for i in invites
    ]


@router.post("/invites/accept", response_model=TeamMemberResponse)
async def accept_invite(
    data: AcceptInviteRequest,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Accept a team invitation."""
    service = TeamService(db)
    
    try:
        membership = service.accept_invite(data.token, current_user)
    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))
    
    return TeamMemberResponse(
        id=membership.id,
        user_id=membership.user_id,
        user_email=membership.user.email,
        user_name=membership.user.name,
        role=membership.role,
        joined_at=membership.joined_at,
        last_active_at=membership.last_active_at,
        is_active=membership.is_active
    )


@router.delete("/{team_id}/invites/{invite_id}", status_code=status.HTTP_204_NO_CONTENT)
async def revoke_invite(
    team_id: str,
    invite_id: str,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Revoke a pending invitation."""
    service = TeamService(db)
    team = service.get_team(team_id)
    
    if not team:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Team not found")
    
    membership = service.get_membership(team_id, current_user.id)
    if not membership or not membership.has_permission(MemberRole.ADMIN):
        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Admin access required")
    
    invite = db.query(TeamInvite).filter(
        TeamInvite.id == invite_id,
        TeamInvite.team_id == team_id
    ).first()
    
    if not invite:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Invite not found")
    
    try:
        service.revoke_invite(invite)
    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))
```

## File Structure
```
backend/
├── models/
│   ├── team.py
│   └── user.py (updated)
├── schemas/
│   └── team.py
├── services/
│   └── team_service.py
└── routers/
    └── teams.py
```

## Validation Gates

### Gate 1: Team Creation
```python
def test_create_team():
    """Verify team creation with owner."""
    response = client.post("/api/v1/teams", json={
        "name": "Test Team",
        "description": "A test team"
    }, headers=auth_headers)
    
    assert response.status_code == 201
    data = response.json()
    assert data["name"] == "Test Team"
    assert data["slug"] == "test-team"
    assert data["user_role"] == "owner"
    assert data["can_manage_members"] == True
```

### Gate 2: Member Invitation Flow
```python
def test_invite_accept_flow():
    """Verify invitation and acceptance."""
    # Create invite
    invite_resp = client.post(f"/api/v1/teams/{team_id}/invites", json={
        "emails": ["newuser@example.com"],
        "role": "member"
    }, headers=owner_headers)
    
    assert invite_resp.status_code == 200
    
    # Accept invite (as new user)
    accept_resp = client.post("/api/v1/teams/invites/accept", json={
        "token": invite_token
    }, headers=new_user_headers)
    
    assert accept_resp.status_code == 200
    assert accept_resp.json()["role"] == "member"
```

### Gate 3: Role Permissions
```python
def test_role_permissions():
    """Verify role-based access control."""
    # Member cannot change roles
    response = client.patch(
        f"/api/v1/teams/{team_id}/members/{other_member_id}",
        json={"role": "admin"},
        headers=member_headers
    )
    assert response.status_code == 403
    
    # Admin can change member role
    response = client.patch(
        f"/api/v1/teams/{team_id}/members/{member_id}",
        json={"role": "viewer"},
        headers=admin_headers
    )
    assert response.status_code == 200
```

## Definition of Done
- [ ] Team model with all fields and relationships
- [ ] TeamMember model with role hierarchy
- [ ] TeamInvite model with token-based flow
- [ ] Pydantic schemas for all operations
- [ ] TeamService with full CRUD operations
- [ ] Role-based permission checking
- [ ] Invite creation and acceptance flow
- [ ] API endpoints for teams, members, invites
- [ ] All validation gates passing
