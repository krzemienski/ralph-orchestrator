# Plan 13-03: SSO Integration Preparation (SAML/OIDC Hooks)

## Overview
Implement the foundation for Single Sign-On (SSO) integration, supporting both SAML 2.0 and OpenID Connect (OIDC) protocols. This enables enterprise customers to authenticate users through their existing identity providers (Okta, Azure AD, Google Workspace, etc.).

## Dependencies
- Plan 13-01 complete (Team/organization data model)
- Plan 13-02 complete (Team collaboration features)
- Team settings and configuration storage
- Secure secrets management

## Security Reasoning

SSO is one of the most security-critical features. Thoroughly analyze protocol requirements:

**SAML 2.0 Security Considerations:**
- Signature validation: ALWAYS verify SAML assertion signatures
- Certificate management: secure storage, rotation procedures
- Replay attack prevention: validate NotBefore/NotOnOrAfter, cache assertion IDs
- XML signature wrapping attacks: use robust SAML library (python3-saml)
- Redirect binding vs POST binding security trade-offs
- Service Provider (SP) metadata must be cryptographically signed

**OIDC Security Considerations:**
- Use authorization code flow (NOT implicit flow)
- Validate `state` parameter to prevent CSRF
- Validate `nonce` to prevent replay attacks
- Verify `iss` (issuer) matches expected IdP
- Verify `aud` (audience) includes our client_id
- Token signature validation with proper key handling
- Secure storage of client secrets

**Common Attack Vectors to Mitigate:**
1. **Account takeover via email mismatch**: Always normalize emails, validate domain ownership
2. **Privilege escalation**: SSO user shouldn't auto-get admin rights
3. **IdP compromise propagation**: Consider step-up auth for sensitive operations
4. **Logout vulnerabilities**: Implement proper SLO (Single Logout)
5. **Metadata spoofing**: Validate IdP metadata authenticity

**Just-In-Time (JIT) Provisioning:**
- Create user on first SSO login (if allowed)
- Update user attributes from IdP claims
- Handle deprovisioning (IdP user deleted)
- Role/group mapping from IdP claims

**Session Management:**
- SSO session vs application session distinction
- Session binding to IdP session (for SLO)
- Re-authentication requirements for sensitive actions

**Testing Requirements:**
- Test with multiple IdPs (Okta, Azure AD, Google)
- Test edge cases: expired certs, revoked access, name changes
- Security scan with SAML-specific tools
- Penetration testing before launch

**Operational Concerns:**
- IdP certificate rotation procedure
- Incident response: how to disable SSO quickly?
- Fallback authentication: what if IdP is down?
- Audit logging: all SSO events with full context

Consider using a battle-tested library (python3-saml for SAML, authlib for OIDC) rather than implementing protocols from scratch.

## Sub-Agent Hint

SSO implementation is complex enough to warrant a dedicated sub-agent:
- SAML and OIDC are distinct protocols requiring different expertise
- Security testing requires focused attention
- Integration testing with real IdPs is time-consuming
- Can iterate on SSO independently from other enterprise features

Sub-agent should focus on:
1. Protocol implementation with security library
2. Configuration UI for admins
3. Testing harness with mock IdPs
4. Security review and hardening

## Implementation

### 1. SSO Configuration Models

**models/sso.py:**
```python
"""SSO configuration models."""
import uuid
from datetime import datetime
from enum import Enum
from sqlalchemy import Column, String, DateTime, Boolean, Text, ForeignKey, Enum as SQLEnum
from sqlalchemy.orm import relationship
from cryptography.fernet import Fernet

from database import Base
from config import settings


class SSOProvider(str, Enum):
    """Supported SSO providers."""
    SAML = "saml"
    OIDC = "oidc"


class SSOStatus(str, Enum):
    """SSO configuration status."""
    DRAFT = "draft"           # Being configured
    TESTING = "testing"       # Ready for test login
    ACTIVE = "active"         # Production ready
    DISABLED = "disabled"     # Temporarily disabled


class SSOConfiguration(Base):
    """SSO configuration for a team."""
    __tablename__ = "sso_configurations"
    
    id = Column(String(36), primary_key=True, default=lambda: str(uuid.uuid4()))
    team_id = Column(String(36), ForeignKey("teams.id", ondelete="CASCADE"), nullable=False, unique=True)
    
    # Provider type
    provider = Column(SQLEnum(SSOProvider), nullable=False)
    status = Column(SQLEnum(SSOStatus), default=SSOStatus.DRAFT, nullable=False)
    
    # Display name for login button
    display_name = Column(String(100), nullable=True)  # e.g., "Sign in with Acme Corp"
    
    # Connection identifier (for routing)
    connection_id = Column(String(100), nullable=False, unique=True, index=True)
    
    # Encrypted configuration (provider-specific)
    config_encrypted = Column(Text, nullable=False)
    
    # Domain restrictions
    allowed_domains = Column(Text, nullable=True)  # Comma-separated email domains
    
    # Behavior settings
    auto_provision = Column(Boolean, default=True)  # Auto-create users on first login
    default_role = Column(String(20), default="member")  # Role for auto-provisioned users
    
    # Audit
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    created_by_id = Column(String(36), ForeignKey("users.id"), nullable=False)
    last_tested_at = Column(DateTime, nullable=True)
    last_login_at = Column(DateTime, nullable=True)
    
    # Relationships
    team = relationship("Team", back_populates="sso_config")
    created_by = relationship("User")
    
    @staticmethod
    def get_cipher():
        """Get Fernet cipher for encryption/decryption."""
        key = settings.SSO_ENCRYPTION_KEY.encode()
        return Fernet(key)
    
    def set_config(self, config: dict) -> None:
        """Encrypt and store configuration."""
        import json
        cipher = self.get_cipher()
        plaintext = json.dumps(config).encode()
        self.config_encrypted = cipher.encrypt(plaintext).decode()
    
    def get_config(self) -> dict:
        """Decrypt and return configuration."""
        import json
        cipher = self.get_cipher()
        plaintext = cipher.decrypt(self.config_encrypted.encode())
        return json.loads(plaintext)
    
    def is_domain_allowed(self, email: str) -> bool:
        """Check if email domain is allowed."""
        if not self.allowed_domains:
            return True
        
        domain = email.split("@")[-1].lower()
        allowed = [d.strip().lower() for d in self.allowed_domains.split(",")]
        return domain in allowed


class SSOSession(Base):
    """SSO authentication session tracking."""
    __tablename__ = "sso_sessions"
    
    id = Column(String(36), primary_key=True, default=lambda: str(uuid.uuid4()))
    sso_config_id = Column(String(36), ForeignKey("sso_configurations.id"), nullable=False)
    
    # State management
    state = Column(String(64), nullable=False, unique=True, index=True)
    nonce = Column(String(64), nullable=True)  # For OIDC
    
    # Relay state (where to redirect after auth)
    relay_state = Column(String(500), nullable=True)
    
    # Lifecycle
    created_at = Column(DateTime, default=datetime.utcnow)
    expires_at = Column(DateTime, nullable=False)
    completed_at = Column(DateTime, nullable=True)
    
    # Result
    user_id = Column(String(36), ForeignKey("users.id"), nullable=True)
    error_message = Column(Text, nullable=True)
    
    # Relationships
    sso_config = relationship("SSOConfiguration")
    user = relationship("User")
    
    def is_valid(self) -> bool:
        """Check if session is still valid."""
        if self.completed_at:
            return False
        if datetime.utcnow() > self.expires_at:
            return False
        return True
```

### 2. SAML Configuration Schema

**schemas/sso.py:**
```python
"""SSO configuration schemas."""
from datetime import datetime
from typing import Optional, List
from pydantic import BaseModel, Field, HttpUrl, validator
from enum import Enum

from models.sso import SSOProvider, SSOStatus


class SAMLConfigCreate(BaseModel):
    """SAML configuration input."""
    display_name: str = Field(..., min_length=1, max_length=100)
    
    # Identity Provider settings
    idp_entity_id: str = Field(..., description="IdP Entity ID / Issuer")
    idp_sso_url: HttpUrl = Field(..., description="IdP Single Sign-On URL")
    idp_slo_url: Optional[HttpUrl] = Field(None, description="IdP Single Logout URL")
    idp_certificate: str = Field(..., description="IdP X.509 Certificate (PEM format)")
    
    # Attribute mapping
    attribute_email: str = Field(default="email", description="Attribute name for email")
    attribute_first_name: str = Field(default="firstName", description="Attribute name for first name")
    attribute_last_name: str = Field(default="lastName", description="Attribute name for last name")
    
    # Optional settings
    allowed_domains: Optional[List[str]] = Field(None, description="Allowed email domains")
    auto_provision: bool = Field(default=True, description="Auto-create users on first login")
    default_role: str = Field(default="member", pattern="^(viewer|member|admin)$")
    
    @validator('idp_certificate')
    def validate_certificate(cls, v):
        """Validate certificate format."""
        if "BEGIN CERTIFICATE" not in v:
            raise ValueError("Certificate must be in PEM format")
        return v


class OIDCConfigCreate(BaseModel):
    """OIDC configuration input."""
    display_name: str = Field(..., min_length=1, max_length=100)
    
    # Provider settings
    issuer: HttpUrl = Field(..., description="OIDC Issuer URL")
    client_id: str = Field(..., description="OAuth Client ID")
    client_secret: str = Field(..., description="OAuth Client Secret")
    
    # Optional: manual endpoint configuration
    authorization_endpoint: Optional[HttpUrl] = None
    token_endpoint: Optional[HttpUrl] = None
    userinfo_endpoint: Optional[HttpUrl] = None
    jwks_uri: Optional[HttpUrl] = None
    
    # Scopes
    scopes: List[str] = Field(default=["openid", "email", "profile"])
    
    # Claim mapping
    claim_email: str = Field(default="email")
    claim_name: str = Field(default="name")
    claim_given_name: str = Field(default="given_name")
    claim_family_name: str = Field(default="family_name")
    
    # Optional settings
    allowed_domains: Optional[List[str]] = None
    auto_provision: bool = True
    default_role: str = Field(default="member", pattern="^(viewer|member|admin)$")


class SSOConfigResponse(BaseModel):
    """SSO configuration response."""
    id: str
    team_id: str
    provider: SSOProvider
    status: SSOStatus
    display_name: Optional[str]
    connection_id: str
    allowed_domains: Optional[List[str]]
    auto_provision: bool
    default_role: str
    created_at: datetime
    updated_at: datetime
    last_tested_at: Optional[datetime]
    last_login_at: Optional[datetime]
    
    # Service Provider metadata (for SAML)
    sp_entity_id: Optional[str] = None
    sp_acs_url: Optional[str] = None
    sp_slo_url: Optional[str] = None
    sp_metadata_url: Optional[str] = None
    
    class Config:
        from_attributes = True


class SSOLoginInitResponse(BaseModel):
    """Response when initiating SSO login."""
    redirect_url: str
    state: str


class SSOTestResult(BaseModel):
    """Result of SSO configuration test."""
    success: bool
    message: str
    user_email: Optional[str] = None
    user_name: Optional[str] = None
    attributes: Optional[dict] = None
    error_details: Optional[str] = None
```

### 3. SSO Service

**services/sso_service.py:**
```python
"""SSO authentication service."""
import secrets
import uuid
from datetime import datetime, timedelta
from typing import Optional, Tuple
from urllib.parse import urlencode
from sqlalchemy.orm import Session

from models.sso import SSOConfiguration, SSOSession, SSOProvider, SSOStatus
from models.team import Team, TeamMember, MemberRole
from models.user import User
from schemas.sso import SAMLConfigCreate, OIDCConfigCreate
from config import settings


class SSOService:
    """Service for SSO operations."""
    
    def __init__(self, db: Session):
        self.db = db
        self.base_url = settings.BASE_URL
    
    # -------------------------------------------------------------------------
    # Configuration Management
    # -------------------------------------------------------------------------
    
    def create_saml_config(
        self,
        team: Team,
        data: SAMLConfigCreate,
        created_by: User
    ) -> SSOConfiguration:
        """Create SAML SSO configuration."""
        # Check if team already has SSO
        existing = self.db.query(SSOConfiguration).filter(
            SSOConfiguration.team_id == team.id
        ).first()
        
        if existing:
            raise ValueError("Team already has an SSO configuration")
        
        # Generate connection ID
        connection_id = f"saml-{team.slug}-{secrets.token_hex(4)}"
        
        # Build config dict
        config = {
            "idp_entity_id": data.idp_entity_id,
            "idp_sso_url": str(data.idp_sso_url),
            "idp_slo_url": str(data.idp_slo_url) if data.idp_slo_url else None,
            "idp_certificate": data.idp_certificate,
            "attribute_mapping": {
                "email": data.attribute_email,
                "first_name": data.attribute_first_name,
                "last_name": data.attribute_last_name
            }
        }
        
        sso_config = SSOConfiguration(
            id=str(uuid.uuid4()),
            team_id=team.id,
            provider=SSOProvider.SAML,
            display_name=data.display_name,
            connection_id=connection_id,
            allowed_domains=",".join(data.allowed_domains) if data.allowed_domains else None,
            auto_provision=data.auto_provision,
            default_role=data.default_role,
            created_by_id=created_by.id
        )
        sso_config.set_config(config)
        
        self.db.add(sso_config)
        
        # Update team SSO flag
        team.sso_enabled = True
        team.sso_provider = SSOProvider.SAML.value
        
        self.db.commit()
        self.db.refresh(sso_config)
        
        return sso_config
    
    def create_oidc_config(
        self,
        team: Team,
        data: OIDCConfigCreate,
        created_by: User
    ) -> SSOConfiguration:
        """Create OIDC SSO configuration."""
        existing = self.db.query(SSOConfiguration).filter(
            SSOConfiguration.team_id == team.id
        ).first()
        
        if existing:
            raise ValueError("Team already has an SSO configuration")
        
        connection_id = f"oidc-{team.slug}-{secrets.token_hex(4)}"
        
        config = {
            "issuer": str(data.issuer),
            "client_id": data.client_id,
            "client_secret": data.client_secret,
            "authorization_endpoint": str(data.authorization_endpoint) if data.authorization_endpoint else None,
            "token_endpoint": str(data.token_endpoint) if data.token_endpoint else None,
            "userinfo_endpoint": str(data.userinfo_endpoint) if data.userinfo_endpoint else None,
            "jwks_uri": str(data.jwks_uri) if data.jwks_uri else None,
            "scopes": data.scopes,
            "claim_mapping": {
                "email": data.claim_email,
                "name": data.claim_name,
                "given_name": data.claim_given_name,
                "family_name": data.claim_family_name
            }
        }
        
        sso_config = SSOConfiguration(
            id=str(uuid.uuid4()),
            team_id=team.id,
            provider=SSOProvider.OIDC,
            display_name=data.display_name,
            connection_id=connection_id,
            allowed_domains=",".join(data.allowed_domains) if data.allowed_domains else None,
            auto_provision=data.auto_provision,
            default_role=data.default_role,
            created_by_id=created_by.id
        )
        sso_config.set_config(config)
        
        self.db.add(sso_config)
        
        team.sso_enabled = True
        team.sso_provider = SSOProvider.OIDC.value
        
        self.db.commit()
        self.db.refresh(sso_config)
        
        return sso_config
    
    def get_config(self, team_id: str) -> Optional[SSOConfiguration]:
        """Get SSO configuration for a team."""
        return self.db.query(SSOConfiguration).filter(
            SSOConfiguration.team_id == team_id
        ).first()
    
    def get_config_by_connection(self, connection_id: str) -> Optional[SSOConfiguration]:
        """Get SSO configuration by connection ID."""
        return self.db.query(SSOConfiguration).filter(
            SSOConfiguration.connection_id == connection_id
        ).first()
    
    def update_status(self, config: SSOConfiguration, status: SSOStatus) -> SSOConfiguration:
        """Update SSO configuration status."""
        config.status = status
        self.db.commit()
        self.db.refresh(config)
        return config
    
    def delete_config(self, config: SSOConfiguration) -> None:
        """Delete SSO configuration."""
        team = config.team
        team.sso_enabled = False
        team.sso_provider = None
        
        self.db.delete(config)
        self.db.commit()
    
    # -------------------------------------------------------------------------
    # SAML Authentication
    # -------------------------------------------------------------------------
    
    def initiate_saml_login(
        self,
        config: SSOConfiguration,
        relay_state: Optional[str] = None
    ) -> Tuple[str, str]:
        """Initiate SAML authentication.
        
        Returns:
            Tuple of (redirect_url, state)
        """
        if config.provider != SSOProvider.SAML:
            raise ValueError("Configuration is not SAML")
        
        if config.status not in [SSOStatus.TESTING, SSOStatus.ACTIVE]:
            raise ValueError("SSO is not active")
        
        # Create session
        state = secrets.token_urlsafe(32)
        session = SSOSession(
            id=str(uuid.uuid4()),
            sso_config_id=config.id,
            state=state,
            relay_state=relay_state,
            expires_at=datetime.utcnow() + timedelta(minutes=10)
        )
        self.db.add(session)
        self.db.commit()
        
        # Build SAML AuthnRequest
        saml_config = config.get_config()
        
        # In production, use python3-saml or similar library
        # This is a simplified example
        saml_request = self._build_saml_authn_request(config, state)
        
        # Build redirect URL
        params = {
            "SAMLRequest": saml_request,
            "RelayState": state
        }
        redirect_url = f"{saml_config['idp_sso_url']}?{urlencode(params)}"
        
        return redirect_url, state
    
    def _build_saml_authn_request(self, config: SSOConfiguration, state: str) -> str:
        """Build SAML AuthnRequest.
        
        In production, use python3-saml library for proper request generation.
        """
        import base64
        import zlib
        
        sp_entity_id = f"{self.base_url}/sso/saml/{config.connection_id}/metadata"
        sp_acs_url = f"{self.base_url}/sso/saml/{config.connection_id}/acs"
        
        saml_config = config.get_config()
        
        # Simplified AuthnRequest XML
        authn_request = f"""<?xml version="1.0" encoding="UTF-8"?>
<samlp:AuthnRequest
    xmlns:samlp="urn:oasis:names:tc:SAML:2.0:protocol"
    xmlns:saml="urn:oasis:names:tc:SAML:2.0:assertion"
    ID="_{state}"
    Version="2.0"
    IssueInstant="{datetime.utcnow().isoformat()}Z"
    Destination="{saml_config['idp_sso_url']}"
    AssertionConsumerServiceURL="{sp_acs_url}"
    ProtocolBinding="urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST">
    <saml:Issuer>{sp_entity_id}</saml:Issuer>
    <samlp:NameIDPolicy Format="urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress" AllowCreate="true"/>
</samlp:AuthnRequest>"""
        
        # Compress and encode
        compressed = zlib.compress(authn_request.encode())[2:-4]  # Remove zlib header/checksum
        encoded = base64.b64encode(compressed).decode()
        
        return encoded
    
    def process_saml_response(
        self,
        config: SSOConfiguration,
        saml_response: str,
        state: str
    ) -> Tuple[User, TeamMember]:
        """Process SAML response and authenticate user.
        
        In production, use python3-saml for proper response validation.
        """
        # Validate session
        session = self.db.query(SSOSession).filter(
            SSOSession.state == state,
            SSOSession.sso_config_id == config.id
        ).first()
        
        if not session or not session.is_valid():
            raise ValueError("Invalid or expired SSO session")
        
        # Parse and validate SAML response
        # In production, this would:
        # 1. Decode and decompress response
        # 2. Validate signature against IdP certificate
        # 3. Validate conditions (NotBefore, NotOnOrAfter)
        # 4. Extract attributes
        
        saml_config = config.get_config()
        attributes = self._parse_saml_response(saml_response, saml_config)
        
        # Extract user info
        attr_mapping = saml_config.get("attribute_mapping", {})
        email = attributes.get(attr_mapping.get("email", "email"))
        first_name = attributes.get(attr_mapping.get("first_name", "firstName"), "")
        last_name = attributes.get(attr_mapping.get("last_name", "lastName"), "")
        
        if not email:
            raise ValueError("Email attribute not found in SAML response")
        
        # Validate domain
        if not config.is_domain_allowed(email):
            raise ValueError(f"Email domain not allowed for this SSO connection")
        
        # Find or create user
        user, membership = self._authenticate_sso_user(
            config=config,
            email=email,
            name=f"{first_name} {last_name}".strip() or email.split("@")[0],
            attributes=attributes
        )
        
        # Complete session
        session.completed_at = datetime.utcnow()
        session.user_id = user.id
        
        # Update last login
        config.last_login_at = datetime.utcnow()
        
        self.db.commit()
        
        return user, membership
    
    def _parse_saml_response(self, saml_response: str, config: dict) -> dict:
        """Parse SAML response and extract attributes.
        
        Simplified example - use python3-saml in production.
        """
        import base64
        import xml.etree.ElementTree as ET
        
        # Decode response
        decoded = base64.b64decode(saml_response)
        root = ET.fromstring(decoded)
        
        # Define namespaces
        ns = {
            "samlp": "urn:oasis:names:tc:SAML:2.0:protocol",
            "saml": "urn:oasis:names:tc:SAML:2.0:assertion"
        }
        
        attributes = {}
        
        # Find AttributeStatement
        for attr in root.findall(".//saml:Attribute", ns):
            name = attr.get("Name")
            value_elem = attr.find("saml:AttributeValue", ns)
            if value_elem is not None and value_elem.text:
                attributes[name] = value_elem.text
        
        return attributes
    
    # -------------------------------------------------------------------------
    # OIDC Authentication
    # -------------------------------------------------------------------------
    
    def initiate_oidc_login(
        self,
        config: SSOConfiguration,
        relay_state: Optional[str] = None
    ) -> Tuple[str, str]:
        """Initiate OIDC authentication."""
        if config.provider != SSOProvider.OIDC:
            raise ValueError("Configuration is not OIDC")
        
        if config.status not in [SSOStatus.TESTING, SSOStatus.ACTIVE]:
            raise ValueError("SSO is not active")
        
        oidc_config = config.get_config()
        
        # Generate state and nonce
        state = secrets.token_urlsafe(32)
        nonce = secrets.token_urlsafe(32)
        
        # Create session
        session = SSOSession(
            id=str(uuid.uuid4()),
            sso_config_id=config.id,
            state=state,
            nonce=nonce,
            relay_state=relay_state,
            expires_at=datetime.utcnow() + timedelta(minutes=10)
        )
        self.db.add(session)
        self.db.commit()
        
        # Get authorization endpoint
        auth_endpoint = oidc_config.get("authorization_endpoint")
        if not auth_endpoint:
            # Discover from issuer
            auth_endpoint = self._discover_oidc_endpoint(
                oidc_config["issuer"], 
                "authorization_endpoint"
            )
        
        # Build authorization URL
        redirect_uri = f"{self.base_url}/sso/oidc/{config.connection_id}/callback"
        
        params = {
            "response_type": "code",
            "client_id": oidc_config["client_id"],
            "redirect_uri": redirect_uri,
            "scope": " ".join(oidc_config.get("scopes", ["openid", "email", "profile"])),
            "state": state,
            "nonce": nonce
        }
        
        redirect_url = f"{auth_endpoint}?{urlencode(params)}"
        
        return redirect_url, state
    
    def process_oidc_callback(
        self,
        config: SSOConfiguration,
        code: str,
        state: str
    ) -> Tuple[User, TeamMember]:
        """Process OIDC callback and authenticate user."""
        # Validate session
        session = self.db.query(SSOSession).filter(
            SSOSession.state == state,
            SSOSession.sso_config_id == config.id
        ).first()
        
        if not session or not session.is_valid():
            raise ValueError("Invalid or expired SSO session")
        
        oidc_config = config.get_config()
        
        # Exchange code for tokens
        tokens = self._exchange_oidc_code(config, code)
        
        # Validate ID token
        id_token = tokens.get("id_token")
        if not id_token:
            raise ValueError("No ID token in response")
        
        # Decode and validate ID token
        claims = self._validate_oidc_token(config, id_token, session.nonce)
        
        # Get user info (optionally, for additional claims)
        userinfo = self._get_oidc_userinfo(config, tokens.get("access_token"))
        claims.update(userinfo)
        
        # Extract user info
        claim_mapping = oidc_config.get("claim_mapping", {})
        email = claims.get(claim_mapping.get("email", "email"))
        name = claims.get(claim_mapping.get("name", "name"))
        
        if not name:
            given = claims.get(claim_mapping.get("given_name", "given_name"), "")
            family = claims.get(claim_mapping.get("family_name", "family_name"), "")
            name = f"{given} {family}".strip()
        
        if not email:
            raise ValueError("Email claim not found in ID token")
        
        # Validate domain
        if not config.is_domain_allowed(email):
            raise ValueError(f"Email domain not allowed for this SSO connection")
        
        # Find or create user
        user, membership = self._authenticate_sso_user(
            config=config,
            email=email,
            name=name or email.split("@")[0],
            attributes=claims
        )
        
        # Complete session
        session.completed_at = datetime.utcnow()
        session.user_id = user.id
        
        config.last_login_at = datetime.utcnow()
        
        self.db.commit()
        
        return user, membership
    
    def _exchange_oidc_code(self, config: SSOConfiguration, code: str) -> dict:
        """Exchange authorization code for tokens."""
        import httpx
        
        oidc_config = config.get_config()
        
        token_endpoint = oidc_config.get("token_endpoint")
        if not token_endpoint:
            token_endpoint = self._discover_oidc_endpoint(
                oidc_config["issuer"],
                "token_endpoint"
            )
        
        redirect_uri = f"{self.base_url}/sso/oidc/{config.connection_id}/callback"
        
        response = httpx.post(
            token_endpoint,
            data={
                "grant_type": "authorization_code",
                "code": code,
                "redirect_uri": redirect_uri,
                "client_id": oidc_config["client_id"],
                "client_secret": oidc_config["client_secret"]
            }
        )
        
        if response.status_code != 200:
            raise ValueError(f"Token exchange failed: {response.text}")
        
        return response.json()
    
    def _validate_oidc_token(self, config: SSOConfiguration, id_token: str, expected_nonce: str) -> dict:
        """Validate and decode OIDC ID token."""
        import jwt
        from jwt import PyJWKClient
        
        oidc_config = config.get_config()
        
        # Get JWKS URI
        jwks_uri = oidc_config.get("jwks_uri")
        if not jwks_uri:
            jwks_uri = self._discover_oidc_endpoint(oidc_config["issuer"], "jwks_uri")
        
        # Get signing key
        jwks_client = PyJWKClient(jwks_uri)
        signing_key = jwks_client.get_signing_key_from_jwt(id_token)
        
        # Decode and validate
        claims = jwt.decode(
            id_token,
            signing_key.key,
            algorithms=["RS256"],
            audience=oidc_config["client_id"],
            issuer=oidc_config["issuer"]
        )
        
        # Validate nonce
        if claims.get("nonce") != expected_nonce:
            raise ValueError("Invalid nonce in ID token")
        
        return claims
    
    def _get_oidc_userinfo(self, config: SSOConfiguration, access_token: str) -> dict:
        """Get additional user info from userinfo endpoint."""
        import httpx
        
        oidc_config = config.get_config()
        
        userinfo_endpoint = oidc_config.get("userinfo_endpoint")
        if not userinfo_endpoint:
            userinfo_endpoint = self._discover_oidc_endpoint(
                oidc_config["issuer"],
                "userinfo_endpoint"
            )
        
        if not userinfo_endpoint:
            return {}
        
        response = httpx.get(
            userinfo_endpoint,
            headers={"Authorization": f"Bearer {access_token}"}
        )
        
        if response.status_code != 200:
            return {}
        
        return response.json()
    
    def _discover_oidc_endpoint(self, issuer: str, endpoint: str) -> Optional[str]:
        """Discover OIDC endpoint from well-known configuration."""
        import httpx
        
        discovery_url = f"{issuer.rstrip('/')}/.well-known/openid-configuration"
        
        response = httpx.get(discovery_url)
        if response.status_code != 200:
            return None
        
        config = response.json()
        return config.get(endpoint)
    
    # -------------------------------------------------------------------------
    # User Provisioning
    # -------------------------------------------------------------------------
    
    def _authenticate_sso_user(
        self,
        config: SSOConfiguration,
        email: str,
        name: str,
        attributes: dict
    ) -> Tuple[User, TeamMember]:
        """Find or create user from SSO authentication."""
        # Look for existing user
        user = self.db.query(User).filter(User.email == email.lower()).first()
        
        if not user:
            if not config.auto_provision:
                raise ValueError("User does not exist and auto-provisioning is disabled")
            
            # Create new user
            user = User(
                id=str(uuid.uuid4()),
                email=email.lower(),
                name=name,
                is_active=True,
                email_verified=True,  # SSO emails are considered verified
                sso_provider=config.provider.value,
                sso_subject_id=attributes.get("sub") or attributes.get("nameID")
            )
            self.db.add(user)
        
        # Check/create team membership
        membership = self.db.query(TeamMember).filter(
            TeamMember.team_id == config.team_id,
            TeamMember.user_id == user.id
        ).first()
        
        if not membership:
            # Auto-add to team
            role = MemberRole(config.default_role)
            membership = TeamMember(
                id=str(uuid.uuid4()),
                team_id=config.team_id,
                user_id=user.id,
                role=role
            )
            self.db.add(membership)
        elif not membership.is_active:
            # Reactivate membership
            membership.is_active = True
            membership.deactivated_at = None
        
        return user, membership
    
    # -------------------------------------------------------------------------
    # Service Provider Metadata
    # -------------------------------------------------------------------------
    
    def generate_sp_metadata(self, config: SSOConfiguration) -> str:
        """Generate SAML Service Provider metadata XML."""
        if config.provider != SSOProvider.SAML:
            raise ValueError("Not a SAML configuration")
        
        sp_entity_id = f"{self.base_url}/sso/saml/{config.connection_id}/metadata"
        sp_acs_url = f"{self.base_url}/sso/saml/{config.connection_id}/acs"
        sp_slo_url = f"{self.base_url}/sso/saml/{config.connection_id}/slo"
        
        metadata = f"""<?xml version="1.0" encoding="UTF-8"?>
<md:EntityDescriptor xmlns:md="urn:oasis:names:tc:SAML:2.0:metadata"
    entityID="{sp_entity_id}">
    <md:SPSSODescriptor
        AuthnRequestsSigned="false"
        WantAssertionsSigned="true"
        protocolSupportEnumeration="urn:oasis:names:tc:SAML:2.0:protocol">
        <md:NameIDFormat>urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress</md:NameIDFormat>
        <md:AssertionConsumerService
            Binding="urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST"
            Location="{sp_acs_url}"
            index="0"
            isDefault="true"/>
        <md:SingleLogoutService
            Binding="urn:oasis:names:tc:SAML:2.0:bindings:HTTP-Redirect"
            Location="{sp_slo_url}"/>
    </md:SPSSODescriptor>
</md:EntityDescriptor>"""
        
        return metadata
```

### 4. SSO API Endpoints

**routers/sso.py:**
```python
"""SSO configuration and authentication endpoints."""
from fastapi import APIRouter, Depends, HTTPException, status, Request, Form, Response
from fastapi.responses import RedirectResponse
from sqlalchemy.orm import Session
from typing import Optional

from database import get_db
from auth import get_current_user
from models.user import User
from models.team import TeamMember, MemberRole
from models.sso import SSOProvider, SSOStatus
from schemas.sso import (
    SAMLConfigCreate, OIDCConfigCreate, SSOConfigResponse,
    SSOLoginInitResponse, SSOTestResult
)
from services.sso_service import SSOService
from services.team_service import TeamService
from services.auth_service import AuthService

router = APIRouter(tags=["sso"])


# -----------------------------------------------------------------------------
# Configuration Management (Authenticated)
# -----------------------------------------------------------------------------

@router.post("/api/v1/teams/{team_id}/sso/saml", response_model=SSOConfigResponse)
async def create_saml_config(
    team_id: str,
    data: SAMLConfigCreate,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Create SAML SSO configuration for a team."""
    team_service = TeamService(db)
    team = team_service.get_team(team_id)
    
    if not team:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Team not found")
    
    membership = team_service.get_membership(team_id, current_user.id)
    if not membership or membership.role != MemberRole.OWNER:
        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Owner access required")
    
    sso_service = SSOService(db)
    
    try:
        config = sso_service.create_saml_config(team, data, current_user)
    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))
    
    return _build_config_response(config, sso_service.base_url)


@router.post("/api/v1/teams/{team_id}/sso/oidc", response_model=SSOConfigResponse)
async def create_oidc_config(
    team_id: str,
    data: OIDCConfigCreate,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Create OIDC SSO configuration for a team."""
    team_service = TeamService(db)
    team = team_service.get_team(team_id)
    
    if not team:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Team not found")
    
    membership = team_service.get_membership(team_id, current_user.id)
    if not membership or membership.role != MemberRole.OWNER:
        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Owner access required")
    
    sso_service = SSOService(db)
    
    try:
        config = sso_service.create_oidc_config(team, data, current_user)
    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))
    
    return _build_config_response(config, sso_service.base_url)


@router.get("/api/v1/teams/{team_id}/sso", response_model=SSOConfigResponse)
async def get_sso_config(
    team_id: str,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Get SSO configuration for a team."""
    team_service = TeamService(db)
    membership = team_service.get_membership(team_id, current_user.id)
    
    if not membership or not membership.has_permission(MemberRole.ADMIN):
        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Admin access required")
    
    sso_service = SSOService(db)
    config = sso_service.get_config(team_id)
    
    if not config:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="No SSO configuration found")
    
    return _build_config_response(config, sso_service.base_url)


@router.post("/api/v1/teams/{team_id}/sso/activate")
async def activate_sso(
    team_id: str,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Activate SSO configuration (move from testing to active)."""
    team_service = TeamService(db)
    membership = team_service.get_membership(team_id, current_user.id)
    
    if not membership or membership.role != MemberRole.OWNER:
        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Owner access required")
    
    sso_service = SSOService(db)
    config = sso_service.get_config(team_id)
    
    if not config:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="No SSO configuration found")
    
    if config.status != SSOStatus.TESTING:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="SSO must be in testing status before activation"
        )
    
    config = sso_service.update_status(config, SSOStatus.ACTIVE)
    return {"status": "activated"}


@router.delete("/api/v1/teams/{team_id}/sso")
async def delete_sso_config(
    team_id: str,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Delete SSO configuration."""
    team_service = TeamService(db)
    membership = team_service.get_membership(team_id, current_user.id)
    
    if not membership or membership.role != MemberRole.OWNER:
        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Owner access required")
    
    sso_service = SSOService(db)
    config = sso_service.get_config(team_id)
    
    if not config:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="No SSO configuration found")
    
    sso_service.delete_config(config)
    return {"status": "deleted"}


# -----------------------------------------------------------------------------
# SAML Endpoints (Unauthenticated)
# -----------------------------------------------------------------------------

@router.get("/sso/saml/{connection_id}/metadata")
async def saml_metadata(
    connection_id: str,
    db: Session = Depends(get_db)
):
    """Get SAML Service Provider metadata."""
    sso_service = SSOService(db)
    config = sso_service.get_config_by_connection(connection_id)
    
    if not config or config.provider != SSOProvider.SAML:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="SSO configuration not found")
    
    metadata = sso_service.generate_sp_metadata(config)
    return Response(content=metadata, media_type="application/xml")


@router.get("/sso/saml/{connection_id}/login")
async def saml_login(
    connection_id: str,
    relay_state: Optional[str] = None,
    db: Session = Depends(get_db)
):
    """Initiate SAML login."""
    sso_service = SSOService(db)
    config = sso_service.get_config_by_connection(connection_id)
    
    if not config or config.provider != SSOProvider.SAML:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="SSO configuration not found")
    
    try:
        redirect_url, state = sso_service.initiate_saml_login(config, relay_state)
    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))
    
    return RedirectResponse(url=redirect_url)


@router.post("/sso/saml/{connection_id}/acs")
async def saml_acs(
    connection_id: str,
    SAMLResponse: str = Form(...),
    RelayState: str = Form(...),
    db: Session = Depends(get_db)
):
    """SAML Assertion Consumer Service - process IdP response."""
    sso_service = SSOService(db)
    config = sso_service.get_config_by_connection(connection_id)
    
    if not config or config.provider != SSOProvider.SAML:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="SSO configuration not found")
    
    try:
        user, membership = sso_service.process_saml_response(config, SAMLResponse, RelayState)
    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))
    
    # Generate JWT token
    auth_service = AuthService(db)
    token = auth_service.create_access_token(user)
    
    # Redirect to frontend with token
    redirect_url = f"{sso_service.base_url}/auth/sso-callback?token={token}"
    return RedirectResponse(url=redirect_url, status_code=status.HTTP_302_FOUND)


# -----------------------------------------------------------------------------
# OIDC Endpoints (Unauthenticated)
# -----------------------------------------------------------------------------

@router.get("/sso/oidc/{connection_id}/login")
async def oidc_login(
    connection_id: str,
    relay_state: Optional[str] = None,
    db: Session = Depends(get_db)
):
    """Initiate OIDC login."""
    sso_service = SSOService(db)
    config = sso_service.get_config_by_connection(connection_id)
    
    if not config or config.provider != SSOProvider.OIDC:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="SSO configuration not found")
    
    try:
        redirect_url, state = sso_service.initiate_oidc_login(config, relay_state)
    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))
    
    return RedirectResponse(url=redirect_url)


@router.get("/sso/oidc/{connection_id}/callback")
async def oidc_callback(
    connection_id: str,
    code: str,
    state: str,
    error: Optional[str] = None,
    error_description: Optional[str] = None,
    db: Session = Depends(get_db)
):
    """OIDC callback - process IdP response."""
    if error:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=error_description or error
        )
    
    sso_service = SSOService(db)
    config = sso_service.get_config_by_connection(connection_id)
    
    if not config or config.provider != SSOProvider.OIDC:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="SSO configuration not found")
    
    try:
        user, membership = sso_service.process_oidc_callback(config, code, state)
    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))
    
    # Generate JWT token
    auth_service = AuthService(db)
    token = auth_service.create_access_token(user)
    
    # Redirect to frontend with token
    redirect_url = f"{sso_service.base_url}/auth/sso-callback?token={token}"
    return RedirectResponse(url=redirect_url, status_code=status.HTTP_302_FOUND)


# -----------------------------------------------------------------------------
# Helper Functions
# -----------------------------------------------------------------------------

def _build_config_response(config, base_url: str) -> SSOConfigResponse:
    """Build SSO config response with SP metadata."""
    response = SSOConfigResponse(
        id=config.id,
        team_id=config.team_id,
        provider=config.provider,
        status=config.status,
        display_name=config.display_name,
        connection_id=config.connection_id,
        allowed_domains=config.allowed_domains.split(",") if config.allowed_domains else None,
        auto_provision=config.auto_provision,
        default_role=config.default_role,
        created_at=config.created_at,
        updated_at=config.updated_at,
        last_tested_at=config.last_tested_at,
        last_login_at=config.last_login_at
    )
    
    if config.provider == SSOProvider.SAML:
        response.sp_entity_id = f"{base_url}/sso/saml/{config.connection_id}/metadata"
        response.sp_acs_url = f"{base_url}/sso/saml/{config.connection_id}/acs"
        response.sp_slo_url = f"{base_url}/sso/saml/{config.connection_id}/slo"
        response.sp_metadata_url = f"{base_url}/sso/saml/{config.connection_id}/metadata"
    
    return response
```

## File Structure
```
backend/
├── models/
│   └── sso.py
├── schemas/
│   └── sso.py
├── services/
│   └── sso_service.py
└── routers/
    └── sso.py
```

## Validation Gates

### Gate 1: SAML Configuration
```python
def test_create_saml_config():
    """Verify SAML SSO configuration creation."""
    response = client.post(f"/api/v1/teams/{team_id}/sso/saml", json={
        "display_name": "Sign in with Okta",
        "idp_entity_id": "https://okta.example.com",
        "idp_sso_url": "https://okta.example.com/sso",
        "idp_certificate": "-----BEGIN CERTIFICATE-----\n...\n-----END CERTIFICATE-----"
    }, headers=owner_headers)
    
    assert response.status_code == 200
    data = response.json()
    assert data["provider"] == "saml"
    assert data["sp_metadata_url"] is not None
```

### Gate 2: OIDC Configuration
```python
def test_create_oidc_config():
    """Verify OIDC SSO configuration creation."""
    response = client.post(f"/api/v1/teams/{team_id}/sso/oidc", json={
        "display_name": "Sign in with Google",
        "issuer": "https://accounts.google.com",
        "client_id": "test-client-id",
        "client_secret": "test-client-secret"
    }, headers=owner_headers)
    
    assert response.status_code == 200
    data = response.json()
    assert data["provider"] == "oidc"
```

### Gate 3: SP Metadata Generation
```python
def test_saml_metadata():
    """Verify SAML SP metadata is accessible."""
    response = client.get(f"/sso/saml/{connection_id}/metadata")
    
    assert response.status_code == 200
    assert "application/xml" in response.headers["content-type"]
    assert "EntityDescriptor" in response.text
```

### Gate 4: Login Flow Initiation
```python
def test_sso_login_redirect():
    """Verify SSO login redirects to IdP."""
    response = client.get(
        f"/sso/saml/{connection_id}/login",
        follow_redirects=False
    )
    
    assert response.status_code == 307
    assert "SAMLRequest" in response.headers["location"]
```

## Security Considerations

1. **Configuration Encryption**: All sensitive SSO config stored encrypted
2. **State Validation**: CSRF protection via state parameter
3. **Nonce Validation**: OIDC replay attack prevention
4. **Certificate Validation**: SAML response signature verification
5. **Domain Restrictions**: Email domain allowlisting
6. **Session Expiration**: Short-lived SSO sessions (10 minutes)
7. **Secure Token Exchange**: HTTPS-only, server-side code exchange

## Definition of Done
- [ ] SSOConfiguration model with encryption
- [ ] SSOSession model for state management
- [ ] SAML configuration creation and storage
- [ ] OIDC configuration creation and storage
- [ ] SAML AuthnRequest generation
- [ ] SAML response parsing and validation
- [ ] OIDC authorization flow
- [ ] OIDC token validation (JWT)
- [ ] User auto-provisioning on first login
- [ ] SP metadata generation
- [ ] All validation gates passing
