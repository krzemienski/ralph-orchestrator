# Plan 13-02: Team Collaboration Features (Shared Stories, Roles)

## Overview
Implement team-based story sharing and collaboration features, enabling team members to create, view, and manage stories within their team workspace. This includes story ownership transfer, team story collections, and visibility controls.

## Dependencies
- Plan 13-01 complete (Team/organization data model)
- Phase 9 complete (Story sharing features)
- Database schema with team relationships

## Implementation

### 1. Update Story Model for Team Support

**models/story.py (updates):**
```python
"""Story model with team support."""
from sqlalchemy import Column, String, DateTime, ForeignKey, Enum as SQLEnum, Boolean
from sqlalchemy.orm import relationship

from database import Base
from models.team import MemberRole


class StoryVisibility(str, Enum):
    """Story visibility levels."""
    PRIVATE = "private"       # Only owner can see
    TEAM = "team"             # All team members can see
    PUBLIC = "public"         # Anyone with link can see


class StoryPermission(str, Enum):
    """Granular story permissions."""
    VIEW = "view"
    EDIT = "edit"
    DELETE = "delete"
    SHARE = "share"
    TRANSFER = "transfer"


class Story(Base):
    """Story model with team support."""
    __tablename__ = "stories"
    
    # ... existing fields ...
    
    # Team ownership
    team_id = Column(String(36), ForeignKey("teams.id"), nullable=True, index=True)
    
    # Visibility
    visibility = Column(
        SQLEnum(StoryVisibility), 
        default=StoryVisibility.PRIVATE, 
        nullable=False
    )
    
    # Collaborator management
    allow_comments = Column(Boolean, default=True)
    allow_team_edit = Column(Boolean, default=False)  # Team members can edit
    
    # Relationships
    team = relationship("Team", back_populates="stories")
    collaborators = relationship("StoryCollaborator", back_populates="story", cascade="all, delete-orphan")
    comments = relationship("StoryComment", back_populates="story", cascade="all, delete-orphan")
    activity_log = relationship("StoryActivity", back_populates="story", cascade="all, delete-orphan")
    
    def get_effective_visibility(self) -> StoryVisibility:
        """Get effective visibility considering team settings."""
        if self.team_id and self.visibility == StoryVisibility.PRIVATE:
            # Private within team context means team-only
            return StoryVisibility.TEAM
        return self.visibility
    
    def can_user_access(self, user_id: str, team_membership: Optional["TeamMember"] = None) -> bool:
        """Check if user can access this story."""
        # Owner always has access
        if self.user_id == user_id:
            return True
        
        # Public stories are accessible to all
        if self.visibility == StoryVisibility.PUBLIC:
            return True
        
        # Team stories accessible to team members
        if self.visibility == StoryVisibility.TEAM and team_membership:
            return team_membership.team_id == self.team_id and team_membership.is_active
        
        # Check collaborator list
        for collab in self.collaborators:
            if collab.user_id == user_id and collab.is_active:
                return True
        
        return False


class StoryCollaborator(Base):
    """Explicit collaborators on a story."""
    __tablename__ = "story_collaborators"
    
    id = Column(String(36), primary_key=True)
    story_id = Column(String(36), ForeignKey("stories.id", ondelete="CASCADE"), nullable=False)
    user_id = Column(String(36), ForeignKey("users.id", ondelete="CASCADE"), nullable=False)
    
    # Permissions
    can_edit = Column(Boolean, default=False)
    can_share = Column(Boolean, default=False)
    can_delete = Column(Boolean, default=False)
    
    # Metadata
    added_by_id = Column(String(36), ForeignKey("users.id"), nullable=False)
    added_at = Column(DateTime, default=datetime.utcnow)
    is_active = Column(Boolean, default=True)
    
    # Relationships
    story = relationship("Story", back_populates="collaborators")
    user = relationship("User", foreign_keys=[user_id])
    added_by = relationship("User", foreign_keys=[added_by_id])


class StoryComment(Base):
    """Comments on stories."""
    __tablename__ = "story_comments"
    
    id = Column(String(36), primary_key=True)
    story_id = Column(String(36), ForeignKey("stories.id", ondelete="CASCADE"), nullable=False)
    user_id = Column(String(36), ForeignKey("users.id", ondelete="CASCADE"), nullable=False)
    
    # Content
    content = Column(Text, nullable=False)
    chapter_id = Column(String(36), nullable=True)  # Optional: comment on specific chapter
    timestamp_seconds = Column(Integer, nullable=True)  # Optional: comment at specific time
    
    # Threading
    parent_id = Column(String(36), ForeignKey("story_comments.id"), nullable=True)
    
    # Status
    is_resolved = Column(Boolean, default=False)
    resolved_by_id = Column(String(36), ForeignKey("users.id"), nullable=True)
    resolved_at = Column(DateTime, nullable=True)
    
    # Lifecycle
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    deleted_at = Column(DateTime, nullable=True)
    
    # Relationships
    story = relationship("Story", back_populates="comments")
    user = relationship("User", foreign_keys=[user_id])
    parent = relationship("StoryComment", remote_side=[id])
    replies = relationship("StoryComment")


class StoryActivity(Base):
    """Activity log for stories."""
    __tablename__ = "story_activities"
    
    id = Column(String(36), primary_key=True)
    story_id = Column(String(36), ForeignKey("stories.id", ondelete="CASCADE"), nullable=False)
    user_id = Column(String(36), ForeignKey("users.id"), nullable=True)  # Null for system actions
    
    # Activity
    action = Column(String(50), nullable=False)  # created, edited, shared, transferred, etc.
    details = Column(Text, nullable=True)  # JSON with action-specific details
    
    # Timestamp
    created_at = Column(DateTime, default=datetime.utcnow)
    
    # Relationships
    story = relationship("Story", back_populates="activity_log")
    user = relationship("User")
```

### 2. Team Story Service

**services/team_story_service.py:**
```python
"""Team story collaboration service."""
import uuid
from datetime import datetime
from typing import Optional, List, Tuple
from sqlalchemy.orm import Session
from sqlalchemy import or_, and_

from models.story import Story, StoryVisibility, StoryCollaborator, StoryComment, StoryActivity
from models.team import Team, TeamMember, MemberRole
from models.user import User


class TeamStoryService:
    """Service for team story operations."""
    
    def __init__(self, db: Session):
        self.db = db
    
    # -------------------------------------------------------------------------
    # Story Access & Listing
    # -------------------------------------------------------------------------
    
    def list_team_stories(
        self,
        team: Team,
        member: TeamMember,
        include_all: bool = False
    ) -> List[Story]:
        """List stories visible to a team member."""
        query = self.db.query(Story).filter(
            Story.team_id == team.id,
            Story.deleted_at.is_(None)
        )
        
        # Filter by visibility based on role
        if not include_all or not member.has_permission(MemberRole.ADMIN):
            # Non-admins see team stories and their own private stories
            query = query.filter(
                or_(
                    Story.visibility == StoryVisibility.TEAM,
                    Story.visibility == StoryVisibility.PUBLIC,
                    Story.user_id == member.user_id
                )
            )
        
        return query.order_by(Story.created_at.desc()).all()
    
    def can_access_story(
        self,
        story: Story,
        user: User,
        membership: Optional[TeamMember] = None
    ) -> bool:
        """Check if user can access a story."""
        # Owner always has access
        if story.user_id == user.id:
            return True
        
        # Public stories
        if story.visibility == StoryVisibility.PUBLIC:
            return True
        
        # Team stories - check membership
        if story.team_id and membership:
            if membership.team_id == story.team_id and membership.is_active:
                if story.visibility in [StoryVisibility.TEAM, StoryVisibility.PUBLIC]:
                    return True
        
        # Explicit collaborator
        collab = self.db.query(StoryCollaborator).filter(
            StoryCollaborator.story_id == story.id,
            StoryCollaborator.user_id == user.id,
            StoryCollaborator.is_active == True
        ).first()
        
        return collab is not None
    
    def can_edit_story(
        self,
        story: Story,
        user: User,
        membership: Optional[TeamMember] = None
    ) -> bool:
        """Check if user can edit a story."""
        # Owner can always edit
        if story.user_id == user.id:
            return True
        
        # Team admins can edit team stories
        if story.team_id and membership:
            if membership.team_id == story.team_id and membership.has_permission(MemberRole.ADMIN):
                return True
            
            # Check if team edit is allowed
            if story.allow_team_edit and membership.has_permission(MemberRole.MEMBER):
                return True
        
        # Explicit edit permission
        collab = self.db.query(StoryCollaborator).filter(
            StoryCollaborator.story_id == story.id,
            StoryCollaborator.user_id == user.id,
            StoryCollaborator.is_active == True,
            StoryCollaborator.can_edit == True
        ).first()
        
        return collab is not None
    
    # -------------------------------------------------------------------------
    # Story Team Assignment
    # -------------------------------------------------------------------------
    
    def assign_to_team(
        self,
        story: Story,
        team: Team,
        user: User,
        visibility: StoryVisibility = StoryVisibility.TEAM
    ) -> Story:
        """Assign a story to a team."""
        # Verify user owns the story
        if story.user_id != user.id:
            raise PermissionError("Only the owner can assign a story to a team")
        
        # Verify user is a team member
        membership = self.db.query(TeamMember).filter(
            TeamMember.team_id == team.id,
            TeamMember.user_id == user.id,
            TeamMember.is_active == True
        ).first()
        
        if not membership:
            raise PermissionError("You must be a team member to assign stories")
        
        # Update story
        story.team_id = team.id
        story.visibility = visibility
        
        # Log activity
        self._log_activity(story, user, "assigned_to_team", {
            "team_id": team.id,
            "team_name": team.name,
            "visibility": visibility.value
        })
        
        self.db.commit()
        self.db.refresh(story)
        
        return story
    
    def remove_from_team(self, story: Story, user: User) -> Story:
        """Remove a story from a team."""
        if story.user_id != user.id:
            # Check if admin
            membership = self.db.query(TeamMember).filter(
                TeamMember.team_id == story.team_id,
                TeamMember.user_id == user.id,
                TeamMember.is_active == True
            ).first()
            
            if not membership or not membership.has_permission(MemberRole.ADMIN):
                raise PermissionError("Only owner or admin can remove stories from team")
        
        old_team_id = story.team_id
        story.team_id = None
        story.visibility = StoryVisibility.PRIVATE
        
        # Log activity
        self._log_activity(story, user, "removed_from_team", {
            "old_team_id": old_team_id
        })
        
        self.db.commit()
        self.db.refresh(story)
        
        return story
    
    # -------------------------------------------------------------------------
    # Ownership Transfer
    # -------------------------------------------------------------------------
    
    def transfer_ownership(
        self,
        story: Story,
        current_owner: User,
        new_owner: User,
        keep_as_collaborator: bool = True
    ) -> Story:
        """Transfer story ownership to another user."""
        if story.user_id != current_owner.id:
            raise PermissionError("Only the owner can transfer ownership")
        
        # If story is in a team, new owner must be a member
        if story.team_id:
            new_owner_membership = self.db.query(TeamMember).filter(
                TeamMember.team_id == story.team_id,
                TeamMember.user_id == new_owner.id,
                TeamMember.is_active == True
            ).first()
            
            if not new_owner_membership:
                raise ValueError("New owner must be a member of the story's team")
        
        old_owner_id = story.user_id
        story.user_id = new_owner.id
        
        # Optionally keep previous owner as collaborator
        if keep_as_collaborator:
            collab = StoryCollaborator(
                id=str(uuid.uuid4()),
                story_id=story.id,
                user_id=old_owner_id,
                can_edit=True,
                can_share=True,
                can_delete=False,
                added_by_id=new_owner.id
            )
            self.db.add(collab)
        
        # Log activity
        self._log_activity(story, current_owner, "transferred_ownership", {
            "from_user_id": old_owner_id,
            "to_user_id": new_owner.id,
            "kept_as_collaborator": keep_as_collaborator
        })
        
        self.db.commit()
        self.db.refresh(story)
        
        return story
    
    # -------------------------------------------------------------------------
    # Collaborators
    # -------------------------------------------------------------------------
    
    def add_collaborator(
        self,
        story: Story,
        user_to_add: User,
        added_by: User,
        can_edit: bool = False,
        can_share: bool = False
    ) -> StoryCollaborator:
        """Add a collaborator to a story."""
        # Check permission
        if not self.can_edit_story(story, added_by):
            raise PermissionError("You don't have permission to add collaborators")
        
        # Check if already a collaborator
        existing = self.db.query(StoryCollaborator).filter(
            StoryCollaborator.story_id == story.id,
            StoryCollaborator.user_id == user_to_add.id
        ).first()
        
        if existing:
            if existing.is_active:
                raise ValueError("User is already a collaborator")
            # Reactivate
            existing.is_active = True
            existing.can_edit = can_edit
            existing.can_share = can_share
            self.db.commit()
            return existing
        
        collab = StoryCollaborator(
            id=str(uuid.uuid4()),
            story_id=story.id,
            user_id=user_to_add.id,
            can_edit=can_edit,
            can_share=can_share,
            can_delete=False,
            added_by_id=added_by.id
        )
        self.db.add(collab)
        
        # Log activity
        self._log_activity(story, added_by, "added_collaborator", {
            "collaborator_id": user_to_add.id,
            "can_edit": can_edit,
            "can_share": can_share
        })
        
        self.db.commit()
        self.db.refresh(collab)
        
        return collab
    
    def remove_collaborator(
        self,
        story: Story,
        collaborator: StoryCollaborator,
        removed_by: User
    ) -> None:
        """Remove a collaborator from a story."""
        # Owner can remove anyone, collaborator can remove themselves
        if story.user_id != removed_by.id and collaborator.user_id != removed_by.id:
            raise PermissionError("You don't have permission to remove this collaborator")
        
        collaborator.is_active = False
        
        # Log activity
        self._log_activity(story, removed_by, "removed_collaborator", {
            "collaborator_id": collaborator.user_id
        })
        
        self.db.commit()
    
    def list_collaborators(self, story: Story) -> List[StoryCollaborator]:
        """List all active collaborators on a story."""
        return self.db.query(StoryCollaborator).filter(
            StoryCollaborator.story_id == story.id,
            StoryCollaborator.is_active == True
        ).all()
    
    # -------------------------------------------------------------------------
    # Comments
    # -------------------------------------------------------------------------
    
    def add_comment(
        self,
        story: Story,
        user: User,
        content: str,
        chapter_id: Optional[str] = None,
        timestamp_seconds: Optional[int] = None,
        parent_id: Optional[str] = None
    ) -> StoryComment:
        """Add a comment to a story."""
        if not story.allow_comments:
            raise ValueError("Comments are disabled for this story")
        
        comment = StoryComment(
            id=str(uuid.uuid4()),
            story_id=story.id,
            user_id=user.id,
            content=content,
            chapter_id=chapter_id,
            timestamp_seconds=timestamp_seconds,
            parent_id=parent_id
        )
        self.db.add(comment)
        
        # Log activity
        self._log_activity(story, user, "added_comment", {
            "comment_id": comment.id,
            "chapter_id": chapter_id,
            "is_reply": parent_id is not None
        })
        
        self.db.commit()
        self.db.refresh(comment)
        
        return comment
    
    def resolve_comment(
        self,
        comment: StoryComment,
        resolved_by: User
    ) -> StoryComment:
        """Mark a comment as resolved."""
        comment.is_resolved = True
        comment.resolved_by_id = resolved_by.id
        comment.resolved_at = datetime.utcnow()
        
        self.db.commit()
        self.db.refresh(comment)
        
        return comment
    
    def list_comments(
        self,
        story: Story,
        chapter_id: Optional[str] = None,
        include_resolved: bool = True
    ) -> List[StoryComment]:
        """List comments on a story."""
        query = self.db.query(StoryComment).filter(
            StoryComment.story_id == story.id,
            StoryComment.deleted_at.is_(None)
        )
        
        if chapter_id:
            query = query.filter(StoryComment.chapter_id == chapter_id)
        
        if not include_resolved:
            query = query.filter(StoryComment.is_resolved == False)
        
        return query.order_by(StoryComment.created_at).all()
    
    # -------------------------------------------------------------------------
    # Activity Log
    # -------------------------------------------------------------------------
    
    def _log_activity(
        self,
        story: Story,
        user: Optional[User],
        action: str,
        details: dict
    ) -> StoryActivity:
        """Log an activity on a story."""
        import json
        
        activity = StoryActivity(
            id=str(uuid.uuid4()),
            story_id=story.id,
            user_id=user.id if user else None,
            action=action,
            details=json.dumps(details)
        )
        self.db.add(activity)
        return activity
    
    def get_activity_log(
        self,
        story: Story,
        limit: int = 50
    ) -> List[StoryActivity]:
        """Get activity log for a story."""
        return self.db.query(StoryActivity).filter(
            StoryActivity.story_id == story.id
        ).order_by(StoryActivity.created_at.desc()).limit(limit).all()
```

### 3. Collaboration Schemas

**schemas/collaboration.py:**
```python
"""Collaboration-related Pydantic schemas."""
from datetime import datetime
from typing import Optional, List
from pydantic import BaseModel, Field
from enum import Enum

from models.story import StoryVisibility


class StoryVisibilityUpdate(BaseModel):
    """Schema for updating story visibility."""
    visibility: StoryVisibility
    allow_comments: Optional[bool] = None
    allow_team_edit: Optional[bool] = None


class AssignToTeamRequest(BaseModel):
    """Schema for assigning story to team."""
    team_id: str
    visibility: StoryVisibility = StoryVisibility.TEAM


class TransferOwnershipRequest(BaseModel):
    """Schema for transferring story ownership."""
    new_owner_id: str
    keep_as_collaborator: bool = True


class AddCollaboratorRequest(BaseModel):
    """Schema for adding a collaborator."""
    user_id: str
    can_edit: bool = False
    can_share: bool = False


class CollaboratorResponse(BaseModel):
    """Schema for collaborator response."""
    id: str
    user_id: str
    user_email: str
    user_name: str
    can_edit: bool
    can_share: bool
    can_delete: bool
    added_at: datetime
    
    class Config:
        from_attributes = True


class AddCommentRequest(BaseModel):
    """Schema for adding a comment."""
    content: str = Field(..., min_length=1, max_length=5000)
    chapter_id: Optional[str] = None
    timestamp_seconds: Optional[int] = Field(None, ge=0)
    parent_id: Optional[str] = None


class CommentResponse(BaseModel):
    """Schema for comment response."""
    id: str
    user_id: str
    user_name: str
    user_avatar_url: Optional[str]
    content: str
    chapter_id: Optional[str]
    timestamp_seconds: Optional[int]
    parent_id: Optional[str]
    is_resolved: bool
    resolved_by_name: Optional[str]
    resolved_at: Optional[datetime]
    created_at: datetime
    updated_at: datetime
    replies: List["CommentResponse"] = []
    
    class Config:
        from_attributes = True


class ActivityResponse(BaseModel):
    """Schema for activity log entry."""
    id: str
    user_name: Optional[str]
    action: str
    details: dict
    created_at: datetime
    
    class Config:
        from_attributes = True


# Forward reference resolution
CommentResponse.model_rebuild()
```

### 4. Collaboration API Endpoints

**routers/collaboration.py:**
```python
"""Story collaboration API endpoints."""
from fastapi import APIRouter, Depends, HTTPException, status, Query
from sqlalchemy.orm import Session
from typing import List, Optional

from database import get_db
from auth import get_current_user
from models.user import User
from models.story import Story, StoryVisibility
from models.team import TeamMember
from schemas.collaboration import (
    StoryVisibilityUpdate, AssignToTeamRequest, TransferOwnershipRequest,
    AddCollaboratorRequest, CollaboratorResponse,
    AddCommentRequest, CommentResponse,
    ActivityResponse
)
from services.team_story_service import TeamStoryService
from services.team_service import TeamService

router = APIRouter(prefix="/api/v1/stories/{story_id}/collaboration", tags=["collaboration"])


def get_story_and_verify_access(
    story_id: str,
    current_user: User,
    db: Session,
    require_edit: bool = False
) -> tuple[Story, Optional[TeamMember]]:
    """Helper to get story and verify access."""
    story = db.query(Story).filter(
        Story.id == story_id,
        Story.deleted_at.is_(None)
    ).first()
    
    if not story:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Story not found")
    
    # Get team membership if applicable
    membership = None
    if story.team_id:
        membership = db.query(TeamMember).filter(
            TeamMember.team_id == story.team_id,
            TeamMember.user_id == current_user.id,
            TeamMember.is_active == True
        ).first()
    
    service = TeamStoryService(db)
    
    if require_edit:
        if not service.can_edit_story(story, current_user, membership):
            raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Edit access required")
    else:
        if not service.can_access_story(story, current_user, membership):
            raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Access denied")
    
    return story, membership


# -----------------------------------------------------------------------------
# Visibility & Team Assignment
# -----------------------------------------------------------------------------

@router.patch("/visibility")
async def update_visibility(
    story_id: str,
    data: StoryVisibilityUpdate,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Update story visibility settings."""
    story, membership = get_story_and_verify_access(story_id, current_user, db, require_edit=True)
    
    # Only owner can change visibility
    if story.user_id != current_user.id:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN, 
            detail="Only owner can change visibility"
        )
    
    story.visibility = data.visibility
    if data.allow_comments is not None:
        story.allow_comments = data.allow_comments
    if data.allow_team_edit is not None:
        story.allow_team_edit = data.allow_team_edit
    
    db.commit()
    
    return {"status": "updated", "visibility": story.visibility.value}


@router.post("/assign-team")
async def assign_to_team(
    story_id: str,
    data: AssignToTeamRequest,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Assign story to a team."""
    story, _ = get_story_and_verify_access(story_id, current_user, db)
    
    team_service = TeamService(db)
    team = team_service.get_team(data.team_id)
    
    if not team:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Team not found")
    
    service = TeamStoryService(db)
    
    try:
        story = service.assign_to_team(story, team, current_user, data.visibility)
    except (PermissionError, ValueError) as e:
        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail=str(e))
    
    return {"status": "assigned", "team_id": team.id, "team_name": team.name}


@router.post("/remove-from-team")
async def remove_from_team(
    story_id: str,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Remove story from team."""
    story, membership = get_story_and_verify_access(story_id, current_user, db)
    
    if not story.team_id:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="Story is not in a team")
    
    service = TeamStoryService(db)
    
    try:
        story = service.remove_from_team(story, current_user)
    except PermissionError as e:
        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail=str(e))
    
    return {"status": "removed"}


@router.post("/transfer")
async def transfer_ownership(
    story_id: str,
    data: TransferOwnershipRequest,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Transfer story ownership."""
    story, _ = get_story_and_verify_access(story_id, current_user, db)
    
    new_owner = db.query(User).filter(User.id == data.new_owner_id).first()
    if not new_owner:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="User not found")
    
    service = TeamStoryService(db)
    
    try:
        story = service.transfer_ownership(story, current_user, new_owner, data.keep_as_collaborator)
    except (PermissionError, ValueError) as e:
        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail=str(e))
    
    return {"status": "transferred", "new_owner_id": new_owner.id}


# -----------------------------------------------------------------------------
# Collaborators
# -----------------------------------------------------------------------------

@router.get("/collaborators", response_model=List[CollaboratorResponse])
async def list_collaborators(
    story_id: str,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """List story collaborators."""
    story, _ = get_story_and_verify_access(story_id, current_user, db)
    
    service = TeamStoryService(db)
    collaborators = service.list_collaborators(story)
    
    return [
        CollaboratorResponse(
            id=c.id,
            user_id=c.user_id,
            user_email=c.user.email,
            user_name=c.user.name,
            can_edit=c.can_edit,
            can_share=c.can_share,
            can_delete=c.can_delete,
            added_at=c.added_at
        )
        for c in collaborators
    ]


@router.post("/collaborators", response_model=CollaboratorResponse)
async def add_collaborator(
    story_id: str,
    data: AddCollaboratorRequest,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Add a collaborator to the story."""
    story, membership = get_story_and_verify_access(story_id, current_user, db, require_edit=True)
    
    user_to_add = db.query(User).filter(User.id == data.user_id).first()
    if not user_to_add:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="User not found")
    
    service = TeamStoryService(db)
    
    try:
        collab = service.add_collaborator(
            story, user_to_add, current_user,
            can_edit=data.can_edit,
            can_share=data.can_share
        )
    except (PermissionError, ValueError) as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))
    
    return CollaboratorResponse(
        id=collab.id,
        user_id=collab.user_id,
        user_email=collab.user.email,
        user_name=collab.user.name,
        can_edit=collab.can_edit,
        can_share=collab.can_share,
        can_delete=collab.can_delete,
        added_at=collab.added_at
    )


@router.delete("/collaborators/{collaborator_id}")
async def remove_collaborator(
    story_id: str,
    collaborator_id: str,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Remove a collaborator from the story."""
    story, _ = get_story_and_verify_access(story_id, current_user, db)
    
    from models.story import StoryCollaborator
    collab = db.query(StoryCollaborator).filter(
        StoryCollaborator.id == collaborator_id,
        StoryCollaborator.story_id == story_id
    ).first()
    
    if not collab:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Collaborator not found")
    
    service = TeamStoryService(db)
    
    try:
        service.remove_collaborator(story, collab, current_user)
    except PermissionError as e:
        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail=str(e))
    
    return {"status": "removed"}


# -----------------------------------------------------------------------------
# Comments
# -----------------------------------------------------------------------------

@router.get("/comments", response_model=List[CommentResponse])
async def list_comments(
    story_id: str,
    chapter_id: Optional[str] = Query(None),
    include_resolved: bool = Query(True),
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """List comments on a story."""
    story, _ = get_story_and_verify_access(story_id, current_user, db)
    
    service = TeamStoryService(db)
    comments = service.list_comments(story, chapter_id, include_resolved)
    
    def format_comment(c) -> CommentResponse:
        return CommentResponse(
            id=c.id,
            user_id=c.user_id,
            user_name=c.user.name,
            user_avatar_url=getattr(c.user, 'avatar_url', None),
            content=c.content,
            chapter_id=c.chapter_id,
            timestamp_seconds=c.timestamp_seconds,
            parent_id=c.parent_id,
            is_resolved=c.is_resolved,
            resolved_by_name=c.resolved_by.name if c.resolved_by else None,
            resolved_at=c.resolved_at,
            created_at=c.created_at,
            updated_at=c.updated_at,
            replies=[format_comment(r) for r in c.replies if r.deleted_at is None]
        )
    
    # Return only top-level comments (replies are nested)
    top_level = [c for c in comments if c.parent_id is None]
    return [format_comment(c) for c in top_level]


@router.post("/comments", response_model=CommentResponse)
async def add_comment(
    story_id: str,
    data: AddCommentRequest,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Add a comment to the story."""
    story, _ = get_story_and_verify_access(story_id, current_user, db)
    
    service = TeamStoryService(db)
    
    try:
        comment = service.add_comment(
            story, current_user, data.content,
            chapter_id=data.chapter_id,
            timestamp_seconds=data.timestamp_seconds,
            parent_id=data.parent_id
        )
    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))
    
    return CommentResponse(
        id=comment.id,
        user_id=comment.user_id,
        user_name=comment.user.name,
        user_avatar_url=getattr(comment.user, 'avatar_url', None),
        content=comment.content,
        chapter_id=comment.chapter_id,
        timestamp_seconds=comment.timestamp_seconds,
        parent_id=comment.parent_id,
        is_resolved=comment.is_resolved,
        resolved_by_name=None,
        resolved_at=None,
        created_at=comment.created_at,
        updated_at=comment.updated_at,
        replies=[]
    )


@router.post("/comments/{comment_id}/resolve")
async def resolve_comment(
    story_id: str,
    comment_id: str,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Mark a comment as resolved."""
    story, _ = get_story_and_verify_access(story_id, current_user, db, require_edit=True)
    
    from models.story import StoryComment
    comment = db.query(StoryComment).filter(
        StoryComment.id == comment_id,
        StoryComment.story_id == story_id
    ).first()
    
    if not comment:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Comment not found")
    
    service = TeamStoryService(db)
    comment = service.resolve_comment(comment, current_user)
    
    return {"status": "resolved"}


# -----------------------------------------------------------------------------
# Activity Log
# -----------------------------------------------------------------------------

@router.get("/activity", response_model=List[ActivityResponse])
async def get_activity_log(
    story_id: str,
    limit: int = Query(50, ge=1, le=200),
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Get story activity log."""
    story, _ = get_story_and_verify_access(story_id, current_user, db)
    
    service = TeamStoryService(db)
    activities = service.get_activity_log(story, limit)
    
    import json
    return [
        ActivityResponse(
            id=a.id,
            user_name=a.user.name if a.user else "System",
            action=a.action,
            details=json.loads(a.details) if a.details else {},
            created_at=a.created_at
        )
        for a in activities
    ]
```

## File Structure
```
backend/
├── models/
│   └── story.py (updated)
├── schemas/
│   └── collaboration.py
├── services/
│   └── team_story_service.py
└── routers/
    └── collaboration.py
```

## Validation Gates

### Gate 1: Team Story Assignment
```python
def test_assign_story_to_team():
    """Verify story can be assigned to team."""
    # Create story
    story_resp = client.post("/api/v1/stories", json={
        "repo_url": "https://github.com/test/repo"
    }, headers=user_headers)
    story_id = story_resp.json()["id"]
    
    # Assign to team
    assign_resp = client.post(
        f"/api/v1/stories/{story_id}/collaboration/assign-team",
        json={"team_id": team_id, "visibility": "team"},
        headers=user_headers
    )
    
    assert assign_resp.status_code == 200
    
    # Team member can now see story
    list_resp = client.get(f"/api/v1/teams/{team_id}/stories", headers=member_headers)
    assert any(s["id"] == story_id for s in list_resp.json())
```

### Gate 2: Collaborator Permissions
```python
def test_collaborator_permissions():
    """Verify collaborator access control."""
    # Add collaborator with edit permission
    client.post(
        f"/api/v1/stories/{story_id}/collaboration/collaborators",
        json={"user_id": other_user_id, "can_edit": True},
        headers=owner_headers
    )
    
    # Collaborator can edit
    edit_resp = client.patch(
        f"/api/v1/stories/{story_id}",
        json={"title": "Updated Title"},
        headers=collaborator_headers
    )
    assert edit_resp.status_code == 200
    
    # Collaborator cannot delete
    delete_resp = client.delete(f"/api/v1/stories/{story_id}", headers=collaborator_headers)
    assert delete_resp.status_code == 403
```

### Gate 3: Comment Threading
```python
def test_comment_threading():
    """Verify comment threading works."""
    # Add comment
    comment_resp = client.post(
        f"/api/v1/stories/{story_id}/collaboration/comments",
        json={"content": "Great story!"},
        headers=user_headers
    )
    comment_id = comment_resp.json()["id"]
    
    # Add reply
    reply_resp = client.post(
        f"/api/v1/stories/{story_id}/collaboration/comments",
        json={"content": "Thanks!", "parent_id": comment_id},
        headers=owner_headers
    )
    
    assert reply_resp.status_code == 200
    
    # List comments - reply should be nested
    list_resp = client.get(f"/api/v1/stories/{story_id}/collaboration/comments", headers=user_headers)
    comments = list_resp.json()
    assert len(comments) == 1  # Only top-level
    assert len(comments[0]["replies"]) == 1
```

## Definition of Done
- [ ] Story model updated with team and visibility fields
- [ ] StoryCollaborator model for explicit sharing
- [ ] StoryComment model with threading support
- [ ] StoryActivity model for audit logging
- [ ] TeamStoryService with all collaboration logic
- [ ] Team story listing with visibility filtering
- [ ] Ownership transfer functionality
- [ ] Collaborator management (add/remove/permissions)
- [ ] Comment system with threading and resolution
- [ ] Activity log for story changes
- [ ] All validation gates passing
